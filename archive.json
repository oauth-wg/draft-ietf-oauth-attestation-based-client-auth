{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-09-26T00:10:42.606750+00:00",
  "repo": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "pending-close",
      "description": "",
      "color": "D76CC5"
    },
    {
      "name": "discuss",
      "description": "",
      "color": "03BA91"
    },
    {
      "name": "ready-for-pr",
      "description": "",
      "color": "19E11B"
    }
  ],
  "issues": [
    {
      "number": 3,
      "id": "I_kwDOJaEkaM5lbyhk",
      "title": "Trust",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/3",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "make it clear that the receiver of the attestation needs to trust the signer of the attestation and pre-obtain(?) the keys to validate it?",
      "createdAt": "2023-05-09T10:10:14Z",
      "updatedAt": "2023-09-06T06:58:42Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would imagine the client is configured/registered with the AS and the jwks or jwks_uri of that client is where the verification keys are found. Basically the trust comes from the client configuration record at the AS (however that comes to be) and the keys are obtained from the client jwks/jwks_uri metadata.",
          "createdAt": "2023-05-10T17:58:41Z",
          "updatedAt": "2023-05-10T17:58:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with Brian, I dont think we want this draft to define how the keys required to validate the attestation MUST be obtained because that is really based on how the client comes to be configured at the AS and as a result there could be multiple mechanisms. There may be a need to add some language that makes this clearly however I will note that RFC 7523 doesn't speak to this for the assertions it defines.",
          "createdAt": "2023-05-11T09:54:19Z",
          "updatedAt": "2023-05-11T09:54:19Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The key point is the digital trust relationship that allows a client to be registered and attestable as realiable and eligible in relation to one or more trust frameworks, and for any following transactions, outside the client registration, that may happen in a defined period of time, beyond which trust with that client must be re-evaluated.\r\n\r\nGiven that having a client registered previously or obtaining its public keys though TLS doesn't give any assurance about the compliance of that client in the present, in relation to privacy and security preserving trust model. We shoudl consider that a client, that's a participant in a Auth/eID infrastructure, may lose its compliance and consequently be banned because of this. The requirement to be met is to allow an automatic method for evaluating the revocation status of the client, if the determining authority (TTP) is outside the party (AS and Client)\r\n\r\nanother key point is that trusted attestations, which allow a customer to be registered and then allow data interchange with it, are considered long-lived attestations, for the satisfaction of non-repudiation requirements for years to come.",
          "createdAt": "2023-05-11T14:49:33Z",
          "updatedAt": "2023-05-11T14:49:33Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just to add a bit of context about the comment about RFC 7523 - it doesn't speak to this stuff in specific terms but does have some discussion in [Interoperability Considerations](https://datatracker.ietf.org/doc/html/rfc7523#section-5) that's pretty open ended. RFC7523 came before \"Dynamic Client Registration\" in RFC7591. But since then the metadata defined in RFC7591, and registered extensions to it, have come to imply a general data model for clients that is useful and used for authorization server implementations, even when the Dynamic Client Registration Protocol isn't in play. That includes jwks/jwks_uri metadata as the place for key(s). OIDC core kinda follows and pushes that pattern too and even 'profiles' RFC7591 somewhat with its definition of `private_key_jwt`.  So, regardless of how a client comes to be configured, the jwks or jwks_uri client metadata fields really have become the de facto for where/how client keys are obtained. I think this draft could acknowledge and/or provide some guidance in that direction. The AS would have one client config record for the whole client system and the verification keys for the attestation assertion come from the jwks or jwks_uri fields of that record. \"Trust\" comes from how that client record comes to be configured, but that how is out of scope of this draft. \r\n",
          "createdAt": "2023-05-11T18:28:31Z",
          "updatedAt": "2023-05-18T23:39:21Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I start from the assumption that OpenID Connect Federation confirms the traditional methods to get the jwks, using jwks/jwks_uri, enabling the jwks claim for the openid connect providers metadata as well.\r\n\r\nI want to start from the example below and answering to the question \"How can you trust such client?\"\r\n\r\n````\r\n{\r\n  \"alg\": \"ES256\",\r\n  \"kid\": \"11\",\r\n  \"trust_chain\": [ ... ]\r\n}\r\n.\r\n{\r\n  \"iss\": \"https://client.example.com\",\r\n  \"sub\": \"https://client.example.com\",\r\n  \"nbf\":1300815780,\r\n  \"exp\":1300819380,\r\n  \"cnf\": {\r\n    \"jwk\": {\r\n      \"kty\": \"EC\",\r\n      \"use\": \"sig\",\r\n      \"crv\": \"P-256\",\r\n      \"x\": \"18wHLeIgW9wVN6VD1Txgpqy2LszYkMf6J8njVAibvhM\",\r\n      \"y\": \"-V4dS4UaLMgP_4fY4j8ir7cl1TXlFdAgcx55o7TkcSA\"\r\n    }\r\n  }\r\n}\r\n````\r\n\r\nif we would have a x5c header parameter instead of the Federation Trust Chain, the Key Attestation would be realiable according to a x509 PKI.\r\n\r\nUsing the Federation Trust Chain we are able to:\r\n\r\n- get the public key corresponding to the kid 11\r\n- get the trust relationships between the client and one or more Trusted Third Parties\r\n- get the metadata related to that client (and all its jwks ...)\r\n- get the policy to be applicable to the metadata, following what configured by the Trusted Third Parties for this client\r\n-  verify the trust chain over years, even if the public keys needed for verification are changed to one or multiple trusted third party or in the client as well\r\n\r\nI'm aware that attesting keys is just attesting keys but the model would require how to attest the owner of that key as reliable?\r\nHow do you trust that client, since it has self issued that attestation?\r\n\r\nI suggest to introduce the topic of Trust Establishment in this Draft, to give some pointers or refs to the ways we have todate to verify the reliability of an attestation, since a self-signed attestation is not attestable as secure.\r\n\r\nAt the same time there may be the possibility that a client attestation should be issued by a trusted third party, so the question would are: \r\n\r\n- Is there a single Trusted Third Party? \r\n- Is there any way the Trusted Third Party has to delegate the issuing of the attestations to another party as an intermediate?\r\n- Is there the need to obtain the public keys of all the Trusted Third Parties, if more than a single? If yes, how to know who these are?\r\n\r\nI'm asking since I found these answers in OpenID Connect Federation and the questions above are the classical questions the analysts/implementers have when deals with client attestations or dynamic client registrations ",
          "createdAt": "2023-05-20T17:01:34Z",
          "updatedAt": "2023-05-20T22:56:42Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another example to exemplify the differences bwtween key attestation and assurance of reliability. \r\n\r\nA crypto key Is a key Just as a Key of a hotel room\r\n\r\nGiven that that Key effectively works for its hotel room, the question Is: which reputation has that hotel?\r\nHow many \"stars\" does It have?\r\nWho give those \"stars\"?\r\nWhich are the evaluation parameters and for how long  will these be valid?\r\nWill be a day when the hotel owner may say to have never give that room to a client, or that such client was never seen before?\r\nWhich trust framework will protect both hotel owner and client from unwanted actions they may do against each other?\r\n\r\nassurance of reliability is something verifiable, even If I'm aware that Trust is more a strategy and the Trust Model should define the rules and the architectural components to implement this strategy. A Strategy won't give us the assurance that a bad action won't be made by an Entity but at the same time the model must give also the assurance that every proof must be non repudiable and issued as long-lived, to give the guarantee to the participants that even if a rogue participant will break the rules of the trust, the proofs will be always verifiable in the future (especially when public keys will change)",
          "createdAt": "2023-05-21T21:55:39Z",
          "updatedAt": "2023-05-21T21:56:17Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOJaEkaM5l2HJe",
      "title": "`sub` value",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/4",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The text currently says:\r\n> The JWT MUST contain a \"sub\" (subject) claim with a value corresponding to the \"client_id\" of the OAuth client.\r\n\r\nthe thing is.. when there could been no pre-existing relationship between the issuer and the wallet. probably worth noting that `sub` (and `client_id` value) can be self-attested by the wallet frontend",
      "createdAt": "2023-05-13T16:58:41Z",
      "updatedAt": "2023-11-08T00:22:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I dont think we want to offer too much commentary here about how the client ends up with a client ID that is recognised and trusted by the AS (credential issuer), but I agree the case you raise is permitted.",
          "createdAt": "2023-05-14T23:47:44Z",
          "updatedAt": "2023-05-14T23:47:44Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Shouldn't we at least describe what identifier is used for further processing (whether to lookup further data or in audit logs)? If the AS trusts the Issuer of the JWT, it should trust it to put a reasonable value in the `sub` field for further usage. ",
          "createdAt": "2023-05-16T13:49:05Z",
          "updatedAt": "2023-05-16T13:49:05Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I assume in some cases the issuer will out the `iss` in the `sub` claim, i.e. whatever data is looked up will be about the issuer (e.g. a wallet provider).",
          "createdAt": "2023-05-16T13:50:03Z",
          "updatedAt": "2023-05-16T13:50:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Apologies im not following you here, I'm inclined to make the iss the client ID as I think the most common case here is that its the client attesting a client instance and make the sub value a client instance ID that is unique per authorization server.",
          "createdAt": "2023-05-18T07:00:03Z",
          "updatedAt": "2023-05-18T07:00:03Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How have you come to the conclusion that this is the most common case?\r\n\r\nMy rationale is as follows: if the issuer wants to client id to be the iss value, it puts the iss value in the sub. If the issuer wants the client id to be something else, it uses a different value. I don\u2019t see a need for a client instance identification (at all or as default).",
          "createdAt": "2023-05-18T07:08:33Z",
          "updatedAt": "2023-05-18T07:08:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> How have you come to the conclusion that this is the most common case?\r\n\r\nI think the most common party signing the client attestation will be the client itself (e.g the backend component), as the AS will need to be able to relate the attestation keys back to the client in order to trust it any way. Do you have usecases where the attester is not the client, I believe this model is complex and we should seriously consider whether we support it. If the attester isn't the client then what do you set the iss value to, what does it mean and how should it influence validation of the attestation?",
          "createdAt": "2023-05-18T08:27:19Z",
          "updatedAt": "2023-05-18T08:28:37Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In general, I would assume the provider of the client to sign the attestation. However, Bundesdruckerei has implemented as solution where the attestation is issued by a trusted 3rd party. \n\nWith respect to the spec: I think it doesn't matter who signs the attestation as long as the AS trusts that party.",
          "createdAt": "2023-05-18T08:41:44Z",
          "updatedAt": "2023-05-18T08:41:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that in effect a trusted 3rd party could do the signing, however I dont believe their identity should be known to the AS (e.g as another protocol participant) instead their identity should still be considered part of the client.",
          "createdAt": "2023-05-18T09:41:38Z",
          "updatedAt": "2023-05-18T09:41:38Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why?",
          "createdAt": "2023-05-18T10:43:02Z",
          "updatedAt": "2023-05-18T10:43:02Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm unsure that it provides any value having another identified participant in the protocol seperate from the client. Can you elaborate on the value of why this trusted third party needs be independently identifiable from the client to the AS? How would its identity become know and managed by the AS?",
          "createdAt": "2023-05-18T10:47:20Z",
          "updatedAt": "2023-05-18T10:47:57Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Again. As long as the AS trusts the issuer of the assertion, it can accept it. I don\u2019t think we need to specify more than that + the sub is the client id. That\u2019s sufficient for interoperability.\n\nTo the contrary, I don\u2019t see a benefit in limiting the issuer to \u201ethe client\u201c.\nOn 18. May 2023 at 12:47 +0200, Tobias Looker ***@***.***>, wrote:\n> I'm unsure that it provides any value having another participant in the protocol seperate from the client. Can you elaborate on the value of why this trusted third party needs be independently identifiable from the client to the AS? How would its identity become know and managed by the AS?\n> \u2014\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n> You are receiving this because you commented.Message ID: ***@***.***>\n",
          "createdAt": "2023-05-18T10:51:28Z",
          "updatedAt": "2023-05-18T10:51:28Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree the most common use case is the iss being the client backend but we should not limit ourselves here.\nI propose iss is the attestation service and sub is a common name for the client aka wallet solution.\nIn some cases both might be the same but they don't need to be.\nBoth identifiers might be relevant for a lookup in a trust list ",
          "createdAt": "2023-05-18T11:08:02Z",
          "updatedAt": "2023-05-18T11:08:02Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Understood but I disagree, how does the attestation service become registered with the AS and managed beyond this point e.g in the event of key rotation, we would be adding another entirely new protocol participant for OAuth2 and I'm not sure we've identified any use cases where this would be valuable. Having the attestation service independently identified to the AS would only appear to be valuable when more than one client deployment wants to use the same attestation service, how common is that pattern? Because if we believe its not very common then the most common case where attestation service == client will likely pay a cost of increased complexity. Also what are the implications on the trust model for the AS, when things go wrong in which situations does it blame the client and others when it blames the attestation service?",
          "createdAt": "2023-05-18T19:46:46Z",
          "updatedAt": "2023-05-18T19:46:46Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How and why the AS trusts the issuer of an attestation is out of scope since it is not relevant on the protocol level. We also haven't defined this in the high assurance profile between verifier and issuer of a VC. I don't understand why we should take a different route here.\n\nJust as an example:\nIn the EU, the issuer will be maintained in a trusted list all issuers trust.\nIn a closed deployment, I would assume the trusted attestation issuers are directly maintained at the issuer.\n\nMany ways to get to Rome. We don't need to know all of them, just cater for them.",
          "createdAt": "2023-05-18T19:56:20Z",
          "updatedAt": "2023-05-18T19:56:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> How and why the AS trusts the issuer of an attestation is out of scope since it is not relevant on the protocol level\r\n\r\nOk I think perhaps our disconnect is here, how can the notion of \"the attestation service\" be entirely out of scope of this protocol? Its a party to the protocol who's identity will be crucial in the AS making a trust decision. Do we not need to define at least that the iss value of the client attestation IS an identifier for the attestation service and also how you resolve its keys and manage it in lifecycle? Also as I said before I think giving the AS two things to trust in reference to a client enormously increases the complexity in the trust decision it must make. ",
          "createdAt": "2023-05-18T20:09:49Z",
          "updatedAt": "2023-05-18T20:09:49Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Are all of those details defined in RFC 7523? I don't think so. This a base spec that is further detailed in profiles and deployments. The vc-sd-jwt spec s add also doesn't require a certain key resolution method for the same reason.\nIt doesn't matter for this spec whether the JWT is issued by a client backend or any other source. Important is that the AS needs to trust this issuer and that this JWT issuer determines the sub value, which is the client id. Anything beyond is subject to other specs in my opinion.\nFor the high assurance profile, I would assume keys are resolved either web based or with x509, like for the VCs. Other profiles can do it differently.",
          "createdAt": "2023-05-18T20:54:48Z",
          "updatedAt": "2023-05-18T20:54:48Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Right but RFC 7523 also doesn't formally define a new protocol participant either that the AS must trust independent of the client, instead its implied the keys required to verify the client attestation are associated to the client which is the model I'm proposing we recognise more formally. Are there any deployments of RFC 7523 that exist where the iss value in the assertion is not in some way an identifier for the client?",
          "createdAt": "2023-05-18T21:17:32Z",
          "updatedAt": "2023-05-18T21:17:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Something that was also pointed out to me is that RFC7523 may not require the iss to be the client_id but OpenID's profiling of it [did](https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication) and from what I understand there was no particular reason for RFC7523 to not constrain the iss value in this way, it just didn't. Nor are there really any deployments that have used RFC7523 in a way where the iss value is not the client id. ",
          "createdAt": "2023-05-19T00:43:33Z",
          "updatedAt": "2023-05-19T00:43:33Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "here I share something that emerged during the implementations and comparisons that took place with other analysts\r\n\r\niss and sub should not contain the same value, since the wallet provider (iss) is a separate entity with respect to the wallet instance (sub)\r\n\r\nFor this reason iss and sub must contain different identifiers, being related to distinct entities.\r\n\r\nThere are some cases where the client should not have a unique identifier, in this case the sub claim should not be included in the claim, because having iss and sub with identical values \u200b\u200bwould not make sense.\r\n\r\nFor this reason I propose to make the sub claim OPTIONAL rather than REQUIRED (MUST).",
          "createdAt": "2023-06-05T08:30:49Z",
          "updatedAt": "2023-06-05T08:30:49Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> iss and sub should not contain the same value, since the wallet provider (iss) is a separate entity with respect to the wallet instance (sub)\r\n\r\nWhy is that and what did emerge during implementations?",
          "createdAt": "2023-06-05T08:33:36Z",
          "updatedAt": "2023-06-05T08:33:36Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the discussion goes somewhere else now.\n\nOriginally the question was whether the attesting entity must be the client backend or can be a trusted third party.",
          "createdAt": "2023-06-05T11:07:53Z",
          "updatedAt": "2023-06-05T11:07:53Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Why is that and what did emerge during implementations?\r\n\r\nexactly was I wrote in the thread\r\n\r\n\r\n",
          "createdAt": "2023-06-05T12:25:14Z",
          "updatedAt": "2023-06-05T12:25:14Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess you mean \"iss and sub should not contain the same value, since the wallet provider (iss) is a separate entity with respect to the wallet instance (sub)\"\r\n\r\nWhile I agree on a conceptual level, I don't follow your conclusion that that an attestation needs to have different values for iss and sub. From the issuer's standpoint it is important to know it is talking to an instance of the respective wallet provider/product. It does not need to have an identity/identifier, nevertheless. You seem to agree as you propose to make the sub optional. Why do you think this is the better option than using sub == iss (i.e. self asserted, which to me makes sense). ",
          "createdAt": "2023-06-05T14:14:14Z",
          "updatedAt": "2023-06-05T14:14:34Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I got your point.\r\n\r\nI don't think that iss == sub because the wallet provider attests this to the wallet instance as a personal mobile device.\r\nThere might be some cases where the wallet instance is provided as a cloud service, thus this would be a specialized case compatible to your vision.\r\n\r\nIn the cases where the wallet instance is a personal device, the Wallet Instance Attestation is not self-asserted since Provider and Instance are actually different entities. The issuer attests information in possession and control of the instance, that's a distinct entity under the sole control of the user.\r\n\r\nIf the attestation is self asserted the private key should be in control of the wallet provider, while this is not the case where personal device are involved.\r\n\r\nthe wallet provider doesn't have any control on the private keys and general details of the wallet instance, since these are arbitraries\r\n\r\n",
          "createdAt": "2023-06-05T16:10:57Z",
          "updatedAt": "2023-06-05T16:12:37Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #12 and #31",
          "createdAt": "2023-09-06T06:57:52Z",
          "updatedAt": "2023-09-06T06:57:52Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Related discussion also occuring in #13 ",
          "createdAt": "2023-11-08T00:22:50Z",
          "updatedAt": "2023-11-08T00:22:50Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOJaEkaM5mDAKH",
      "title": "Change name of the JWT to Client Attestation ",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/6",
      "state": "CLOSED",
      "author": "tlodderstedt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm struggling with the terminology currently used in this draft. For me, it describes a mechanism to use JWTs to authenticate OAuth clients. \r\n\r\nHowever, the draft currently designates those JWTs as \"Key Attestation\" or \"attestation key\" or \"jwt-key-attestation\", which sounds like the focus is on attesting something about a certain key to the AS. But that's obviously not the case since, this draft is about client authentication and the key is \"just\" used to protect the JWT against replay. \r\n\r\nI think the name is confusing and suggest to change it to \"Client Attestation\". ",
      "createdAt": "2023-05-16T13:45:01Z",
      "updatedAt": "2023-09-06T06:57:13Z",
      "closedAt": "2023-09-06T06:57:13Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, what about \"Client Attestation based Client Authentication\" as a draft title?",
          "createdAt": "2023-05-18T06:55:37Z",
          "updatedAt": "2023-05-18T06:55:52Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I revisited the title of RFC 7523. What about \u201eSender-Constrained JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication\u201c?",
          "createdAt": "2023-05-18T07:24:52Z",
          "updatedAt": "2023-05-18T07:24:52Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "@tlodderstedt thats a proposal for the title of the RFC I guess? I'm ok with that..\r\nI propose \"Client Attestation JWT\" for the actual thing, that we call wallet attestation in our scenario",
          "createdAt": "2023-05-19T16:27:53Z",
          "updatedAt": "2023-05-19T16:27:53Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Renaming the Client Attestation covered by #11 .\r\nRenaming topic in this issue is about the title?",
          "createdAt": "2023-05-22T16:22:45Z",
          "updatedAt": "2023-05-22T16:22:45Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "After thinking about this more I propose \"Attestation Based Client Authentication for OAuth 2\"",
          "createdAt": "2023-05-30T21:47:55Z",
          "updatedAt": "2023-05-30T21:47:55Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What is the meaning of this title? What does \"Attestation based\" mean?",
          "createdAt": "2023-05-31T01:21:47Z",
          "updatedAt": "2023-05-31T01:21:47Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "that the Client backend/Attestation Service attests the Client Instance",
          "createdAt": "2023-06-05T13:24:21Z",
          "updatedAt": "2023-06-05T13:24:21Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How is that different from \"JWT-based client authentication\"? The JWT also contains claims about the client.",
          "createdAt": "2023-06-05T14:08:44Z",
          "updatedAt": "2023-06-05T14:08:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Resolved in draft-00",
          "createdAt": "2023-09-06T06:57:13Z",
          "updatedAt": "2023-09-06T06:57:13Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOJaEkaM5mMD6N",
      "title": "Introduction text",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/7",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft says:\r\n\r\n> [[RFC7521](https://vcstuff.github.io/draft-looker-oauth-attested-key-based-client-authentication/draft-looker-oauth-attested-key-based-client-authentication.html#RFC7521)] defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification extends this mechanism to provide a way for a client instance to authenticate it self with the authorization server through an attested key based authentication scheme.\r\n\r\nI don't like the description of a \"an attested key based authentication scheme\", as key attestations are not always possible and it is more about attesting the wallet and the key being a mechanism.\r\n\r\n I would rather describe the current approach as a\r\n- remote client (instance) attestation scheme\r\n- remote wallet (instance) attestation scheme",
      "createdAt": "2023-05-17T18:27:28Z",
      "updatedAt": "2023-09-06T06:56:38Z",
      "closedAt": "2023-09-06T06:56:38Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed I dont like it particularly either, what about just \r\n\r\n\r\n[[RFC7521](https://vcstuff.github.io/draft-looker-oauth-attested-key-based-client-authentication/draft-looker-oauth-attested-key-based-client-authentication.html#RFC7521)] defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification extends this mechanism to provide a way for a client instance to authenticate itself with the authorization server through an attestation based authentication scheme.",
          "createdAt": "2023-05-18T06:54:25Z",
          "updatedAt": "2023-05-18T06:54:39Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine to close this, see #11 ",
          "createdAt": "2023-05-22T16:21:37Z",
          "updatedAt": "2023-05-22T16:21:37Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Rephrased in #39 ",
          "createdAt": "2023-09-06T06:56:38Z",
          "updatedAt": "2023-09-06T06:56:38Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOJaEkaM5mMRNY",
      "title": "Improvements to the diagram",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/8",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current diagram describes 6 steps:\r\n(1) Generate Attestation Key \r\n(2) Request  Client Key Attestation for generated key\r\n(3) Generate Client Key Attestation\r\n(4) Repond with Generated Client Key Attestation\r\n(5) Generate Key Attestation PoP\r\n(6) Interaction using Client Key Attestation + PoP for authentication\r\n\r\nI would propose for:\r\n(1) Generate key and client app attestations\r\n(2) Request Client Attestation JWT\r\n(3) Validate attestations and generate Client Attestation JWT\r\n(4) Issue Client Attestation JWT\r\n(5) Generate DPoP for Client Attestation JWT\r\n(6) Authenticate using Client Attestation JWT + DPoP\r\n",
      "createdAt": "2023-05-17T18:59:35Z",
      "updatedAt": "2023-09-06T06:55:34Z",
      "closedAt": "2023-09-06T06:55:34Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "A couple of thoughts w.r.t this\r\n\r\nIm not sure how much we want to talk about app attestations in this draft as it assumes the client instance is say a native app.\r\n\r\nI think this issue has some good terminology suggestions WDYT about the following\r\n\r\nClient Attestation JWT - Generated by the client backend\r\nClient Instance PoP JWT - Generated by the client instance during client authentication (I dont think DPoP is right to use here w.r.t how it conflicts with DPoP)\r\nClient Instance Key - What the client attestation jwt is bound to\r\n\r\n",
          "createdAt": "2023-05-18T06:52:53Z",
          "updatedAt": "2023-05-18T06:52:53Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, is this covered by #11 ?\r\nOk to close for me",
          "createdAt": "2023-05-22T16:20:31Z",
          "updatedAt": "2023-05-22T16:20:31Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOJaEkaM5mPkLA",
      "title": "Replay attack prevention through AS contributed nonce",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/9",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "Currently the specification does not define a mechanism for an AS contributed nonce to feature in the client attestation PoP meaning replay attack detection by authorisation servers requires tracking the JTI within the time window set by the PoP's iat claim. We should elaborate on an AS contributed nonce for the specification.",
      "createdAt": "2023-05-18T10:00:50Z",
      "updatedAt": "2023-10-23T20:15:32Z",
      "closedAt": "2023-10-23T20:15:32Z",
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "What about using the authorization code or pre auth code as suggested in our demo?",
          "createdAt": "2023-05-18T11:03:02Z",
          "updatedAt": "2023-05-18T11:03:02Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is an option, however the nonce for client authentication becomes dependent on the grant type which creates a bit of an awkward coupling when an application wants to say use this mode of client authentication for grant type other than pre auth code or authorisation code.",
          "createdAt": "2023-05-18T20:35:12Z",
          "updatedAt": "2023-05-18T20:35:35Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "How many implemantations out there actually use different grant types than auth-code?\r\nGiven that this serves our purposes and imo everybody is using auth-code, I think that we should RECOMMEND that scenario but I#m ok with showing up alternatives as you suggested.\r\n@tlodderstedt What's your opinion on this?",
          "createdAt": "2023-05-22T16:13:22Z",
          "updatedAt": "2023-05-22T16:13:22Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the flow can be used with and without nonce. \r\n\r\nIf it is used without nonce, jti and short expiration must be used to limit the risk. \r\nIf a nonce is used, I think using the codes is a pragmatic option. Alternatively, the AS could provide a dedicated nonce with the credential offer or authorization response. It could also provide the nonce with a token error response. ",
          "createdAt": "2023-05-23T07:35:49Z",
          "updatedAt": "2023-05-23T07:35:49Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "discussion on 23.05 is leaning towards DpoP-style error providing nonce",
          "createdAt": "2023-05-23T19:28:50Z",
          "updatedAt": "2023-05-23T19:28:50Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "can we please bring this issue forward, it is very important?\r\n\r\n> discussion on 23.05 is leaning towards DpoP-style error providing nonce\r\n\r\nI see some advantages in that approach as it would allow the AS to request nonce use for all endpoints (including PAR).",
          "createdAt": "2023-07-30T15:43:23Z",
          "updatedAt": "2023-07-30T15:43:23Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "on that topic, I would suggest such an AS provided nonce should be good up until the AS says otherwise. That would allow a client to use the same nonce for PAR and token endpoint.",
          "createdAt": "2023-07-30T15:44:37Z",
          "updatedAt": "2023-07-30T15:44:37Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Update provided in #39",
          "createdAt": "2023-09-06T06:56:35Z",
          "updatedAt": "2023-09-06T06:56:35Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "PR #49 ",
          "createdAt": "2023-10-08T15:17:05Z",
          "updatedAt": "2023-10-08T15:17:05Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "PR #49 ",
          "createdAt": "2023-10-08T15:18:03Z",
          "updatedAt": "2023-10-08T15:18:03Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOJaEkaM5mhKRe",
      "title": "Explain and discuss the options of ad-hoc and long-lasting client attestations",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/10",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "Options on requesting/generating the client/wallet attestation ad-hoc or in advance have been discussed and there are pros and cons for both sides. Is a short explanation of this suited for the RFC?",
      "createdAt": "2023-05-22T15:52:23Z",
      "updatedAt": "2023-09-06T06:56:00Z",
      "closedAt": "2023-09-06T06:56:00Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Suggest closing as we shouldn't comment on attestation token lifetimes anymore then OAuth2 comments on expected AT lifetimes, its at the discretion of the implementation which is often highly deployment specific.",
          "createdAt": "2023-09-06T06:56:00Z",
          "updatedAt": "2023-09-06T06:56:00Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOJaEkaM5nOgXk",
      "title": "Why not just use the same client attestation JWT? That would not require any client instance identification and is also not a privacy issue.",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/12",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tplooker"
      ],
      "labels": [],
      "body": "              Why not just use the same client attestation JWT? That would not require any client instance identification and is also not a privacy issue. \r\n\r\nurn:ietf:params:oauth:client-assertion-type:jwt-key-attestation -> urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation\r\n\r\n_Originally posted by @tlodderstedt in https://github.com/vcstuff/draft-looker-oauth-attested-key-based-client-authentication/pull/11#discussion_r1201683953_\r\n            ",
      "createdAt": "2023-05-30T09:15:06Z",
      "updatedAt": "2023-09-08T21:43:06Z",
      "closedAt": "2023-09-08T21:43:06Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #31. The problem with this model is that the refresh token if bound to the client attestation JWT then limits the RT lifetime.",
          "createdAt": "2023-09-06T06:53:51Z",
          "updatedAt": "2023-09-06T06:53:51Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOJaEkaM5nQFkc",
      "title": "Client Key Attestation JWT Example",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/13",
      "state": "OPEN",
      "author": "fmarino-ipzs",
      "authorAssociation": "NONE",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "In the example in section 3.1.1. the issuer and the sub parameters should not be the same since the Wallet provider and the wallet instance are distinct entities. The private key in sole control of the wallet instance is referenced in the attestation while the subject refers to the Wallet Provider. \r\n\r\nMoreover, is the given example meant to be normative? I'm asking since in the example we find the JWS header parameter kid without any explanatory text about the key resolution mechanism allowed in the specs. (x5c, trust_chain, jwk)\r\n\r\n",
      "createdAt": "2023-05-30T13:22:00Z",
      "updatedAt": "2023-11-12T14:11:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "re 1: the wallet instance is an instance of the software published by the wallet provider. Setting the sub to the issuer value is a plausible option as the wallet provider issued an attestation to one of its instances. It most notably prevents tracking of wallet instances (aka super cookies).\r\nre 2: this draft (as all OAuth WG drafts) is a base module to be used in the context of a certain profile. Such a profile would define how the keys are resolved. There will be definitely be a definition on the level of the OID4VC High Assurance Interoperability Profile.  ",
          "createdAt": "2023-07-05T12:47:01Z",
          "updatedAt": "2023-07-05T12:47:01Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "regarding the value of the sub claim in the WAI: since the wallet instance attestation is binded to a public key, we are not forced to use a unique and immutable subject identifier but instead a unique identifier with the same lifetime of the related key. That's why I suggest to place the jwk thumbprint value as sub or any other collision resistant value\r\n\r\nanyway I think that's an implementation choice if not of interest in this specs, I'd ask to remove any constraint to have iss equal to sub, since doesn't make any sense following the awareness that the wallet provider and the wallet instance are distinct entities, even if part of the same wallet solution, then they should not use the same entity identifier\r\n\r\n",
          "createdAt": "2023-07-05T23:36:44Z",
          "updatedAt": "2023-07-05T23:36:44Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see any constraints in the spec regarding the `sub` value. Please point our if I missed one. ",
          "createdAt": "2023-07-06T06:56:05Z",
          "updatedAt": "2023-07-06T06:56:05Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I had a check, now I can confirm.\r\nHappy to have put a stone with you on that\r\n",
          "createdAt": "2023-07-06T09:22:14Z",
          "updatedAt": "2023-07-06T09:22:14Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Following the generalisation proposed in #32 if merged then we will need to constrain the sub value to being the client_id to ensure client identification and authentication can take place. Multiple client instances sharing a single client_id is not a new pattern and is common place for public clients.",
          "createdAt": "2023-09-06T06:51:43Z",
          "updatedAt": "2023-09-06T06:51:43Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "As of now, I think there is consensus to have `sub` as client_id.\r\nPending close if no objections",
          "createdAt": "2023-10-08T15:19:18Z",
          "updatedAt": "2023-10-08T15:19:18Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agreed that `sub` must have the same value of `client_id` but I didn't agreed that the specs should say which must be their value.\r\nI agree @TakahikoKawasaki 's comment [here](https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/issues/32#issuecomment-1637028939) and I think that different implementations and models may distinguish the wallet instance from the wallet provider as different entities",
          "createdAt": "2023-10-09T09:14:20Z",
          "updatedAt": "2023-10-09T09:14:20Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> I agreed that sub must have the same value of client_id but I didn't agreed that the specs should say which must be their value.\r\nI agree @TakahikoKawasaki 's comment https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/issues/32#issuecomment-1637028939 and I think that different implementations and models may distinguish the wallet instance from the wallet provider as different entities\r\n\r\n@peppelinux apologies we are struggling to understand what you mean here, can you possibly clarify?",
          "createdAt": "2023-11-06T08:06:08Z",
          "updatedAt": "2023-11-06T08:06:08Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ciao @tplooker \r\n\r\n`iss` is the entity that attests an instance, while `sub` is the instance.\r\nin my current implementation the first is the wallet provider, the latter is the End-User personal device.\r\n\r\nWe have found a good compromise with @paulbastian to not force in the specs a specific value, in a way to not force that `iss` value must be equal to `sub`. Wee agreed and everything seems fine to date.",
          "createdAt": "2023-11-06T17:31:46Z",
          "updatedAt": "2023-11-06T17:31:46Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @peppelinux, if you dont mind, could you copy in an example of your client attestation JWT just so we can be 100% aligned, what I'm trying to understand is whether the sub value you are using is unique per user? Because our proposal above is simply for the sub value to be the client ID which for public clients would mean the same sub value across multiple instances of the same client.",
          "createdAt": "2023-11-06T21:52:28Z",
          "updatedAt": "2023-11-06T21:52:28Z"
        },
        {
          "author": "TakahikoKawasaki",
          "authorAssociation": "NONE",
          "body": "@tplooker \r\nThe example of \"wallet instance attestation\" (which corresponds to the \"client attestation JWT\") in the [page 9](https://docs.google.com/presentation/d/1xcUyrPZbOyAS5-aSk189L0n7CMIZyuGI7jqLtmZfHPE/#slide=id.g6340a851bc_0_56) of \"[Discover the Italian Wallet](https://docs.google.com/presentation/d/1xcUyrPZbOyAS5-aSk189L0n7CMIZyuGI7jqLtmZfHPE/)\" indicates that the value of the `sub` is not a client application identifier but an identifer unique per user (per client instance key).\r\n\r\nTo be exact, the Italian technical document, \"[Wallet Instance Attestation](https://italia.github.io/eudi-wallet-it-docs/versione-corrente/en/wallet-instance-attestation.html)\", defines the `sub` as follows.\r\n\r\n> Thumbprint value of the JWK of the Wallet Instance for which the attestation is being issued.\r\n\r\nAs an implementer of an authorization server that plans to support the \"OAuth 2.0 Attestation-Based Client Authentication\" specification, I'm looking for a way to support both the cases at the same time where (1) `sub` is a client application identifier or (2) `sub` is a unique identifier per client instance key.",
          "createdAt": "2023-11-06T23:33:30Z",
          "updatedAt": "2023-11-06T23:33:30Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @TakahikoKawasaki can you elaborate on the usecase/rationale for why the client attestation needs to include a client instance (or user unique) identifier in the attestation? For example the reason the attestation must include a client_id somewhere is because the authorisation server needs to know which client is making the request, but generally as is the case with public clients, the authorisation server doesn't care which specific instance is making the request. ",
          "createdAt": "2023-11-06T23:37:52Z",
          "updatedAt": "2023-11-06T23:37:52Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #57 ",
          "createdAt": "2023-11-06T23:39:41Z",
          "updatedAt": "2023-11-06T23:39:41Z"
        },
        {
          "author": "TakahikoKawasaki",
          "authorAssociation": "NONE",
          "body": "@tplooker \r\nTo be honest, I don't care about the rationale behind the value of the `sub` claim in the \"Client Attestation JWT\". Because authorization server implementations can know the client application identifier from the `iss` claim in \"Client Attestation **PoP** JWT\", the value of the `sub` claim in the \"Client Attestation JWT\" is not necessary to identify the client application.\r\n\r\nIf the specification says \"the `sub` claim in the Client Attestation JWT must be identical to the client application identifier\", authorization server implementations must reject requests from Italian wallets. On the contrary, if the specification says \"the `sub` claim in the Client Attestation JWT must be the JWK thumbprint of the client instance key\", authorization server implementations must reject requests from other wallets (e.g. IDunion wallets?) that set the client application identifier to the `sub` claim.\r\n\r\nGeneral-purpose authorization server implementations want to accept both requests at runtime, or at least want to be (statically) configurable to accept either of the two patterns. A simple resolution would be to define the value of the `sub` claim of the Client Attestation JWT as follows.\r\n\r\n- The client identifier or the JWK thumbprint of the client instance key\r\n\r\n",
          "createdAt": "2023-11-07T00:05:49Z",
          "updatedAt": "2023-11-07T00:05:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> To be honest, I don't care about the rationale behind the value of the sub claim in the \"Client Attestation JWT\". Because authorization server implementations can know the client application identifier from the iss claim in \"Client Attestation PoP JWT\", the value of the sub claim in the \"Client Attestation JWT\" is not necessary to identify the client application.\r\n\r\nI understand the AS can use the PoP to identify who the client is, but without a client_id in the client attestation its not really a client attestation instead its just a key attestation. Perhaps @peppelinux can you elaborate on why the sub value needs to be a JWK thumbprint in your implementation what does this enable?",
          "createdAt": "2023-11-07T04:13:57Z",
          "updatedAt": "2023-11-07T04:13:57Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tplooker \r\n\r\nThe `cnf.jwk` represents the identifier of the wallet instance. A wallet instance may have more than a private key and more than a single wallet instance attestation. Even using `iss` == `sub` the wallet instance attestation can be implicitly identified with the `cnf.jwk`.\r\n\r\nThe value of the `sub` claim is something to uniquely identify the subject, we should not mandate a specific value type but the only requirement to have unique value per wallet instances, while `iss` == `sub` == `client_id` doesn't make sense to me.\r\n\r\nI agree with Taka and at the same time I foudn a compromise with @paulbastian and at the end if `iss` == `sub` this will be ignored by the implementations because it doesn't bring any value, sense or benefit. It would be then better to remove `client_id` and `sub`. Anyway if this compromise to ignore the sub value helps the interop, I can buy but in Italy we're prone to distinguish the issuer from the subject because they are distinct entities, the first is the wallet instance attestation issuer, the latter is the wallet instance.",
          "createdAt": "2023-11-07T11:44:18Z",
          "updatedAt": "2023-11-07T23:49:29Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the explanation @peppelinux.\r\n\r\n> The value of the sub claim is something to uniquely identify the subject, we should not mandate a specific value type but the only requirement to have unique value per wallet instances, while iss == sub == client_id doesn't make sense to me.\r\n\r\nI think perhaps here is where there is a disconnect. At present in the specification, the attestation is called a \"client attestation\" not \"user attestation\" which is because the issuer of the attestation is a client and the subject is an instance that particular client.\r\n\r\nIf we make the change proposed in #32 then the issuer of the client attestation is no longer necessarily the client (or client backend) instead it could be any party that the authorization server trusts to make attestations about clients. However in that model the subject of the attestation is still always a client instance not a user.\r\n\r\nSo with the adoption of #32 the iss will no longer be the client ID meaning instead the client_id must feature somewhere else in the client attestation, otherwise the authorization server has no way to validate for which client an attestation it is presented has been produced for. The most practical change I see here would be for us to require the `sub` value to be the client_id of the client being attested.\r\n\r\nIn short with the change proposed above the iss value could be any string but the sub would then still have to be the client_id, would that work for your implementation? For a concrete example see here https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/issues/32#issuecomment-1637028939 as proposed by @TakahikoKawasaki ",
          "createdAt": "2023-11-08T00:15:08Z",
          "updatedAt": "2023-11-09T20:29:33Z"
        },
        {
          "author": "TakahikoKawasaki",
          "authorAssociation": "NONE",
          "body": "The following table summarizes the current spec, the Italian ecosystem, and possible compromises.\r\n\r\n| No. | Client Attestation JWT `iss` | Client Attestation JWT `sub` | Client Attestation JWT, new claim | Client Attestation PoP JWT `iss` | Memo |\r\n|:-:|:--|:--|:--|:--|:--|\r\n| 1 | Attester | Client ID | N/A | Client ID | The current spec. |\r\n| 2 | Client ID | Client ID | N/A | Client ID | The example in the current spec (excerpted in #32). My understanding is that the example is misleading because the current spec conceptually treats the attester and the client as different things. |\r\n| 3 | Attester | Thumbprint of Client Instance Key | N/A | Client ID | The Italian ecosystem |\r\n| 4 | Attester | Any | N/A | Client ID | Compromise A |\r\n| 5 | Attester | Client ID or Thumbprint of Client Instance Key | N/A | Client ID | Compromise B |\r\n| 6 | Attester | Client ID | Thumbprint of Client Instance Key | Client ID | Compromise C |\r\n| 7 | Attester | Thumbprint of Client Instance Key | Client ID | Client ID | Compromise D |\r\n| 8 | Attester | Any | Client ID | Client ID | Compromise E |\r\n| 9 | Attester | Any | Thumbprint of Client Instance Key | Client ID | Compromise F |\r\n| 10 | Attester | Client ID or Thumbprint of Client Instance Key | Client ID | Client ID | Compromise G |\r\n| 11 | Attester | Client ID or Thumbprint of Client Instance Key | Thumbprint of Client Instance Key | Client ID | Compromise H |\r\n",
          "createdAt": "2023-11-08T01:09:27Z",
          "updatedAt": "2023-11-08T01:09:27Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @TakahikoKawasaki for your write up. @peppelinux if the main intent of your use-case is to support identifying the client instance, then I believe as you highlight above that can be accomplished via the `cnf` claim. Therefore we can leave the `sub` claim as the client_id value. Will that work for your deployment?\r\n\r\n",
          "createdAt": "2023-11-09T20:33:52Z",
          "updatedAt": "2023-11-09T20:33:52Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tplooker \r\n\r\n> If we make the change proposed in #32 then the issuer of the client attestation is no longer necessarily the client (or client backend) instead it could be any party that the authorization server trusts to make attestations about clients. However in that model the subject of the attestation is still always a client instance not a user.\r\n\r\nI didn't mention any user, a subject could be any kind of entity, like a robot, a machine, a client, etc.\r\n\r\n> Therefore we can leave the sub claim as the client_id value. Will that work for your deployment?\r\n\r\nIn my deployment the `sub` value, then the client_id, is the thumbprint value of the cnf.jwk and this is therefore different from the `iss` value.\r\n\r\nThanks to @TakahikoKawasaki for his memorable contributions.\r\n",
          "createdAt": "2023-11-12T14:11:44Z",
          "updatedAt": "2023-11-12T14:11:44Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOJaEkaM5nQJz8",
      "title": "The Entity Attestation Token (EAT)",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/14",
      "state": "CLOSED",
      "author": "peppelinux",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Is there any considerations about adopting *The Entity Attestation Token (EAT)* [draft-ietf-rats-eat-12](https://datatracker.ietf.org/doc/draft-ietf-rats-eat/12/) for the Attestation JWT?",
      "createdAt": "2023-05-30T13:31:55Z",
      "updatedAt": "2023-09-06T06:48:55Z",
      "closedAt": "2023-09-06T06:48:55Z",
      "comments": [
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it is sufficient to add that JWT Claims defined in EAT draft can be put in the attestation JWT?",
          "createdAt": "2023-07-06T19:05:10Z",
          "updatedAt": "2023-07-06T19:05:10Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "EAT is a more general purpose token format, however as highlight by @Sakurann implementations are free to make use of claims registered by EAT for their purposes.",
          "createdAt": "2023-09-06T06:48:47Z",
          "updatedAt": "2023-09-06T06:48:47Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOJaEkaM5nQSkv",
      "title": "Security levels in the attestation",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/15",
      "state": "OPEN",
      "author": "fmarino-ipzs",
      "authorAssociation": "NONE",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "Since the EUDI Wallet instance may have different level of security depending on its own hardware and/or software capabilities, here the proposal: define a claim name for exposing different level of security of the wallet instance.\r\n\r\nExample:\"gold\", \"silver\" and \"bronze\" or \"high\", \"medium\", \"low\" depending on the framework used. \r\n\r\nThis proposal enables the security evaluation to the credential issuing side (or any other Relying Party) without knowing any specific hardware or software features (e.g. OS, etc.). ",
      "createdAt": "2023-05-30T13:52:15Z",
      "updatedAt": "2024-08-28T13:42:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "The RFC may be used to issue wallet attestations in the eIDAS use case, giving additional information on the key type of the `cnf` and the user authenticaiton mechanisms, see more info [here](https://www.linkedin.com/feed/update/urn:li:activity:7056179875635724289/). A Wallet alone does not achieve a LoA but only supports the issuer in achieving an LoA for the lifecycle of an issues credential. However, a claim `supported_LoA` could be useable",
          "createdAt": "2023-05-30T15:18:52Z",
          "updatedAt": "2023-05-30T15:18:52Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here the proposal raised in the italian implementation\r\n\r\n`asc_values_supported` and `asc`\r\n\r\nwhere ASC is the acronym of Attested Security Context\r\n\r\nthis aims do disambiguate the meaning of LoA, that is referred to person identities, to the scope of this attestation, that's entirely related to the security context of a personal device \r\n\r\n#### asc_values_supported\r\n\r\nis a capability of the wallet provider, that defines which kind of checks/levels is able to attests to its wallet instances\r\n\r\n#### asc \r\n\r\nis the claim issued in the Wallet Instance Attestation",
          "createdAt": "2023-06-17T12:46:20Z",
          "updatedAt": "2023-06-17T12:47:50Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the parameter name was renamed to `attested_security_context` (ASC) and we read it here:\r\nhttps://github.com/vcstuff/draft-looker-oauth-attestation-based-client-auth/blob/main/draft-looker-oauth-attestation-based-client-auth.md#wallet-instance-attestation\r\n\r\nIn that form **it is just a non-normative example, so some explanatory/normative text is needed**.\r\n\r\nASC aims to introduce a classification for the common capabilities of the device/mobile-app and a simple evaluation by the issuers.\r\n\r\nGenerally, it\r\n\r\n- avoids that the issuers should take any responsability by attesting `key_type` and `user_authentication`, since the sole responsability of the wallet security compliance is up to the wallet provider\r\n\r\n- avoids the implicit disclosure of system internals or mobile os name/brand. These could be derived by knowing the `key_type`, since there are some technologies that are only available on some specific platforms/os/versions. Then it improves the privacy, because the issuer cannot know which mobile os the user prefers or simply uses.\r\n\r\n-  requires a common framework where different device capabilities and user auth method must be mapped, classified and grouped in the ASC levels. A matrix with the key_types and user_auth values, grouped by each ASC level, is then required (but probably outside of the scope of this specs). \r\n\r\n- avoids that future features that today still don't exist, for example `key_type: \"super-Strong-box-3.0\"`, don't introduce anything more to the issuers that just need to know which are the ASC level and the one carried in the WIA, without any details (mandated to a common framework)\r\n\r\nexample of how the ACS levels could be defined can be found in literature as they was for ACR and AMR.",
          "createdAt": "2023-07-29T21:44:38Z",
          "updatedAt": "2023-07-30T18:13:20Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "While I agree that ASC is a good idea, the argument for privacy is negligible as every browser user sends the OS information anyway, additional information of the key type is very small.\n\nThe argument for simplicity, that the issuer does not need to do a mapping, is the strong argument here, but we are missing the mapping right now.",
          "createdAt": "2023-07-29T22:23:36Z",
          "updatedAt": "2023-07-29T22:24:54Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "good point,\r\n\r\nfor my personal experience I think that the level of privacy of a web browser can be configured by the User that is able to install additional privacy extensions as well.\r\n\r\nthe mapping is in the todo list, would this specs hosts a baseline of this mapping or do you think that it would be better to have it out of this spec? ",
          "createdAt": "2023-07-30T18:10:38Z",
          "updatedAt": "2023-07-30T18:10:38Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #29 ",
          "createdAt": "2023-09-06T06:47:46Z",
          "updatedAt": "2023-09-06T06:47:46Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Solved in #48 ",
          "createdAt": "2023-10-08T15:21:44Z",
          "updatedAt": "2023-10-08T15:21:44Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "I think we can close this?",
          "createdAt": "2024-08-28T13:42:56Z",
          "updatedAt": "2024-08-28T13:42:56Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOJaEkaM5nyl4B",
      "title": "Reanme Grant Type to JWT-PoP?",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/17",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "Issue raised by Kristina:\r\nI also perceive this draft as a PoP version of urn:ietf:params:oauth:grant-type:jwt-bearer, would it make sense to make that more intuitive and explicit - like urn:ietf:params:oauth:grant-type:jwt-pop? - this can be another issue\r\n\r\n_Originally posted by @Sakurann in https://github.com/vcstuff/draft-looker-oauth-attested-key-based-client-authentication/pull/11#pullrequestreview-1451679914_\r\n            ",
      "createdAt": "2023-06-05T08:59:41Z",
      "updatedAt": "2023-11-06T08:00:33Z",
      "closedAt": "2023-11-06T08:00:33Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "@Sakurann can you please review the latest terminology in the draft and let us know if you have any issue with it?",
          "createdAt": "2023-09-06T06:46:52Z",
          "updatedAt": "2023-09-06T06:46:52Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that this draft is defining an OAuth client authentication method and *not* a grant type (yes RFC7521 has both but this draft only deals with client auth). So there may well be room for improvement in terminology but it shouldn't be about grant type.",
          "createdAt": "2023-09-25T18:40:04Z",
          "updatedAt": "2023-09-25T18:40:04Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Pending close if there are no objections",
          "createdAt": "2023-10-08T15:22:24Z",
          "updatedAt": "2023-10-08T15:22:24Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOJaEkaM5oo1Wx",
      "title": "client_assertion_type",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/18",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "              I perceive this draft as a PoP version of `urn:ietf:params:oauth:grant-type:jwt-bearer`, would it make sense to make that more intuitive and explicit - like `urn:ietf:params:oauth:grant-type:jwt-pop`?\r\n\r\n_Originally posted by @Sakurann in https://github.com/vcstuff/draft-looker-oauth-attested-key-based-client-authentication/pull/11#discussion_r1210728395_\r\n            ",
      "createdAt": "2023-06-13T19:34:04Z",
      "updatedAt": "2023-09-06T06:45:42Z",
      "closedAt": "2023-09-06T06:45:42Z",
      "comments": [
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "is this duplicate of #17 ?",
          "createdAt": "2023-07-06T19:02:12Z",
          "updatedAt": "2023-07-06T19:02:12Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOJaEkaM5pQ52B",
      "title": "Change Client Attestation JWT to SD-JWT",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/20",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If we use SD-JWT instead of JWT for Client Attestation, things might be easier and its a good test case for using SD-JWT without Disclosures",
      "createdAt": "2023-06-20T19:38:28Z",
      "updatedAt": "2023-07-07T15:36:19Z",
      "closedAt": "2023-07-07T15:36:19Z",
      "comments": [
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "SD-JWT VC as defined in [draft-terbu-sd-jwt-vc](https://github.com/vcstuff/draft-terbu-sd-jwt-vc) without SD, right? (we should differentiate with core sd-jwt)",
          "createdAt": "2023-07-06T19:01:00Z",
          "updatedAt": "2023-07-06T19:01:08Z"
        },
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "what is the use-case for the wallet attestation with selective disclosure?",
          "createdAt": "2023-07-06T19:09:01Z",
          "updatedAt": "2023-07-06T19:09:01Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "we probably don't need selective disclosure. SD-JWT-VC gives some feature like easy holder-binding with tilde and key discovery etc that we would need replicate with plain JWTs",
          "createdAt": "2023-07-06T19:18:51Z",
          "updatedAt": "2023-07-06T19:18:51Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "whether to rely on SD-JWT or SD-JWT-VC is yet another option to discuss",
          "createdAt": "2023-07-06T19:19:37Z",
          "updatedAt": "2023-07-06T19:19:37Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "in the discussion on July 6th, it was agreed to stay with plain JWT for now",
          "createdAt": "2023-07-07T15:36:19Z",
          "updatedAt": "2023-07-07T15:36:19Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOJaEkaM5p9Z-V",
      "title": "Terms and Definitions are run together",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/24",
      "state": "CLOSED",
      "author": "selfissued",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the Terminology section, the term names and term definitions are run together with no punctuation between them.  For example:\r\n> Client Attestation JWT A JSON Web Token (JWT) generated by the client backend which is bound to a key managed by a client instance which can then be used by the instance for client authentication.\r\n\r\nI suggest emulating the formatting in https://openid.bitbucket.io/connect/openid-4-verifiable-credential-issuance-1_0.html#name-terminology.",
      "createdAt": "2023-06-27T20:29:52Z",
      "updatedAt": "2023-07-05T20:43:17Z",
      "closedAt": "2023-07-05T20:43:17Z",
      "comments": []
    },
    {
      "number": 27,
      "id": "I_kwDOJaEkaM5q6iJF",
      "title": "Send Client Attestation with Authorization Request instead of Token Request",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/27",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tplooker"
      ],
      "labels": [],
      "body": "There is an idea to send the Client attestation already in Authorization Request or PAR instead of with the Token Request.\r\nI see the following advantages:\r\n - the client attestation could act as some kind of mobile capability descriptor, thus allowing the Authorization Server(Issuer) to check these before the user performs user authentication, otherwise this could result in poor UX as the user authenticates and the AS realizes only afterwards in Token Request that the level of client attestation is not enough (e.g. wallet can only handle key type xyz or LoA low)\r\n\r\nI see the following disadvantage:\r\n- some flows do not require Authorization Request\r\n- the user usually does not give consent before sending Authorization Request",
      "createdAt": "2023-07-07T15:20:37Z",
      "updatedAt": "2023-09-08T21:46:00Z",
      "closedAt": "2023-09-08T21:46:00Z",
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The client attestation can for sure be used to authenticate with PAR. The HAIP already requires that. ",
          "createdAt": "2023-07-07T15:23:06Z",
          "updatedAt": "2023-07-07T15:23:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "The draft just needs to be clarified that this is a general purpose client authentication method that can be used with any interaction with an AS that is requiring or making use of client authentication.",
          "createdAt": "2023-09-06T06:45:35Z",
          "updatedAt": "2023-09-06T06:45:35Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOJaEkaM5rDmRt",
      "title": "Diagram exceeds 72 charaters",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/28",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "IETF drafts are expected to not exceed 72 characters per line. The diagram in the Introduction currently takes 91",
      "createdAt": "2023-07-10T06:55:56Z",
      "updatedAt": "2023-10-23T20:17:37Z",
      "closedAt": "2023-10-23T20:17:37Z",
      "comments": []
    },
    {
      "number": 29,
      "id": "I_kwDOJaEkaM5rEv0s",
      "title": "[IANA Registry] attested_security_context as JWT parameter",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/29",
      "state": "OPEN",
      "author": "peppelinux",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "The brand new parameter called `attested_security_context`, as defined [here](https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-auth/pull/26/files#diff-55e05bec82593426ed363ab5c93ddf1e82b0f64cdf164f98e85fe1236b8783edR325), requires a IANA section for the registration of this parameter name\r\n\r\n",
      "createdAt": "2023-07-10T09:57:59Z",
      "updatedAt": "2023-09-06T06:43:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Registration is no longer required as this section was shifted to a non-normative example. We are still discussing as editors whether registration of some form of claim for this purpose is valuable for the draft.",
          "createdAt": "2023-09-06T06:43:00Z",
          "updatedAt": "2023-09-06T06:43:00Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOJaEkaM5rrKKF",
      "title": "typ values for Client Attestation JWT and Client Attestation PoP JWT",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/30",
      "state": "OPEN",
      "author": "TakahikoKawasaki",
      "authorAssociation": "NONE",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "The current draft does not require the Client Attestation JWT and Client Attestation PoP JWT to have the `typ` JWS header parameter. Do you have any plans to define specific `typ` values for these JWTs?",
      "createdAt": "2023-07-16T07:29:52Z",
      "updatedAt": "2023-11-03T19:48:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. Need to properly define header section",
          "createdAt": "2023-09-06T06:39:22Z",
          "updatedAt": "2023-09-06T06:39:22Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "May also require IANA considerations for registration.",
          "createdAt": "2023-09-06T06:40:11Z",
          "updatedAt": "2023-09-06T06:40:11Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposing `jwt-client-attestation` , `jwt-client-attestation-pop`",
          "createdAt": "2023-09-06T06:42:02Z",
          "updatedAt": "2023-09-06T06:42:02Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "JWS/JWT typ is a media type and based on https://datatracker.ietf.org/doc/html/rfc8725#name-use-explicit-typing I'd propose something like `oauth-client-attestation+jwt` and `oauth-client-attestation-pop+jwt`\r\n\r\nAnd FWIW you can kinda follow how DPoP registered and used the `application/dpop+jwt` media type to allow for explicit typing there https://www.rfc-editor.org/rfc/rfc9449.html or `application/at+jwt` from https://datatracker.ietf.org/doc/html/rfc9068 ",
          "createdAt": "2023-11-03T19:48:07Z",
          "updatedAt": "2023-11-03T19:48:07Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOJaEkaM5rrPuP",
      "title": "The same client attestation for the refresh token flow",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/31",
      "state": "CLOSED",
      "author": "TakahikoKawasaki",
      "authorAssociation": "NONE",
      "assignees": [
        "tplooker"
      ],
      "labels": [],
      "body": "The \"Refresh token binding\" section requires _\"The client MUST also use the same Client Attestation.\"_\r\n\r\nWhat is the intention of the requirement from the following options?\r\n\r\n1. **The exactly same client attestation JWT.** The refresh token becomes invalid after the client attestation JWT expires. **Even if the attester issues a new client attestation JWT for the same client key, the new client attestation JWT would not work with the refresh token.** If the requirement expects this behavior, AS implementations would simply use the hash of the client attestation JWT to judge whether the client attestation JWT presented in the refresh token flow is identical to the previous one.\r\n2. **Any client attestation JWT for the same client key issued by the same attester.** If this is the actual intention of the requirement, even after the original client attestation JWT expires, the refresh token can be used with a new client attestation JWT issued by the same attester. In this case, AS implementations would check the combination of the attester's identifier and the client key during the refresh token flow.\r\n3. **Any client attestation JWT for the same client key issued by any attester the AS trusts.** If this is the actual intention of the requirement, even after the original client attestation JWT expires and/or even after the attester ceases its service, the refresh token can be used with a new client attestation issued by any attester the AS trusts. In this case, AS implementations would check the JWK thumbprint of the client key only during the refresh token flow and would not check whether the attester is identical to the one of the previous client attestation JWT.\r\n\r\nFYI: [RFC 8705](https://www.rfc-editor.org/rfc/rfc8705.html) defines a mechanism to bind an X.509 certificate to an access token. The specification states that a JWT access token should include `\"x5t#S256\"` (which represents the SHA-256 thumprint of an X.509 certificate) in its payload if the access token is bound to a certain X.509 certificate. It results in that certificate-bound access tokens and refresh tokens expire when their X.509 certificates expire and that renewing X.509 certificates for the same subject does NOT revive the access tokens and refresh tokens. Therefore, client applications have to go through an authorization flow again to get a new access token once the X.509 certificate bound to the previous access token expires.\r\n\r\nThere are pros and cons. The requirement will need to be rephrased depending on what the \"refresh token binding\" wants to achieve.",
      "createdAt": "2023-07-16T08:37:24Z",
      "updatedAt": "2023-09-08T21:43:05Z",
      "closedAt": "2023-09-08T21:43:05Z",
      "comments": [
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, the statement \"The client MUST also use the same Client Attestation that was used for authentication when the refresh token was issued.\" is problematic and needs to be removed or rephrased. \r\n\r\nThe intent, as I understand it from previously discussing/pushing the issue of RT binding for this draft, is that the RT needs to be bound to the client instance. And that means binding the RT to the client instance's key. I think Tobias didn't want to go so far as saying that b/c he thought it was too inflexible. But the client instance's key is currently the only thing here that uniquely identifies the client instance. ",
          "createdAt": "2023-07-20T21:28:07Z",
          "updatedAt": "2023-07-20T21:28:07Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "@bc-pi is correct around the intent here, I agree the wording makes it unclear so it should be clarified that the binding is to the client instance key used when the RT was issued.",
          "createdAt": "2023-09-06T06:38:30Z",
          "updatedAt": "2023-09-06T06:38:30Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOJaEkaM5rrQsf",
      "title": "Client Backend -> Client Attester",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/32",
      "state": "OPEN",
      "author": "TakahikoKawasaki",
      "authorAssociation": "NONE",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "\"Client Backend\" in the specification should be replaced with \"Client Attester\".\r\n\r\n\"Client Backend\" creates the impression that both the client and the system issuing the attestation for the client are managed by the same entity. While it is possible for actual deployments to be structured in this manner, it appears that the specification intends to treat them as separate entities.",
      "createdAt": "2023-07-16T08:52:40Z",
      "updatedAt": "2023-11-09T22:32:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "TakahikoKawasaki",
          "authorAssociation": "NONE",
          "body": "In that sense, the example payload of the Client Attestation JWT in the \"Client Attestation JWT\" section should be updated from\r\n\r\n```json\r\n{\r\n  \"iss\": \"https://client.example.com\",\r\n  \"sub\": \"https://client.example.com\",\r\n  \"nbf\":1300815780,\r\n  \"exp\":1300819380,\r\n  \"cnf\": {\r\n    \"jwk\": {\r\n      \"kty\": \"EC\",\r\n      \"use\": \"sig\",\r\n      \"crv\": \"P-256\",\r\n      \"x\": \"18wHLeIgW9wVN6VD1Txgpqy2LszYkMf6J8njVAibvhM\",\r\n      \"y\": \"-V4dS4UaLMgP_4fY4j8ir7cl1TXlFdAgcx55o7TkcSA\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nto\r\n\r\n\r\n```json\r\n{\r\n  \"iss\": \"https://attester.example.com\",\r\n  \"sub\": \"https://client.example.com\",\r\n  \"nbf\":1300815780,\r\n  \"exp\":1300819380,\r\n  \"cnf\": {\r\n    \"jwk\": {\r\n      \"kty\": \"EC\",\r\n      \"use\": \"sig\",\r\n      \"crv\": \"P-256\",\r\n      \"x\": \"18wHLeIgW9wVN6VD1Txgpqy2LszYkMf6J8njVAibvhM\",\r\n      \"y\": \"-V4dS4UaLMgP_4fY4j8ir7cl1TXlFdAgcx55o7TkcSA\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n(Changing the value of the `\"iss\"` from `\"https://client.example.com\"` to `\"https://attester.example.com\"`)",
          "createdAt": "2023-07-16T08:58:45Z",
          "updatedAt": "2023-07-16T08:58:45Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Hello @TakahikoKawasaki we are having the exact same discussions between the editors, so thanks for your feedback! If you have any further rationale for having separate entities, please let us know",
          "createdAt": "2023-07-16T10:17:53Z",
          "updatedAt": "2023-07-16T10:17:53Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I've discussed this issue today with my colleague, we agree to this change.\r\nEspecially `sub` should match the `client_id` in the issuance.\r\nVersion might be separated into an additional, optional attribute",
          "createdAt": "2023-07-18T14:16:55Z",
          "updatedAt": "2023-07-18T14:16:55Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "add text on iss and sub",
          "createdAt": "2023-09-06T06:52:17Z",
          "updatedAt": "2023-09-06T06:52:17Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The `iss` of the Client Attestation JWT should identify the issuer of the Client Attestation JWT. When it's the client backend (which I think will be a common case), the `iss` value should be the client id value and the verification key should be found from the `jwks_uri` or `jwks_uri` field of that client (however that client info comes to exist with the AS). When the Client Attestation JWT is issued by some attestation service, the `iss` value should identify that service. And the AS needs to trust the service for this purpose and know how to find verification keys for it. \r\n\r\nThe `sub` of the Client Attestation JWT should be the client id value. ",
          "createdAt": "2023-11-09T22:07:39Z",
          "updatedAt": "2023-11-09T22:07:39Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "> The `iss` of the Client Attestation JWT should identify the issuer of the Client Attestation JWT. When it's the client backend (which I think will be a common case), the `iss` value should be the client id value and the verification key should be found from the `jwks_uri` or `jwks_uri` field of that client (however that client info comes to exist with the AS). When the Client Attestation JWT is issued by some attestation service, the `iss` value should identify that service. And the AS needs to trust the service for this purpose and know how to find verification keys for it. \n> \n> The `sub` of the Client Attestation JWT should be the client id value. \n\nThis is exactly my opinion.",
          "createdAt": "2023-11-09T22:17:13Z",
          "updatedAt": "2023-11-09T22:17:13Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, I'm not totally convinced there's really a need to allow for an attestation service that's not managed by the same entity as the client but other folks seem to want it so my prior comment assumes it. ",
          "createdAt": "2023-11-09T22:30:44Z",
          "updatedAt": "2023-11-09T22:32:18Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDOJaEkaM5sKCbK",
      "title": "Attestation JWT should be reusable but there's contradictory text ",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/33",
      "state": "CLOSED",
      "author": "bc-pi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tplooker"
      ],
      "labels": [],
      "body": "The Client Attestation JWT seems like a long(er) lived credential that should be reusable so the client instance doesn't have to go get a new one each time (right?*).  But this text [here](https://www.ietf.org/archive/id/draft-looker-oauth-attestation-based-client-auth-00.html#section-4.1.1-2.7) for the Client Attestation JWT has 'The authorization server MAY ensure that JWTs are not replayed by maintaining the set of used \"jti\" values for the length of time for which the JWT would be considered valid based on the applicable \"exp\" instant' that suggests the AS might limit them to single use. I think that sentence can just be removed. \r\n\r\n\r\n\\* right: https://www.ietf.org/archive/id/draft-looker-oauth-attestation-based-client-auth-00.html#name-reuse-of-a-client-attestati ",
      "createdAt": "2023-07-20T18:26:11Z",
      "updatedAt": "2023-09-07T21:03:31Z",
      "closedAt": "2023-09-07T21:03:31Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, need to remove this sentence from step 7 of 4.1.1.",
          "createdAt": "2023-09-06T06:34:06Z",
          "updatedAt": "2023-09-06T06:34:06Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "I_kwDOJaEkaM5sKH5r",
      "title": "PoP JWT example is not consistent with spec text",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/34",
      "state": "CLOSED",
      "author": "bc-pi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tplooker"
      ],
      "labels": [],
      "body": "The text says jti is required https://www.ietf.org/archive/id/draft-looker-oauth-attestation-based-client-auth-00.html#section-4.1.2-2.3 but the example doesn't have jti https://www.ietf.org/archive/id/draft-looker-oauth-attestation-based-client-auth-00.html#section-4.1.2-3\r\n",
      "createdAt": "2023-07-20T18:38:19Z",
      "updatedAt": "2023-09-07T21:03:31Z",
      "closedAt": "2023-09-07T21:03:31Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate of #37 ",
          "createdAt": "2023-09-06T06:32:25Z",
          "updatedAt": "2023-09-06T06:32:25Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "I_kwDOJaEkaM5sN-zP",
      "title": "Should token_endpoint_auth_signing_alg be considered?",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/35",
      "state": "OPEN",
      "author": "TakahikoKawasaki",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "[OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html), [Section 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata), defines the `token_endpoint_auth_signing_alg` client metadata as follows.\r\n\r\n>OPTIONAL. [JWS](https://openid.net/specs/openid-connect-registration-1_0.html#JWS) [JWS] `alg` algorithm [[JWA]](https://openid.net/specs/openid-connect-registration-1_0.html#JWA) that MUST be used for signing the JWT [[JWT]](https://openid.net/specs/openid-connect-registration-1_0.html#JWT) used to authenticate the Client at the Token Endpoint for the `private_key_jwt` and `client_secret_jwt` authentication methods. All Token Requests using these authentication methods from this Client MUST be rejected, if the JWT is not signed with this algorithm. Servers SHOULD support `RS256`. The value `none` MUST NOT be used. The default, if omitted, is that any algorithm supported by the OP and the RP MAY be used.\r\n\r\nShould server-side implementations of the `attest_jwt_client_auth` client authentication method take the client metadata into consideration? To be concrete, should server-side implementations reject requests when the Client Attestation PoP JWT is not signed with the algorithm specified by the client metadata if the metadata is set, or may server-side implementations ignore the client metadata when processing the `attest_jwt_client_auth` client authentication method?",
      "createdAt": "2023-07-21T10:56:23Z",
      "updatedAt": "2023-11-08T14:16:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "In general I agree that a piece of metadata like this is useful, the other option which springs to mind is to reuse the token_endpoint_auth_signing_alg metadata property for this auth method instead of defining a new metadata element.",
          "createdAt": "2023-09-06T06:29:07Z",
          "updatedAt": "2023-09-06T06:29:07Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Which ever metadata element we choose for this purpose it should apply to BOTH the attestation JWT and PoP JWT.",
          "createdAt": "2023-09-06T06:29:43Z",
          "updatedAt": "2023-09-06T06:29:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "We would also need to clarify that the signing algorithm used for the attestation JWT and PoP JWT do not need to be the same however both would need to be permitted for the client making the request to the authorization server.",
          "createdAt": "2023-09-06T06:32:05Z",
          "updatedAt": "2023-09-06T06:32:05Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Considering this more I think it is safer to have a new seperate metadata element for signalling support algorithms for this client authentication mechanism.",
          "createdAt": "2023-11-06T07:59:13Z",
          "updatedAt": "2023-11-06T07:59:13Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "I believe the re-use of both AS discovery `token_endpoint_auth_signing_alg_values_supported` and Client `token_endpoint_auth_signing_alg` is the right way to move forward and needs to be mentioned in the document.\r\n\r\n---\r\n\r\n> token_endpoint_auth_signing_alg_values_supported\r\n\r\nJSON array containing a list of the JWS signing algorithms supported by the token endpoint for the signature on the JWT used to authenticate the client at the token endpoint\r\n\r\nThis fits.\r\n\r\n--- \r\n\r\n> token_endpoint_auth_signing_alg\r\n\r\nJWS alg algorithm that MUST be used for signing the JWT used to authenticate the Client at the Token Endpoint for the private_key_jwt and client_secret_jwt authentication methods\r\n\r\nThis doesn't fit but only needs an updated description.",
          "createdAt": "2023-11-08T14:13:54Z",
          "updatedAt": "2023-11-08T14:16:15Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "I_kwDOJaEkaM5sTgXa",
      "title": "Sender-Constrained Access Token",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/36",
      "state": "CLOSED",
      "author": "TakahikoKawasaki",
      "authorAssociation": "NONE",
      "assignees": [
        "tplooker"
      ],
      "labels": [],
      "body": "The specification contains sentences related to sender-constrained acess tokens as follows.\r\n\r\n#### In the \"1. Introduction\" section:\r\n>... The Authorization Server may continue to issue sender-constrained access tokens using DPOP.\r\n\r\n#### In the \"4.1.1. Client Attestation JWT\" section:\r\n> The JWT MUST contain an \"cnf\" claim conforming RFC7800 that conveys the key to be used for sender constraining tokens issued by the authorization server. The key MUST be expressed using the \"jwk\" representation.\r\n\r\n### Questions\r\n\r\n**Q1.** \"**Client authentication**\" and \"**sender-constrained access token**\" are different. Is the specification trying to define requirements not only for client authentication but also for sender-constrained access tokens? (FYI: [RFC 8705](https://www.rfc-editor.org/rfc/rfc8705.html) defines \"client authentication\" in [Section 2](https://www.rfc-editor.org/rfc/rfc8705.html#section-2) and defines \"sender-constrained access token\" in [Section 3](https://www.rfc-editor.org/rfc/rfc8705.html#section-3).)\r\n\r\n**Q2.** DPOP is mentioned abruptly in the Introduction section but not referenced anywhere else. Is this mention of DPOP merely an example of sender-constrained access tokens, or is it a requirement to bind the Client Instance Key to the access token as if it were specified by DPOP? If it is not a normative requirement, mentioning DPOP would only cause confusion without any benefits. On the contrary, if it is a normative requirement, detailed explanation is needed.\r\n\r\n**Q3.** The explanation about the `cnf` claim of the Client Attestation JWT requires authorization server implementations to bind the Client Instance Key to access tokens. Is this normative requirement really intended? If it is intended, how does the client prove that it possesses the private key of the Client Instance Key when accessing protected resource endpoints? DPOP?",
      "createdAt": "2023-07-23T09:11:07Z",
      "updatedAt": "2024-01-26T03:43:14Z",
      "closedAt": "2024-01-26T03:43:13Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "The introduction text is fixed by #19 ",
          "createdAt": "2023-09-06T06:21:21Z",
          "updatedAt": "2023-09-06T06:21:21Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Q2 - We will clarify that any usage of this client authentication method with DPoP is entirely optional. It is as you highlight first and foremost a client authentication method.\r\n\r\nQ3 - This is a mistake in the language, thanks for highlighting as above, DPoP is entirely optional.",
          "createdAt": "2023-09-06T06:24:46Z",
          "updatedAt": "2023-09-06T06:24:46Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "The explicit reference to DPoP was removed from the introduction for now.\r\n\r\nI would consider adding it to implementation considerations as a recommendation to use DPoP-bound access tokens after client authentication with this spec to achieve a consistent security level",
          "createdAt": "2023-11-01T15:51:22Z",
          "updatedAt": "2023-11-01T15:51:22Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this issue has now been addressed, intend to close soon if there are no objections.",
          "createdAt": "2023-11-09T20:56:36Z",
          "updatedAt": "2023-11-09T20:56:36Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as I believe this now resolved, please reopen if need be.",
          "createdAt": "2024-01-26T03:43:13Z",
          "updatedAt": "2024-01-26T03:43:13Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "I_kwDOJaEkaM5s9MJ6",
      "title": "Client Attestation PoP JWT does not contain mandatory \"jti\" claim",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/37",
      "state": "CLOSED",
      "author": "tlodderstedt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tplooker"
      ],
      "labels": [],
      "body": "The spec states: \r\n\r\n\"The JWT MUST contain a \"jti\" (JWT ID) claim that provides a unique identifier for the token. The authorization server MAY ensure that JWTs are not replayed by maintaining the set of used \"jti\" values for the length of time for which the JWT would be considered valid based on the applicable \"exp\" instant.\"\r\n\r\nHowever the `jti` is not shown in the example in the same section. ",
      "createdAt": "2023-07-30T15:41:43Z",
      "updatedAt": "2023-09-07T21:03:32Z",
      "closedAt": "2023-09-07T21:03:32Z",
      "comments": []
    },
    {
      "number": 38,
      "id": "I_kwDOJaEkaM5s9MrT",
      "title": "endpoint URL in pop JWT?",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/38",
      "state": "CLOSED",
      "author": "tlodderstedt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tplooker"
      ],
      "labels": [
        "pending-close"
      ],
      "body": "Should the actual URL the client attestation pop JWT shall be sent to be included in the pop JWT?\r\n\r\nDPoP has it but I assume the nonce is powerful enough to protect against replay but want to make sure we have thought about it.",
      "createdAt": "2023-07-30T15:48:54Z",
      "updatedAt": "2023-10-23T20:31:40Z",
      "closedAt": "2023-10-23T20:31:40Z",
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I didn't get the \"actual URL\" , do you mean the `htu` value?",
          "createdAt": "2023-07-30T18:06:57Z",
          "updatedAt": "2023-07-30T18:06:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "@tlodderstedt can you confirm what you mean, I read your issue as meaning we should be including the endpoint that the PoP is going to be presented at (e.g the token endpoint)?",
          "createdAt": "2023-09-06T06:17:02Z",
          "updatedAt": "2023-09-06T06:17:02Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yes, that's what I mean. The PoP should be restricted to the endpoint URL it is sent to. ",
          "createdAt": "2023-09-12T19:22:51Z",
          "updatedAt": "2023-09-12T19:22:51Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "The HTU claim in DPoP serves a couple of purposes which are freshness and audience constraint. With this draft the client attestation PoP already has normative text around populating the aud value for audience constraint and a mechanism around jti for a limited solution to detecting freshness (replay attacks). We also have #39 discussing a solution to a server generated nonce which will improve the freshness (replay attacks). With those mechanisms in place I dont believe we also need an HTU style claim.",
          "createdAt": "2023-09-13T22:22:06Z",
          "updatedAt": "2023-09-13T22:22:06Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "I_kwDOJaEkaM5wQR5G",
      "title": "Replay prevention",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/39",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "To prevent replay attacks the following mechanisms could be used:\r\n- AS/Issuer providing a nonce\r\n- reuse of existing of existing parameters as nonce\r\n- limiting the lifetime of PoP (through JTI)\r\n\r\n### AS/Issuer providing a nonce\r\nThis requires an additional endpoint/ an additional roundtrip\r\n\r\n### reuse of existing of existing parameters as nonce\r\nFor some flows it might be doable to reuse the auth code/pre-auth code as a nonce, this saves another roundtrip but might not work for all flows, like PAR endpoint\r\n\r\n### limiting the lifetime of PoP (through JTI)\r\nThis is the existing mechanism described in the spec, the JWT PoP includes a jti and the AS needs to keep track of used jti values until they are expired",
      "createdAt": "2023-09-06T06:17:55Z",
      "updatedAt": "2023-10-23T20:32:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Option 2 is grant specific and not desired.\r\nOption 3 is in the text as a MAY\r\nOption 1 should be considered in DPoP-style and be added to the text",
          "createdAt": "2023-09-06T07:02:52Z",
          "updatedAt": "2023-09-06T07:02:52Z"
        },
        {
          "author": "PieterKas",
          "authorAssociation": "NONE",
          "body": "Support for a server generated nonce over which the attestation can be generated is something that is highly desirable to protect against pre-computation attacks. We have seen attacks where attackers deploy malware an pre-compute signatures (including manipulation of the system clock) and then exfiltrating these signatures for future use. This was one of the reasons why we strongly advocated for the inclusion of server supplied nonces in the DPoP standard. \r\n \r\nPerhaps we can use a similar mechanism as in DPoP to include an optional server supplied nonce when generating the attestation (see Section 8 and 9 in DPoP for inspiration on supplying nonces as part of the interaction with the authorization and resource servers). The inclusion of  the nonce as part of a 200 response helps save on roundtrips (bar the first need for a nonce).\r\n",
          "createdAt": "2023-09-07T10:42:47Z",
          "updatedAt": "2023-09-07T10:42:47Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "todo: describe how a nonce request error look like",
          "createdAt": "2023-10-23T20:32:12Z",
          "updatedAt": "2023-10-23T20:32:12Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDOJaEkaM5x3qkF",
      "title": "[client_assertion_pop] JWTs concatenated and separated by ~ vs self-explanatory parameter names",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/45",
      "state": "CLOSED",
      "author": "peppelinux",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the current solution under development in Italy, the debate on the use of this wonderful draft has been alive for months.\r\n\r\nFrom the experiences and positions collected there seems to be a general refusal to recognize as \"beautiful\" the concatenation of JWTs divided by the ~ character within the `client_assertion` parameter.\r\n\r\nFor those who don't know, the crime of ugliness does not yet exist in Italy but there is great sensitivity in the search for beauty even in implementations.\r\n\r\nThere are alternative ways to proof the PoP, like DPoP. Unfortunately convey large JWT in a HTTP header like DPoP may have impacts on the tuning of the httpd services that would require a specialized configuration to allow http headers larger than 4KB. This has relevant impacts in the cases where a JWT carries x5c or Federation trust chains within its headers, where a JWT could be more than 4KB.\r\n\r\nEven if there are other specs that uses concatenation of JWTs using `~` as separator char, like SD-JWT. However SD-JWT tends to be self-contained artifact, general purpose and agnostic from the way it is transported. Then I'd tend to leave out SD-JWT from this thread.\r\n\r\nConsidering that this draft aims to extend RFC7521, I'd suggest to not use the concatenation two JWTs using `~` but the definition of a new parameter, that we may call `client_assertion_pop` to convey the client attestation PoP. This proposal suggests a good semantic with self-explanatory parameter names, in a modular way that aims to extend RFC7521 with explicit parameters as additional modules, that may be used where PoP is required.\r\n\r\n",
      "createdAt": "2023-09-24T23:25:42Z",
      "updatedAt": "2023-10-09T12:34:18Z",
      "closedAt": "2023-10-09T12:34:17Z",
      "comments": [
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "[Giuseppe asked for my thoughts]  \r\nRFC7521 largely only envisioned a single assertion so building on it for the intended functionality of this draft isn't a perfect fit. The current approach of the `client_assertion` parameter value having the two tilde separated JWTs is fine, though, in my opinion. And I don't believe that defining  new parameter for the Client Attestation PoP JWT would be a material improvement.    \r\n\r\n",
          "createdAt": "2023-09-25T15:10:41Z",
          "updatedAt": "2023-09-25T18:28:32Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Then you definitively suggest to detect the `client_assertion` value format by filter with the `client_assertion_type`",
          "createdAt": "2023-09-25T17:09:30Z",
          "updatedAt": "2023-09-25T17:09:30Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, the value of the `client_assertion_type` is intended to indicate the format (and other aspects) of the `client_assertion` value.",
          "createdAt": "2023-09-25T17:39:32Z",
          "updatedAt": "2023-09-25T17:39:32Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since an agreement was found about the adoption of the current specs as they are and without requesting any breaking change, this thread doesn't represent an issue anymore.\r\n[\r\nHere the related PR](https://github.com/italia/eudi-wallet-it-docs/pull/138) that uses this specs as it is in the it wallet",
          "createdAt": "2023-10-09T12:34:17Z",
          "updatedAt": "2023-10-09T12:34:17Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "I_kwDOJaEkaM5x3sO_",
      "title": "extend use beyond authorization servers",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/46",
      "state": "OPEN",
      "author": "peppelinux",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "According to RFC7521 this draft aims to give specification about how to get authenticated with an AS, as we read in the introductory text\r\n\r\n> [[RFC7521](https://vcstuff.github.io/draft-ietf-oauth-attestation-based-client-auth/draft-ietf-oauth-attestation-based-client-auth.html#RFC7521)] defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification uses this framework to define a new assertion type that provides a way for a client instance to authenticate itself with the authorization server through an assertion that is bound to a public key (for proof of possession).\r\n\r\nIf the usefulness and purpose of this draft is clear, at the same time we perceive a great potential that could also be useful in other contexts.\r\n\r\nLately there has been a lot of talk about the use of the nonce as a definitive prevention against replay attacks, and the importance of the nonce endpoint for issuing these is often discussed.\r\n\r\nIn the background we have the emerging wallet ecosystem which proposes reversed roles at different times, where the wallet is a client in the issuance phase towards a credential issuer which is an AS, while it is a sort of AS in the presentation phase towards the Relying Party.\r\n\r\nThis draft could enable the authentication of a client (wallet) to a third party (either this AS or RP) before obtaining the nonce.\r\n\r\nthe possible nonce endpoint could present itself as a protected endpoint, the nonce should only be issued to authenticated parties.\r\n\r\nThis generalization would require greater flexibility compared to the current purposes of the draft, which envisages its use only when the audience is an AS, while it could also be an RP, where the wallet instance attestation with PoP can be provided before any kind of transaction takes place (allowing the RP to discover the wallet capabilities before issuing the signed request object).",
      "createdAt": "2023-09-24T23:50:46Z",
      "updatedAt": "2023-11-01T16:23:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "David-Chadwick",
          "authorAssociation": "NONE",
          "body": "From a trust perspective I think that issuing and presentation of credentials are different. The user/wallet typically trusts the issuer, otherwise why would it ask for a credential from it? OTOH, the user/wallet cannot trust any random RP that it connects to. Therefore the user/wallet should expect the issuer to authenticate itself first to the user/wallet, before authenticating itself to the issuer. OTOH the user should expect the verifier to identify itself first, so that it can determine if this verifier is trustworthy, before progressing any further with authentication or capability determination.",
          "createdAt": "2023-09-25T09:50:31Z",
          "updatedAt": "2023-09-25T09:50:31Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I fully agree with you @David-Chadwick, in any cases the parties must establish trust before any protocol specific flow (issuance or presentation) may happen.\r\n\r\nthis issue aims to use an verifiable attestation based approach not just for client-AS (issuance) but also from AS-client (presentation), where the flow is conditioned by which entity has availability of endpoints (CI, RP) and which one not (wallet instances)",
          "createdAt": "2023-09-25T11:16:25Z",
          "updatedAt": "2023-09-25T11:16:25Z"
        },
        {
          "author": "fbaud",
          "authorAssociation": "NONE",
          "body": "@David-Chadwick @peppelinux, I agree that issuing and verifiying are entirely different from a trust perspective. But my angle would be to emphasize this from the issuer/verifier perspective:\r\n\r\n- as an issuer, I want to trust the wallet I'm issuing a credential to. At the minimum, I want to check that the wallet has received some form of authorization to receive a credential that was defined by a user agent (a widget in our case at Primus Money)\r\n- as a verifier, I may just want to identify who is presenting a credential so that I can reconcile it with my backend data server. Most of the time, identification could be self-contained within the presentation itself. The more empediment (excessive authentication requirement) for the wallet to provide a credential, the less useful it is for the verifier.\r\n\r\nI agree that from the wallet perspective, the angle is the symetric: more requirements on the verifier to identify itself, no excessive requirement on the issuer for most of the types of credentials.\r\n\r\nI must stress that in our architecture, we have the additional element that is the widget which is the first interface between the user and the issuer/verifier. We are in a context where the widget connects to a SaaS infrastructure and we have again different trust requirements between issuing and verifying:\r\n\r\n- for issuing, the widget needs to authentify to specify the type of credentials it authorizes the SaaS server to issue\r\n-  for verification, except the concerns about Denial Of Service, the requirement to authentify are much less stringent and we can imagine workflows where we let anyone who wants to submit a presentation to let them do that. ",
          "createdAt": "2023-09-25T11:52:05Z",
          "updatedAt": "2023-09-25T11:52:05Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@fbaud I agree with you and I'd buy also this \r\n\r\n> Most of the time, identification could be self-contained within the presentation itself. The more empediment (excessive authentication requirement) for the wallet to provide a credential, the less useful it is for the verifier.\r\n\r\nAt the same time the RP should know the wallet capabilities to know which are the supported sign and enc alg (and enc), if the wallet solution supports the presentation_definition_uri and so on.\r\n\r\nIn italy we use the wallet instance also to carry these capabilities, [here an example](https://italia.github.io/eudi-wallet-it-docs/versione-corrente/en/wallet-instance-attestation.html#format-of-the-wallet-instance-attestation)\r\n\r\nthis feature consolidates how a wallet capabilities discovery is required for a good interoperability, let's consider that a signature alg may be discovered vulnerable or the continuous technology advancement and innovation that will introduce periodically new features and algs.\r\n\r\nI believe that having a wallet capabilities discovery process, seamless in both issuance and presentation, is a future proof approach\r\n",
          "createdAt": "2023-09-25T12:29:50Z",
          "updatedAt": "2023-09-25T12:29:50Z"
        },
        {
          "author": "fbaud",
          "authorAssociation": "NONE",
          "body": "@peppelinux I think that the discovery process between the wallet and the server can be done without authentication.\r\nIt is more part of a protocol negotiation than part of a transaction. Transaction may need authentication, but for the verifier the point was more: \"give me all you can give and I'll sort it out\". While for the issuing, after possibly negotiating what alg, trust_chain, credential format,.. will be used, the server may need to authenticate the wallet (or check that it has the right authorisations) before delivering the credential. But nevertheless, we should also imagine that a wallet can request a credential without having to authenticate (like for a server delivering a timestamped credential for a process requiring a dead-man switch).",
          "createdAt": "2023-09-25T13:35:57Z",
          "updatedAt": "2023-09-25T13:36:54Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@fbaud How an RP discovers the wallet capabilities is something that should happen before the issuance of the signed request object. At the same time the RP must be sure that the WIA is in the legitimate possession of the Holder, with the authentication through the WIA+PoP\r\n\r\nthis approach would fit with the nonce_endpoint discussed here: https://github.com/openid/OpenID4VCI/issues/71#issuecomment-1733791449 where in addition we protect the issuance of the nonce with a wallet instance authz\r\n\r\n>  But nevertheless, we should also imagine that a wallet can request a credential without having to authenticate (like for a server delivering a timestamped credential for a process requiring a dead-man switch).\r\n\r\nyes, the autentication would be quite modular and for Type 1 and some Type 2 credentials, according to the required LoA\r\n",
          "createdAt": "2023-09-25T14:21:46Z",
          "updatedAt": "2023-09-25T14:22:57Z"
        },
        {
          "author": "David-Chadwick",
          "authorAssociation": "NONE",
          "body": "The verifier must trust the issuer, otherwise it cannot accept the issued credentials that are held by the user/wallet, regardless of the capabilities of the wallet. However, we know that the wallet must have the capability to accept the credential from the issuer.\r\nConsequently the verifier should obtain the meta data of the issuer, and this will provide the verifier with (possibly a superset of) the capabilities of the wallet. Thus I think it is a false requirement for the verifier to determine the capabilities of the wallet. Rather it should determine the capabilities of the issuer. If the verifier is capable of accepting all of these capabilities, then it knows that it can accept the credential from the wallet, regardless of what capability the wallet has. Now, I accept that a wallet may only support a subset of the capabilities of the issuer, but providing the verifier can support all the capabilities of the issuer this is not be a problem. The problem arises if we have both a verifier and a wallet that only support a subset of the capabilities of the issuer, and these are disjoint sets. But in this case there is little point in the verifier determining the capabilities of the wallet, as it cannot interwork with it. Thus the verifier should request the credential from the wallet using (a subset of) the capabilities of the issuer, and see if the wallet can provide it in this format. I don't believe the verifier needs to pre-determine the capabilities of the wallet.",
          "createdAt": "2023-09-25T21:13:25Z",
          "updatedAt": "2023-09-25T21:13:25Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What if ... \r\n\r\n1. The wallet instance encrypts the presentation response with an enc alg that's not supported by the verifier?\r\n2. The wallet instance doesn't support presentation_definition_uri? (see `presentation_definition_uri_supported`)\r\n3. The wallet instance doesn't support a specific vp format? (see `vp_formats_supported`)\r\n4. The wallet instance has to provide the `authorization_endpoint` to the verifier? (... Can be custom URI scheme, or Universal Links/App links ...)\r\n\r\nthen, having these previous, why the wallet capabilities discovery would be a false requirement?",
          "createdAt": "2023-09-26T07:04:37Z",
          "updatedAt": "2023-09-26T07:04:37Z"
        },
        {
          "author": "David-Chadwick",
          "authorAssociation": "NONE",
          "body": "@peppelinux In answer to the above\r\n1. This is a (lack of) capability of the verifier. If it is constrained in this way it should inform the wallet in the request for the VP or via its metadata\r\n2. The wallet will return an error to the RP\r\n3. It is most likely that the wallet will support the same formats for VCs as for VPs. I think it highly unlikely that a wallet will support say a JWT VC and not a JWT VP. Thus the verifier can infer what vp format(s) will be supported by seeing what VC format(s) the issuer provides to the wallet.\r\n4. In our interworking tests the RP had to have a web page with the correct wallet endpoints so that the user could click on the correct one. In the case of a cloud wallet, the user had to enter this URL to the RP (since the RP cannot know the endpoints of all (or any) cloud wallets. If the RP knows nothing about the user's wallet how do you expect the two to communicate? In our opinion, the connection had to be initiated by the user, and the user knows the endpoint of its own wallet",
          "createdAt": "2023-09-26T07:54:26Z",
          "updatedAt": "2023-09-26T07:54:26Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I got your point @David-Chadwick and I'd make your also mine, however I'm aware that having a proper discovery we would remove any fault, errors and failed transaction that may happen in the real world, in particular with an open ecosystem where different tecnologies and implementations profiles will end to be mixed. I see a future where an EIDAS Wallet solution may implements external features and then also did resolvers and additional capabilities. This would build an open ecosystem where interop and capabilities discovery represent a concrete and future proof requirement\r\n\r\nNot at least, preventing faults saves both users time and electricity :-)",
          "createdAt": "2023-09-26T08:56:46Z",
          "updatedAt": "2023-09-26T08:56:46Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @David-Chadwick here mostly. My observations are:\r\n- The Verifier will most certainly know which credentials he requires and the technical requirements are clear from the issuers, that the Verifier will accept\r\n- Wallet Capabilities and Wallet Attestations is not necessarily the same concept, indeed the Verifier metadata may be transmitted unsigned as well today in OpenID4VP\r\n- Wallet technical capabilities should be omitted or very constrained to not open up privacy issues\r\n- if the technical capabilities of the Wallet and Verifier do not match, this will ultimately result in an error, no matter if the Verifier detects the capabilities or not\r\n\r\nAs this discussion is happening in the Client attestation draft, I would like to limit this discussion mostly to the question whether we need client authentication for Wallet-Verifier interaction and what would be necessary for this draft to accomplish this",
          "createdAt": "2023-11-01T16:23:02Z",
          "updatedAt": "2023-11-01T16:23:02Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "I_kwDOJaEkaM5x3vhj",
      "title": "PoP attestation binding ",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/47",
      "state": "OPEN",
      "author": "peppelinux",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Even if remote, there is the possibility that an implementation re-uses the same cryptographic keys for different scopes.\r\n\r\nthe PoP JWT could be used with the same cryptograhic key attested in more than a single attestation and therefore be replicated for different endpoints/audience\r\n\r\nWhat do you think about getting the `ath` claim inside the DPoP token as requested?\r\n\r\nIn this way, a DPoP token cannot be replicated when the key that proves possession is the same within different attestations.\r\n\r\nEven if DPoP specs defines `ath` in relation to an access token, may we consider that any kind of JWT could represent an access token, in relation of its scope, the flow where it is used and its usage in general?\r\n\r\nThen, could we provide a binding of the PoP to a specific attestation where the possession aims to be proved?",
      "createdAt": "2023-09-25T00:16:42Z",
      "updatedAt": "2023-11-06T07:50:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For better clarity\r\n\r\nan aud is not enough where a pop is used on a different attestation that has in common the same key used for the signature of another attestation\r\n\r\nit's an implementation risk where an implementer would use the same key for different attestations\r\n\r\nonce you have one, you can replay the same PoP for another/different attestation that has in common the same key\r\nhash of the attestation is then required, WDYT?",
          "createdAt": "2023-09-25T11:07:05Z",
          "updatedAt": "2023-09-25T11:07:05Z"
        },
        {
          "author": "asharif1990",
          "authorAssociation": "NONE",
          "body": "> Even if remote, there is the possibility that an implementation re-uses the same cryptographic keys for different scopes.\r\n> \r\n> the PoP JWT could be used with the same cryptograhic key attested in more than a single attestation and therefore be replicated for different endpoints/audience\r\n> \r\n> What do you think about getting the `ath` claim inside the DPoP token as requested?\r\n> \r\n> In this way, a DPoP token cannot be replicated when the key that proves possession is the same within different attestations.\r\n> \r\n> Even if DPoP specs defines `ath` in relation to an access token, may we consider that any kind of JWT could represent an access token, in relation of its scope, the flow where it is used and its usage in general?\r\n> \r\n> Then, could we provide a binding of the PoP to a specific attestation where the possession aims to be proved?\r\n\r\nI can see the benefits of binding the wallet instance attestations to the specific proof to avoid the possibility that it could be swapped in the case that the same cryptography keys are used by the implementers. I agree that the usage of a similar countermeasure like `ath` that is defined in the DPoP specification can work here as a mitigation. However, it would be better to introduce a new claim for this to be included in PoP as `ath` meant for the Access Token, and here as we deal with Wallet Instance Attestation maybe we can use the following claim `wiah`?",
          "createdAt": "2023-09-25T13:00:08Z",
          "updatedAt": "2023-09-25T13:00:08Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you propose a new claim in the Client Attestation PoP JWT thats value is the hash of the corresponding Client Attestation JWT?",
          "createdAt": "2023-11-01T16:48:21Z",
          "updatedAt": "2023-11-01T16:48:21Z"
        },
        {
          "author": "asharif1990",
          "authorAssociation": "NONE",
          "body": "> Do you propose a new claim in the Client Attestation PoP JWT thats value is the hash of the corresponding Client Attestation JWT?\r\n\r\nYes Paul. That is the idea. ",
          "createdAt": "2023-11-01T17:04:13Z",
          "updatedAt": "2023-11-01T17:04:13Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "We will explore this, but initially it does not seem like a bad idea",
          "createdAt": "2023-11-06T07:50:03Z",
          "updatedAt": "2023-11-06T07:50:03Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "I_kwDOJaEkaM50wRKQ",
      "title": "Authorization code binding to client instance",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/56",
      "state": "OPEN",
      "author": "cobward",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, section 5.2 \"Refresh token binding\"  gives requirements for how an authorization server must bind the client instance to the refresh token. Could we reuse this mechanism to bind the authorization code to the client instance in the case that client auth was performed in the authorization request?",
      "createdAt": "2023-10-24T08:59:21Z",
      "updatedAt": "2023-11-06T13:49:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "@cobward do you mean in the event we are using something like a signed PAR request?",
          "createdAt": "2023-10-31T19:23:36Z",
          "updatedAt": "2023-10-31T19:23:36Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "If I understand you correctly, you get a similar set of assurances like with PKCE, so I'm unsure if we want to duplicate this mechanism.",
          "createdAt": "2023-11-06T07:42:59Z",
          "updatedAt": "2023-11-06T07:42:59Z"
        },
        {
          "author": "cobward",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @cobward do you mean in the event we are using something like a signed PAR request?\r\n\r\nI'm not sure that it only applies to signed PAR request. I mean just generally that if client authentication is required at the authorization endpoint then the same requirements of binding the client instance to the authorization code still apply.\r\n\r\n> If I understand you correctly, you get a similar set of assurances like with PKCE, so I'm unsure if we want to duplicate this mechanism.\r\n\r\nIf that is the case then would it make sense to add text to that effect? Something along the lines of:\r\n\r\n_The Authorization Server is not required to bind the client instance to the authorization code, as PKCE provides sufficient mitigation of security risks._\r\n",
          "createdAt": "2023-11-06T13:49:21Z",
          "updatedAt": "2023-11-06T13:49:21Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "I_kwDOJaEkaM50wo51",
      "title": "Refresh token binding after attestation expiration",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/57",
      "state": "CLOSED",
      "author": "cobward",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently section 5.2 states:\r\n> The client MUST also use the same key that was present in the \"cnf\" claim of the client attestation that was used for client authentication when the refresh token was issued.\r\n\r\nIn the case that the original client attestation JWT has expired, what should happen? If it is acceptable for the client to re-use the same key in the \"cnf\" field across attestation JWTs, then the client can easily generate a new attestation JWT with the same \"cnf\" key. But if the client needs to use a fresh \"cnf\" key, then I can think of three options:\r\n\r\n1. Define a flow which endorses the new \"cnf\" key with the old \"cnf\" key.\r\n2. Define a field in the client attestation JWT that contains a unique identifier for the client instance, and use that identifier to bind the refresh token to the client instance.\r\n3. Explicitly don't permit this in the specification, add text to the specification that makes it clear that the \"cnf\" key must stay the same across refreshed client attestations.\r\n\r\nMy preference would be for option 2.",
      "createdAt": "2023-10-24T09:57:44Z",
      "updatedAt": "2024-02-13T17:42:07Z",
      "closedAt": "2024-02-13T17:42:07Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> In the case that the original client attestation JWT has expired, what should happen?\r\n\r\nCurrently the client instance needs to go back to the client backend and request a new client attestation JWT bound to the same key used in the old JWT.\r\n\r\nIn general because we are effectively using the client instance key to identify the instance at the authorization server this makes key rotation of the client instance key difficult with active refresh tokens. \r\n\r\n1 feels too complex, 3 is an option and @bc-pi and I have discussed 2 before. The flip side to consider with option 2 is the privacy implications of formally electing to track client instances, personally i'm not convinced its a bad idea but we should carefully consider the impact.",
          "createdAt": "2023-10-31T02:31:47Z",
          "updatedAt": "2023-10-31T02:31:47Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In general because we are effectively using the client instance key to identify the instance at the authorization server\r\n\r\nDo we? I had assumed the AS identifies the client by the `sub` value. I don't see a need to identify a client instance. ",
          "createdAt": "2023-10-31T10:59:24Z",
          "updatedAt": "2023-10-31T10:59:24Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the forth option is to have long living client attestations, which in my opinion is no problem\r\n\r\nthe client should then use different attestations with different ASs",
          "createdAt": "2023-10-31T11:01:21Z",
          "updatedAt": "2023-10-31T11:01:21Z"
        },
        {
          "author": "cobward",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The flip side to consider with option 2 is the privacy implications of formally electing to track client instances, personally i'm not convinced its a bad idea but we should carefully consider the impact.\r\n\r\nThis just makes explicit the tracking of client instances that already existed through the requirement for the \"cnf\" key to stay the same over attestations.\r\n\r\n> the forth option is to have long living client attestations, which in my opinion is no problem\r\n\r\nThis is really a decision for the use-case in my opinion. In the context of software integrity being established through the client attestation, it is trivial to inject malware after the generation of the attestation, so some in some cases it may be a requirement to have fresh attestations.",
          "createdAt": "2023-10-31T15:13:49Z",
          "updatedAt": "2023-10-31T15:13:49Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Isn't the AS identifying the client also by the refresh token itself?\n\nI dislike option 2 due to the privacy implications. As any optional fields in the client attestation JWT are valid, profiles could still use this option, but it should not be a good requirement in my opinion.\n\nI see two options: \nA: the wallet initially gets one client attestation and uses the cnf key over a longer period to bind a sequence of refresh tokens to it. -> similar to option 4?\n\nB: the Wallet initially gets one client attestation and the AS binds the first refresh token to the cnf key. When it uses the refresh token, it also provides a new client attestation with a new cnf key and the AS binds a new refresh token to this new key. -> similar to option 1?",
          "createdAt": "2023-10-31T18:33:58Z",
          "updatedAt": "2023-10-31T18:33:58Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> Do we? I had assumed the AS identifies the client by the sub value. I don't see a need to identify a client instance.\r\n\r\nWell the current language doesn't actually guarantee that the AS can track the client instance (which is a good thing IMO), as the instance can in many common cases, rotate the keys it uses in between fetching tokens. But in the event a client instance is exchanging a refresh token for a fresh access token and potentially another refresh token, the client instance must authenticate using a client attestation JWT with the same key in the cnf claim that was in the original attestation used when the refresh token was obtained. This ensures one client instance can't use another client instances refresh token. So in this case the AS can track that the client instance who obtained the refresh token is the client instance now requesting to exchange it for a new access token, which is desired from a security perspective.\r\n\r\n> This just makes explicit the tracking of client instances that already existed through the requirement for the \"cnf\" key to stay the same over attestations.\r\n\r\nAs I said above in response to Torsten's point, using the key instead of an explicit claim means a single client instance could actually use multiple keys over time meaning the AS can't track the client instance across all of those interactions. The concern if we make an explicit claim in the client attestation JWT for identifying the client instance, is that implementations won't rotate this identifier over time thus meaning the instance would be tracked.\r\n\r\n> the forth option is to have long living client attestations, which in my opinion is no problem\r\n\r\nIronically if your goal is to reduce the ability of the AS to track the client instance over time, this option will in fact enable that as the attestation itself becomes the tracking vector.\r\n\r\n> Isn't the AS identifying the client also by the refresh token itself?\r\n\r\nAgreed, the additional requirement of requiring the same client authentication method with the same key just means that obtaining the refresh token alone is not enough for another instance to be able to exercise the refresh token, it doesn't materially change the ability for the AS to track the client instance because as you highlight the refresh token itself creates the same possibility for correlation.",
          "createdAt": "2023-10-31T19:22:17Z",
          "updatedAt": "2023-10-31T19:22:17Z"
        },
        {
          "author": "cobward",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> A: the wallet initially gets one client attestation and uses the cnf key over a longer period to bind a sequence of refresh tokens to it. -> similar to option 4?\r\n\r\nI think this is basically my option 3.\r\n\r\n> Well the current language doesn't actually guarantee that the AS can track the client instance (which is a good thing IMO), as the instance can in many common cases, rotate the keys it uses in between fetching tokens.\r\n\r\n> a single client instance could actually use multiple keys over time meaning the AS can't track the client instance across all of those interactions\r\n\r\nUnless there is a mechanism to issue a refresh token that I am not aware of, it is not possible to rotate keys according to the current language. The spec states:\r\n\r\n> Authorization servers issuing a refresh token in response to a token request using the \"urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation\" client authentication method **MUST bind the refresh token to the client instance**, and NOT just the client as specified in section 6 {{RFC6749}}. To prove this binding, **the client instance MUST authenticate itself to the authorization server when refreshing an access token** using the \"urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation\" authentication method. The client **MUST also use the same key** that was present in the \"cnf\" claim of the client attestation that was used for client authentication when the refresh token was issued.\r\n\r\nThis is what I mean by \"_This just makes explicit the tracking of client instances that already existed through the requirement for the \"cnf\" key to stay the same over attestations._\"",
          "createdAt": "2023-11-06T14:52:08Z",
          "updatedAt": "2023-11-06T14:53:14Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think rotation of the key within the lifetime of a refresh token is something that needs to be accounted for. So my preference would be for option 3 (which is how it functionally is now but could be made more explicit in the text).  Adding an explicit claim in the client attestation JWT which identifies the client instance, i.e. option 2, would be okay too. But I think it'd get complicated/confusing to describe it in the spec. \r\n",
          "createdAt": "2023-11-09T21:34:11Z",
          "updatedAt": "2023-11-09T21:34:11Z"
        },
        {
          "author": "cobward",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't think rotation of the key within the lifetime of a refresh token is something that needs to be accounted for.\r\n\r\nBy saying you can't rotate the key within the lifetime of a refresh token, I think this means that you cannot rotate the key without starting from scratch at the authorization endpoint. I just wanted to make sure that is what you meant?",
          "createdAt": "2023-11-10T16:24:23Z",
          "updatedAt": "2023-11-10T16:24:23Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > I don't think rotation of the key within the lifetime of a refresh token is something that needs to be accounted for.\r\n> \r\n> By saying you can't rotate the key within the lifetime of a refresh token, I think this means that you cannot rotate the key without starting from scratch at the authorization endpoint. I just wanted to make sure that is what you meant?\r\n\r\nBasically yeah, I think so. Rotating the the key would mean you'd have to go back to the authorization endpoint. That seems acceptable/reasonable. Maybe it's too narrow of a view but it seems like if there's a reason to rotate that key then reauthorizing is probably needed or at least acceptable anyway. ",
          "createdAt": "2023-11-10T17:15:19Z",
          "updatedAt": "2023-11-10T17:15:19Z"
        },
        {
          "author": "cobward",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> if there's a reason to rotate that key then reauthorizing is probably needed\r\n\r\nI'm not sure that's true. IMO authorization is more of a user-identification concern, the rotation of the key is a client-security concern.\r\n\r\nSaying that, I think I agree that it's probably acceptable to say key-rotation isn't possible without returning to the authorization endpoint.\r\n\r\nGiven this I would suggest we add a sub-section to the Implementation Considerations section, something along the lines of this:\r\n\r\n> ## Rotation of confirmation key\r\n> This specification does not provide a mechanism to rotate the confirmation key identified in the Client Attestation JWT. If the client instance needs to use a new confirmation key for any reason, then it MUST begin the OAuth 2.0 flow from scratch.",
          "createdAt": "2023-11-13T10:45:01Z",
          "updatedAt": "2023-11-13T10:45:01Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "I_kwDOJaEkaM51372F",
      "title": "Extend the draft to define a new grant type",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/58",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Can this draft be extended to define a new grant type `urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation` where a sender-constrained JWT can be used to request an Access Token? for example, i think it would be useful in use-cases like catena-x https://github.com/eclipse-tractusx/identity-trust/issues/34 (cc @c2bo)\r\nInspiration for the suggestion is https://www.rfc-editor.org/rfc/rfc7523, which defined `urn:ietf:params:oauth:grant-type:jwt-bearer` both for client authentication and a new grant type.",
      "createdAt": "2023-11-05T02:21:14Z",
      "updatedAt": "2023-11-06T07:59:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "@Sakurann can you please elaborate on the usecase here, the attached issue doesn't provide any context.",
          "createdAt": "2023-11-06T07:59:48Z",
          "updatedAt": "2023-11-06T07:59:48Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOJaEkaM52OUZK",
      "title": "Using a server provided nonce to limit the lifetime of a Client Attestation PoP JWT",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/59",
      "state": "OPEN",
      "author": "pmhsfelix",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Following up on the conversations some of us had after IIW (see https://github.com/openid/OpenID4VCI/issues/71#issuecomment-1719631991), this issue proposes the addition of a server provided nonce mechanism to limit the lifetime of a Client Attestation PoP JWT, similar to the [DPoP nonce mechanism](https://www.rfc-editor.org/rfc/rfc9449.html#name-authorization-server-provid).\r\n\r\nThis relates to https://github.com/openid/OpenID4VCI/issues/71, however the required changes need to be addressed on the attestation spec and not on the VCI spec.\r\n\r\nI'm currently working on a PR to add this. ",
      "createdAt": "2023-11-08T12:14:18Z",
      "updatedAt": "2024-08-22T13:48:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Please see #67 for a proposal to use DPoP which would provide an alternative solution to this proposal.",
          "createdAt": "2024-01-15T21:28:51Z",
          "updatedAt": "2024-01-15T21:28:51Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Thoughts from today's editor call:\r\n\r\n## Proposal 1: DPoP style\r\nAdvantages:\r\n- established mechanism\r\n- high flexiblity for AS to manages nonce lifetime\r\n\r\nDisadvantage:\r\n- higher chance of failure and repeated DPoP proof signatures, costly with remote or hardware key\r\n  - no nonce expiration communicated to client\r\n- is there a defined way for a client to request a valid nonce from AS? How can he be sure to end up in the use_dpop_nonce and not in other error conditions? -> clarify with @danielfett @bc-pi \r\n\r\n## Proposal 2: new/extended mechanism\r\nextend DPoP with:\r\n- define a HTTP Header to explicitly request a new nonce\r\n- add expiration to the nonce delivery (AS may still send a new nonce, even if the time has not passed yet)\r\n\r\nAdvantages:\r\n- ability to request fresh nonces when needed\r\n  - Wallet doesn't need to store old/fake DPoP Proofs to fetch a new one\r\n  - avoid double DPoP proof, costly with remote or hardware key\r\n- nonces could be delivered as header within other messages\r\n\r\nDisadvantage:\r\n- unauthenticated endpoint to request nonce that may generate state on the AS/may be leveraged for DDoS\r\n- unclear how to extend DPoP / more work\r\n\r\n----\r\nDo we want the Wallet to cache the nonces at all? Doesn't this open tracking by the issuer? This makes it even more obvious that we need explicit nonce requests!\r\n",
          "createdAt": "2024-08-22T09:01:10Z",
          "updatedAt": "2024-08-22T09:01:32Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@paulbastian How do you envision the client to determine whether a nonce is needed? I'm asking since if the client would know this in advance, it would allow a design where the client could obtain the nonce from a dedicated endpoint before calculating the PoP and sending the token request. ",
          "createdAt": "2024-08-22T09:52:29Z",
          "updatedAt": "2024-08-22T09:52:29Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "One idea was to add certain datapoints to the (previous) response - things like expiration time that could be a used as an indicator for the client that a nonce is not valid anymore (but not a guarantee that it will be accepted by the server).\r\nI guess we could also signal the general nonce policies for endpoints somewhere in the metadata?",
          "createdAt": "2024-08-22T11:12:36Z",
          "updatedAt": "2024-08-22T11:12:36Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My question is related to a client that just received an authorization code and now wants to authentication using a client attestation. How is the client supposed to figure our whether a nonce is needed?\r\n\r\nI see the following options: \r\n1. on demand, because the token request with a PoP w/o nonce is rejected\r\n2. some AS metadata tell the client a nonce is needed\r\n3. client and AS belong to a certain domain (e.g. the client is a wallet and the AS represents a credential issuer in the EUDI Wallet space) and nonces are always required in this domain. \r\n ",
          "createdAt": "2024-08-22T12:35:15Z",
          "updatedAt": "2024-08-22T12:35:15Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "I think there are 2 kinds of information we should consider:\r\n1: Something about the general policy of requiring a nonce (with the 3 options you mentioned)\r\n2: Some form of indicators if a client can re-use an existing nonce or should directly request a new nonce (and avoid an unnecessary signature)",
          "createdAt": "2024-08-22T13:48:51Z",
          "updatedAt": "2024-08-22T13:48:51Z"
        }
      ]
    },
    {
      "number": 60,
      "id": "I_kwDOJaEkaM52eD7T",
      "title": "IETF 118: Refer / Explain relation to RATS and the RATS terminology",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/60",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-10T13:05:09Z",
      "updatedAt": "2024-05-20T09:55:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Attester = Client\r\nRelying Party = AS,RS\r\nVerifier = Client Backend (possibly Attestation Service)\r\nEndorser, Reference Value Provider = out of scope\r\n\r\nClaim = Claim\r\nEndorsement, Evidenace, Policies nad Reference Values = out of scope\r\nAttestation Result = Client Attestation JWT\r\n",
          "createdAt": "2024-05-20T09:55:47Z",
          "updatedAt": "2024-05-20T09:55:47Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOJaEkaM52eFe7",
      "title": "IETF 118 : Should this mechanism be used in parallel with Client Authentication /with Dynamic Client Registration",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/61",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In particiuar:\r\n- this mechanism should work for other endpoints\r\n- client attestation should not \"take up\" the client authentication slot, but be separate\r\n- How does the AS get the key of the client backend/attestation service? What's the trust mechanism?\r\n\r\nRelated to #62 ",
      "createdAt": "2023-11-10T13:09:37Z",
      "updatedAt": "2024-08-26T14:30:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The way this mechanism is designed allows it to be used with other endpoints then the token endpoint (like any other client authentication method). \r\n\r\nUsing client authentication as a way to also do client attestation is not just convenient it also means any client with attestation capabilities can be treated as a confidential client. \r\n\r\nI would like to understand how people proposing to split client authentication and attestation envision this to work. Would that mean deployments would use public clients + attestations? What would be the benefit?\r\n\r\nHow would dynamic client registration work with attestation? \r\n\r\nI personally have doubts about the utility of dynamic client registration. It requires the client to dynamically keep track of AS specific credentials including its expiration. Attestation based authentication on the other hand allows a client to just use a single attestation with any compatible AS. ",
          "createdAt": "2023-11-13T11:04:56Z",
          "updatedAt": "2023-11-13T11:04:56Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "\"Should this mechanism be used in parallel with Client Authentication /with Dynamic Client Registration\" feels like two different questions that we may want to discuss separately (albeit if the answer to both is \"yes\" the solution may be the same for both cases).\r\n\r\n\r\n@tlodderstedt \r\n\r\n> I personally have doubts about the utility of dynamic client registration. It requires the client to dynamically keep track of AS specific credentials including its expiration. \r\n\r\nDCR requires neither of those things when used with private_key_jwt or MTLS client authentication. (I'd agree that it does probably require the client to keep track of a client_id per AS.)\r\n\r\nDCR with attestations is fairly commonly used by mobile apps, to establish per-install client credentials. It's certainly not the only solution, but many people find it a useful solution today. The advantage of using attestation at DCR is you only do the attestation process once at registration time, which in the lower risks  cases makes things easier to implement on the AS side and simpler for client developers. (For clarify I also agree that there are use cases where presenting attestations every time a client authenticates could make sense.)\r\n",
          "createdAt": "2023-11-15T08:52:53Z",
          "updatedAt": "2023-11-15T08:52:53Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "> Using client authentication as a way to also do client attestation is not just convenient it also means any client with attestation capabilities can be treated as a confidential client.\r\n\r\nI am not convinced this is completely true; it's actually creating something that sits somewhere between a confidential client and a public client. See for example the special handling needing for refresh tokens as per https://vcstuff.github.io/draft-ietf-oauth-attestation-based-client-auth/draft-ietf-oauth-attestation-based-client-auth.html#section-5.2 but I think it has further implications for AS implementations, for example existing authorised consents would need to be tracked on a per \"client instance\" basis instead of a per client basis.",
          "createdAt": "2023-11-15T09:03:20Z",
          "updatedAt": "2023-11-15T09:03:20Z"
        },
        {
          "author": "ju-cu",
          "authorAssociation": "NONE",
          "body": "> I would like to understand how people proposing to split client authentication and attestation envision this to work. Would that mean deployments would use public clients + attestations? What would be the benefit?\r\n\r\nAttestation is just a statement by some entity (\"Attester\") about certain properties of a client (including its public key, in this case). I don't think attestation implies neither a public nor confidential client. Attestation could be used with both types I believe, because it serves a different purpose than authentication. I see attestation as a method to for the authorization server to get greater confidence in the credentials of a client. I picture, like @jogu, a setup where you can use client attestation (e.g. in an HTTP header or additional query parameter?!) together with existing (or future) client authentication methods such as private_key_jwt or mutual TLS.\r\n+1 for separating client attestation and client authentication via PoP mechanisms\r\n+1 for supporting client attestation with DCR.",
          "createdAt": "2023-11-15T09:56:23Z",
          "updatedAt": "2023-11-15T09:56:23Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Let me lay out how I understand the ideas of combining DCR with Client Attestation:\r\n- before a  Wallet/Client interacts with an Issuer/AS, he once sends a request to DCR Endpoint containing:\r\n  - client attestation as authorization\r\n  - some additional data according to RFC 7591\r\n  - some mechanism for client authentication, e.g. client credentials or private_key_jwt\r\n- Issuer/AS checks the client attestation and registers the Wallet/Client in his Client database under a newly generated client_id,e.g. (client_id, private_key_jwt) and sends response to DCR request\r\n- Wallet/Client Token Request containing:\r\n  - client authentication, e.g. private_key_jwt\r\n  - DPoP key\r\n- Issuer/AS responds with Token Response containing the DPoP-bound access token\r\n\r\nMy observations to this:\r\n- the biggest difference to the status quo of this specification is that in DCR the AS chooses the client_id, while in our model the Wallet Provider has a client_id that is the same for all client instances and chosen by the Wallet Provider\r\n- as I understand DCR is usually only called once during registration, in the use cases we have in mind it is very typical to send fresh client attestations to the Issuer/AS\r\n- as of now, we cannot use client attestations with DCR, because the cleint attestation already contains client_id as the `sub` value\r\n- in my opinion it seems a little strange and inefficient that every AS manages client_ids for every wallet instance and all wallets manage separate client_ids for every Issuer\r\n- We want to have attested public keys in the client attestation that an Issuer may use to bind VCs or other credentials to, that doesn't work very well with DCR\r\n\r\nThe initial motivation of this draft is to provide identification and authentication of the client instance towards the AS. I'm new to DCR so I might miss a few things here, right now it seems like an extra steps with no benefit to our usecases.\r\n",
          "createdAt": "2023-11-15T13:30:12Z",
          "updatedAt": "2023-11-15T13:30:12Z"
        },
        {
          "author": "vdzhuvinov",
          "authorAssociation": "NONE",
          "body": "Maybe I don't know the entire story behind this ticket, but switching to a DCR seems kind of heavy and inefficient to me, as seen from an AS, but also generally, when I try to think how this is going to mesh in a greater system / deployment / federation.\r\n\r\nI liked the original concept that relied on the attestation. It is efficient and easier to scale.",
          "createdAt": "2023-11-15T13:47:54Z",
          "updatedAt": "2023-11-15T13:47:54Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > Using client authentication as a way to also do client attestation is not just convenient it also means any client with attestation capabilities can be treated as a confidential client.\r\n> \r\n> I am not convinced this is completely true; it's actually creating something that sits somewhere between a confidential client and a public client. See for example the special handling needing for refresh tokens as per https://vcstuff.github.io/draft-ietf-oauth-attestation-based-client-auth/draft-ietf-oauth-attestation-based-client-auth.html#section-5.2 but I think it has further implications for AS implementations, for example existing authorised consents would need to be tracked on a per \"client instance\" basis instead of a per client basis.\r\n\r\nIs this handling any different from private_key_jwt?",
          "createdAt": "2023-11-15T15:05:52Z",
          "updatedAt": "2023-11-15T15:05:52Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> \"Should this mechanism be used in parallel with Client Authentication /with Dynamic Client Registration\" feels like two different questions that we may want to discuss separately (albeit if the answer to both is \"yes\" the solution may be the same for both cases).\r\n> \r\n> @tlodderstedt\r\n> \r\n> > I personally have doubts about the utility of dynamic client registration. It requires the client to dynamically keep track of AS specific credentials including its expiration.\r\n> \r\n> DCR requires neither of those things when used with private_key_jwt or MTLS client authentication. (I'd agree that it does probably require the client to keep track of a client_id per AS.)\r\n> \r\n> DCR with attestations is fairly commonly used by mobile apps, to establish per-install client credentials. It's certainly not the only solution, but many people find it a useful solution today. The advantage of using attestation at DCR is you only do the attestation process once at registration time, which in the lower risks cases makes things easier to implement on the AS side and simpler for client developers. (For clarify I also agree that there are use cases where presenting attestations every time a client authenticates could make sense.)\r\n\r\nCan you please describe how that works? As far as I understand RFC 7591, the AS creates a client id with every registration. There is no special treatment of neither private_key_jwt nor mTLS. \r\n\r\nI also noticed there is no proof of possession for the key material and there is no key binding for the software statement. That's all built into the client attestation mechanism. ",
          "createdAt": "2023-11-15T15:10:59Z",
          "updatedAt": "2023-11-15T15:10:59Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "> Is this handling any different from private_key_jwt?\r\n\r\nYes. The entire concept that one client_id can now have multiple instances and that the AS needs to treat the different instances of that client_id as distinct entities is a brand new concept created in this draft.",
          "createdAt": "2023-11-15T15:13:41Z",
          "updatedAt": "2023-11-15T15:13:41Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You are right. Since different client instances may use different attestations, the refresh token is no longer just bound to the client id. \r\n\r\nI think a client id previously already could have multiple instances (think of open banking apps), however the AS did not need to know. Why? Because authentication was done through the respective backend so instance management was application internal. Now, the instances themselves can authenticate, which raises privacy as the backend cannot observer this interaction. The way I see it this draft allows implementation of confidential clients with native apps in a more privacy friendly manner. The attestation part helps the AS to determine whether the instance is really an instance of the respective client id. I guess that's why I believe both concepts belong together. ",
          "createdAt": "2023-11-16T11:19:05Z",
          "updatedAt": "2023-11-16T11:19:05Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "> I think a client id previously already could have multiple instances (think of open banking apps), however the AS did not need to know\r\n\r\nI'm not sure that's really counts multiple instances. Or at least it's not just that authentication was in the backend, it's also that the refresh tokens never left the backend so there was no risk of one instance using a difference instances refresh token.\r\n\r\nI agree with the privacy benefits, but it is a significant change to the security posture. It is clear that the new thing defined in this draft is neither a traditional confidential client nor a traditional public client. I'm struggling to figure out which it is closest too. I think in a lot of ways it feels closest to a public client that's using dpop (particularly when you think of how refresh tokens are bound to the dpop key in that case), but essentially with the addition of attestation for the dpop key.\r\n",
          "createdAt": "2023-11-16T11:54:24Z",
          "updatedAt": "2023-11-16T11:54:24Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> feels closest to a public client that's using dpop (particularly when you think of how refresh tokens are bound to the dpop key in that case), but essentially with the addition of attestation for the dpop key.\r\n\r\nI'd concur with that. And there's some discussion over [here and above](https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/64#issuecomment-1815362871) about maybe using the DPoP proof as the PoP mechanism rather than the Client Attestation PoP JWT. Doing that change in conjunction with changing the Client Attestation JWT to be sent via some other parameter (`client_key_attestation` or something) and decoupled from client authentication is appealing. It'd keep public clients public. But give binding of RT to the DPoP key (the key that's been attested to) without the [special handling that's there now](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-attestation-based-client-auth#name-refresh-token-binding) but is a really important security property. And could provide this simple attestation (mostly about a key) independent of client authentication. And also stay orthogonal to DCR. \r\n",
          "createdAt": "2023-11-16T22:16:42Z",
          "updatedAt": "2023-11-16T22:16:42Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> Yes. The entire concept that one client_id can now have multiple instances and that the AS needs to treat the different instances of that client_id as distinct entities is a brand new concept created in this draft.\r\n\r\nIt might not be a broadly enough socialised concept yet but I dont think this draft has invented the notion of a client instance. [OAuth 2.1](https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-09.html), [RFC8705](https://www.rfc-editor.org/rfc/rfc8705.html) and [the latest OAuth browser BCP](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps-05) all speak informally about client instances.\r\n\r\nI also dont think the draft is aiming for an AS to treat different instances of a particular client differently beyond that if they fail to authenticate in a way that is required for that client, then of course their request could be rejected. The exception is perhaps the RT language that @bc-pi raised which I agree is very important to prevent one client instance from being able to use another client instances RT.\r\n\r\n> Doing that change in conjunction with changing the Client Attestation JWT to be sent via some other parameter (client_key_attestation or something) and decoupled from client authentication is appealing. It'd keep public clients public. But give binding of RT to the DPoP key (the key that's been attested to) without the [special handling that's there now](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-attestation-based-client-auth#name-refresh-token-binding) but is a really important security property.\r\n\r\nI like this solution personally, it is much cleaner to explain and feels like it gets the best of both worlds including re-using DPoP more meaning this specification has to invent less.",
          "createdAt": "2023-11-17T03:03:54Z",
          "updatedAt": "2023-11-17T03:06:10Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "> It might not be a broadly enough socialised concept yet but I dont think this draft has invented the notion of a client instance. [OAuth 2.1](https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-09.html), [RFC8705](https://www.rfc-editor.org/rfc/rfc8705.html) and [the latest OAuth browser BCP](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps-05) all speak informally about client instances.\r\n\r\nThis is true, albeit they only speak about instances of public clients. (My original sentence wasn't great; it was the \"that the AS needs to treat the different instances of that same confidential client_id as distinct entities is a brand new concept\" part that I really wanted to emphasise. And we agree that it's this refresh token related behaviour that's the important and necessary difference.)\r\n\r\nI strongly agree this latest direction as per your / Brian's comments.",
          "createdAt": "2023-11-17T09:53:14Z",
          "updatedAt": "2023-11-17T09:53:14Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "client instances: the draft allows to authenticate the caller as being an instance of a certain client (id). The client id should then be used by the AS for other logic (such as storing user consent and so on). There is no need to identify the client instance, I would go as far as to state the instance should not be identifiable simply because a client instance identifier would be kind of a user identifier (in case of a native app). I know the key is a co-relation handle, that's why deployments should use short lived or even emphemeral client attestation to foster privacy.\r\n\r\nattestation vs authentication: In traditional OAuth deployments requiring client authentication (e.g. open banking or commercial/paid schemes), a native app would send requests through its backend, which acts as a confidential client towards the AS. That's the way to ensure the AS talks to a legit client. In emerging use cases (esp. wallets), the way through the backend is seen as not as privacy preserving as it should be. Using the apps backend instead to issue an assertion to its app(s) and use that assertion to authenticate to the AS is the alternative being proposed. The backend uses platform attestation to ensure the caller is a instance of the backend's app. That's the origin of the name attestation based client authentication. Binding the attestation to a key ensures it cannot be replayed by other parties. With such an attestation, the app can directly call the AS (while establishing confidence the AS talks to the legit client).\r\n\r\nConclusion: the attestation is used to establish confidence the AS is talking to an instance of a certain client. This is inline with the purpose of client authentication. That's why the idea to use the existing client authentication mechanics here makes sense to me. \r\n\r\nre public client: I would like to understand how the suggested differentiation between attestation and public client shall work. Can someone please share an example flow with request examples? I would especially like to know what client_id such a public client would use. I'm asking since in the proposed flow, the client_id is determined by the trusted 3rd party issuing the client attestation assertion. ",
          "createdAt": "2023-11-22T11:17:42Z",
          "updatedAt": "2023-11-22T11:20:09Z"
        },
        {
          "author": "embesozzi",
          "authorAssociation": "NONE",
          "body": "Just a minor comment: I'm trying to use this standard in the context of the proposed [OAuth 2.0 for First-Party Applications](https://datatracker.ietf.org/doc/draft-parecki-oauth-first-party-apps/) standard to prevent client impersonation (I'm on the implementation side). To provide more context, OAuth 2.0 for First-Party Applications is an API-based \"authentication\" approach, serving as an alternative to the traditional method, which required redirecting or opening a browser. \r\nIn the context of mobile apps that use public clients, the Authorization Server MUST verify the \"first-partyness\" of the client. Therefore, I'm implementing client attestation at the token endpoint.\r\n\r\nAfter reviewing the standard, it's not clear to me how the AS can trust the attestation issuer and verify the signature of a client attestation.",
          "createdAt": "2024-08-20T19:55:10Z",
          "updatedAt": "2024-08-20T19:55:10Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "@embesozzi you're not missing anything, that currently isn't stated as far as I know. Like base OAuth as defined in RFC6749 doesn't say much about how you get a client_secret or client_id, it's assumed there's some kind of out of band configuration of what attestation issuers an authorization server trusts and where it gets the keys for those issuers from.\r\n\r\n(See also https://github.com/openid/oid4vc-haip-sd-jwt-vc/issues/101 which has more discussion.)",
          "createdAt": "2024-08-25T17:31:33Z",
          "updatedAt": "2024-08-25T17:33:07Z"
        },
        {
          "author": "embesozzi",
          "authorAssociation": "NONE",
          "body": "@jogu, I appreciate the feedback and I'll review the discussion.\r\nI've found others proposed standards to address this issue, but as usual, I'll try follow the [KISS principle](https://simple.wikipedia.org/wiki/KISS_principle).",
          "createdAt": "2024-08-26T14:30:12Z",
          "updatedAt": "2024-08-26T14:30:12Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "I_kwDOJaEkaM52f0LU",
      "title": "IETF 118: Overlap/Synergies with \"Attestation in Dynamic Client Registration Draft\"",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/62",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "What are similarities with the new draft of \"Attestation in Dynamic Client Registration Draft\"?\r\nEvaluate the possiblities to merge this.",
      "createdAt": "2023-11-10T17:27:28Z",
      "updatedAt": "2023-11-17T02:39:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My intuition is that there are actually very few synergies when you get into the specifics and details (which are what is needed for interop) and merging the drafts will be counter productive at best. ",
          "createdAt": "2023-11-16T22:01:02Z",
          "updatedAt": "2023-11-16T22:01:02Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I share this view ^ efforts to use attestations in DCR are quite different to proposing a client authentication mechanism that uses attestations and I'd prefer we keep them distinct.",
          "createdAt": "2023-11-17T02:39:33Z",
          "updatedAt": "2023-11-17T02:39:33Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "I_kwDOJaEkaM53y6Te",
      "title": "Include guidance to use token_endoint_auth_methods_support",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/66",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-24T14:41:45Z",
      "updatedAt": "2023-11-24T14:41:45Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 68,
      "id": "I_kwDOJaEkaM58fVe3",
      "title": "Introducing a general purpose assertion-based client authentication with holder-of-key JWT",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/68",
      "state": "OPEN",
      "author": "ju-cu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "What about introducing a general purpose client authentication using a holder-of-key JWT assertion instead of Client Attestation JWT?\r\n\r\nThe draft introduces the Client Attestation JWT that is bound to the public key of a Client Instance Key. What about having a spec that replaces the Client Attestation JWT with an assertion that is a holder-of-key JWT, meaning a JWT bound to a key that the client proofs to be able to control (e.g. using DPoP as suggested in #67 ). The draft would not make any assumptions on whether the holder-of-key JWT is an attestation or not; it technically would support any JWT with a `cnf` claim and require a proof-of-possession for client authentication.\r\nAttestation-based client authentication could profile such a spec if necessary. In the ecosystem, there would be RFC7521, upon it RFC7523 for the bearer JWT assertion and next to it some spec for holder-of-key JWT assertion, and upon that the attestation-based client authentication. What do you think? \r\n\r\nThis idea was first proposed by @pmhsfelix in #64 (https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/64#issuecomment-1838969799). ",
      "createdAt": "2024-01-18T15:58:38Z",
      "updatedAt": "2024-02-05T08:24:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @ju-cu thanks for surfacing this into a seperate issue. I'm wondering how much of this is a terminology issue as the Client attestation JWT is really just a JWT with minimal normative requirements to ensure it is appropriate as an attestation or in your terminology a holder-of-key JWT. Can you explain what other usecases you would like to use this holder-of-key JWT outside of this specs usage? As it would appear that is the key to understanding whether this additional layer of abstraction would be useful.",
          "createdAt": "2024-01-18T20:34:28Z",
          "updatedAt": "2024-01-18T20:35:09Z"
        },
        {
          "author": "ju-cu",
          "authorAssociation": "NONE",
          "body": "I agree, it is mainly a terminology issue and I'm not sure there is a need for an additional layer or updating the current one is actually good enough. As you say, the draft includes only minimal normative requirements for the Client Attestation JWT. But this fact made me wonder how the proposed authentication method is actually related to attestation and what it distinguishes it from an authentication method for any holder-of-key JWT. So, I started to think that there could be likewise an authentication method that uses a holder-of-key JWT and any attestation specifics (if there are any) would be on top of that.",
          "createdAt": "2024-01-19T08:05:54Z",
          "updatedAt": "2024-01-19T08:05:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Understood, perhaps the question more lies with what usecases do you see outside of client authentication where this mechanism would be useful? Keeping in mind this draft is inherently bound to applications of the OAuth 2.0 protocol.",
          "createdAt": "2024-01-22T00:11:49Z",
          "updatedAt": "2024-01-22T00:11:49Z"
        },
        {
          "author": "pmhsfelix",
          "authorAssociation": "NONE",
          "body": "Currently, we have:\r\n- [RFC 7521 - Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants](https://www.rfc-editor.org/rfc/rfc7521.html) as a very general and format independent framework for both client authentication and authorization grants.\r\n    - This framework defines \"two general types of assertions\": \"Bearer Assertions\" and \"Holder-of-Key Assertions\" (https://www.rfc-editor.org/rfc/rfc7521.html#section-3).\r\n\r\n- [RFC 7523 - JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants](https://www.rfc-editor.org/rfc/rfc7523.html) profiles RFC 7521 for JWT *bearer* tokens.\r\n- AFAIK, there isn't any spec profiling RFC 7521 for JWT *holder-of-key* assertions.\r\n  \r\nMy idea, which I believe is similar to @ju-cu, would be to create such a *holder-of-key* profile spec, using DPoP-based proof-of-possession. This spec would be useful in both client authentication and authorization grant scenarios that require additional security (i.e. bearer is not adequate).\r\n*Attestation*-based client authentication would be based in this last profile spec, by defining a set of attestation-related claims to be contained in the JWT\r\n\r\nThis seems more modular and useful.\r\n\r\n```\r\nRFC 7521 - The framework\r\n|\r\n+---> RFC 7523 - profiles the framework for Bearer JWT\r\n|\r\n+---> NewSpec1 - profiles the framework for holder-of-key JWT, based on DPoP, independent of attestation\r\n          |\r\n          +---> NewSpec2 - Tiny spec profiling NewSpec1 for *attestation*-based client authentication, \r\n                    just by defining extra JWT claims.\r\n```\r\nThe main advantage would be the broader applicability of NewSpec1 as a version of RFC 7523 with holder-of-key\r\n       ",
          "createdAt": "2024-02-01T13:36:44Z",
          "updatedAt": "2024-02-01T13:36:44Z"
        },
        {
          "author": "ju-cu",
          "authorAssociation": "NONE",
          "body": "I do not have any (additional) use cases for a general purpose client authentication using a holder-of-key JWT, other than the general one that @pmhsfelix described: a JWT-assertion-based authentication for scenarios where bearer is not enough. \r\n\r\nThis draft does not specify any attestation specific claims for the client attestation JWT (it does not even define attestation and how it differs from an assertion). The only thing, that defines the client attestation JWT is the fact that it is bound to a public key and that the draft expects a client backend to generate it, which imo is not enough for an attestation. For example, the client attestation JWT does not provide any information about how the client protects the key as pointed out in this comment: https://github.com/openid/OpenID4VCI/issues/150#issuecomment-1918865432\r\n\r\nIn best cases, this draft provides some confidence that the request comes from a genuine client (or what the \"client backend\" thinks is genuine). I believe that you do not need a client backend to get this confidence. Technically, I don't think, it makes a difference if the client attestation JWT was issued by a client backend or any other third party because it all boils down to how the client authenticates to the client backend (step 2) which is out of scope of the draft anyways. \r\nI believe, to make this draft applicable, you will need a profile that defines the  attestation-specific claims in the client attestation JWT as well as the client authentication to who-ever-issues-the-key-bound-jwt. Imo, the current draft is more suited as a general-purpose holder-of-key-based client authentication method.\r\n\r\nMaybe you can help me to understand the difference between an attestation and a key-bound JWT?",
          "createdAt": "2024-02-05T08:24:09Z",
          "updatedAt": "2024-02-05T08:24:09Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDOJaEkaM59PQkf",
      "title": "Usecase: authenticating the key used for DPoP bound access tokens back to the client",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/69",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the event this client authentication method is used with DPoP bound access tokens. An AS may want the assurance that the key they bind an issued access token, is in fact authenticated to the client. Without this assurance a MITM attack is possible where an intermediary could substitute the DPoP proof in the token request for a key they control, thus then being able to use the returned access token.\r\n\r\nBelow is a simple diagram depicting this attack\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant C as Client\r\n    participant A as Attacker\r\n    participant AS as Authorisation Server\r\n    participant RS as Resource Server\r\n\r\n    C->>C: Prepare Token Request (including DPoP proof)\r\n    C->>A: Send token request (intercepted by attacker)\r\n    A->>A: Generate new DPoP key and DPoP proof\r\n    A->>A: Generate new token request using the clients original request but with the new DPoP proof substituted\r\n    A->>AS: Send token request\r\n    AS->>AS: Validate and generate access token bound to attackers DPoP key\r\n    AS->>A: Send token response (with access token bound to attackers DPoP key)\r\n    A->>RS: Protected resource request using obtained access token\r\n```\r\n\r\nDPoP as stated in the RFC [is not designed as a client authentication method, but is instead designed to work with client authentication](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop-16#section-3). The client authentication method as defined by this draft could be such a suitable method that would provide a way to prevent the above attack from occurring.\r\n\r\nRelated to this issue, is PR #67, which explores using the DPoP proof syntax instead of defining a new JWT PoP syntax as is the case with the current draft. Consequently if #67 were adopted, the usage of this client authentication method with DPoP bound access tokens becomes much simpler and the above attack scenario would be prevented implicitly through the design. However, there is concern that #67 risks coupling together the DPoP key and client attestation key where there maybe usecases where these keys should be seperate (cc @tlodderstedt). Personally I'm not convinced that the DPoP key and client attestation key need to be different and I believe the complexity it creates is not worth it. However, if #67 is not adopted, then a different solution to solving the above problem needs to be devised which may require putting the DPoP key in the client attestation PoP so it can be authenticated back to the client. \r\n",
      "createdAt": "2024-01-25T20:54:18Z",
      "updatedAt": "2024-01-31T07:00:58Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 70,
      "id": "I_kwDOJaEkaM6DW1c7",
      "title": "Register AS and client metadata for algorithm negotiation of attestations and pops",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/70",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We need to consider registering appropriate metadata for an AS and client to respectively indicate what signing algorithms they support for \r\n\r\n- A client attestation\r\n- A client attestation pop",
      "createdAt": "2024-03-23T09:56:57Z",
      "updatedAt": "2024-03-23T09:56:57Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 71,
      "id": "I_kwDOJaEkaM6Dq8a3",
      "title": "Propose to change the draft name",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/71",
      "state": "OPEN",
      "author": "tlodderstedt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "I think the \"attestation\" term in the draft name causes confusing and a wrong perception what this draft is about. \r\n\r\nIn my opinion, this draft evolves the concept RFC 7523 to allow use of JWTs bound to a key for client authentication. \r\n\r\nConsequently,  I suggest to rename the draft to \"Key-bound JWT Client Authentication\".",
      "createdAt": "2024-03-26T18:55:21Z",
      "updatedAt": "2024-09-11T06:58:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "adeinega",
          "authorAssociation": "NONE",
          "body": "@tlodderstedt, along with this renaming, the spec could also simplify a few other things. Say it can remove all references / interaction with Client Backend, so an OAuth client could simply reuse [OAuth 2.0 Dynamic Client Registration Protocol (RFC 7591)](https://datatracker.ietf.org/doc/html/rfc7591).",
          "createdAt": "2024-07-15T17:42:25Z",
          "updatedAt": "2024-07-15T17:42:25Z"
        },
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Would be good to know what \"a wrong perception what this draft is about\" was about, but I suspect we clarified those confusions in the oauth wg.\r\n\r\nterms wallet attestation/key attestation have already been widely used in the community that is the target audience for this draft. are we sure renaming this draft to client authentication would not cause more confusion?",
          "createdAt": "2024-07-26T20:47:47Z",
          "updatedAt": "2024-07-26T20:47:47Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "I_kwDOJaEkaM6D1qnJ",
      "title": "Add required typ values for the client-attestation and client-attestation-pop in line with JWT BCP",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/72",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready-for-pr"
      ],
      "body": "",
      "createdAt": "2024-03-27T20:50:04Z",
      "updatedAt": "2024-09-11T06:58:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "adeinega",
          "authorAssociation": "NONE",
          "body": "\ud83d\udc4d ",
          "createdAt": "2024-07-15T17:44:13Z",
          "updatedAt": "2024-07-15T17:44:13Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "I just stumbled over this -> Right now the typ is only shown in Appendix A - we should definitely introduce specific typ values in section 4.2 and 4.3",
          "createdAt": "2024-09-10T10:23:06Z",
          "updatedAt": "2024-09-10T10:23:06Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "I_kwDOJaEkaM6D2Ixt",
      "title": "Add relevant oauth error responses to token requests when the client attestation is invalid",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/73",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready-for-pr"
      ],
      "body": "",
      "createdAt": "2024-03-27T22:27:44Z",
      "updatedAt": "2024-09-11T06:58:23Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 75,
      "id": "I_kwDOJaEkaM6FQ1vP",
      "title": "Make PoP optional",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/75",
      "state": "CLOSED",
      "author": "nikosft",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I believe there are many existing systems that generate \"client attestations\" and can benefit from this draft, examples of such client attestations are:\r\n\r\n- Github's [oidc token for actions](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect)\r\n- SPRIFFE [JWT Verifiable Document](https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/#spiffe-verifiable-identity-document-svid)\r\n- Azure [AD Pod identity](https://azure.github.io/aad-pod-identity/)\r\n\r\nHowever in all these solutions, attestations are not bound to any key. ",
      "createdAt": "2024-04-10T14:45:46Z",
      "updatedAt": "2024-05-24T06:20:23Z",
      "closedAt": "2024-05-24T06:20:23Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "OpenID and OAuth already have mechanisms for ordinarily signed JWTs as a means of client authentication toward an AS, such as private key jwt and token exchange so I'm unsure how supporting this would be any different to those existing mechanisms?",
          "createdAt": "2024-05-19T09:35:33Z",
          "updatedAt": "2024-05-19T09:35:33Z"
        },
        {
          "author": "nikosft",
          "authorAssociation": "NONE",
          "body": "Yes you are right",
          "createdAt": "2024-05-24T06:20:23Z",
          "updatedAt": "2024-05-24T06:20:23Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDOJaEkaM6JXDu1",
      "title": "Explicitly state the client attestation mechanism can be used at other endpoints such as PAR",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/76",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready-for-pr"
      ],
      "body": "Should we explcitly say that this may be used at the PAR endpoint?\r\n\r\n_Originally posted by @paulbastian in https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/74#discussion_r1605361442_\r\n            ",
      "createdAt": "2024-05-19T09:38:43Z",
      "updatedAt": "2024-09-11T06:55:10Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 77,
      "id": "I_kwDOJaEkaM6JXD5y",
      "title": "Update client attestation pop to include JTI and nonce",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/77",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready-for-pr"
      ],
      "body": "              The example neither include nonce nor jti, so it does not have replay protection?\r\n\r\n_Originally posted by @paulbastian in https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/74#discussion_r1605339102_\r\n            ",
      "createdAt": "2024-05-19T09:40:32Z",
      "updatedAt": "2024-09-11T06:54:52Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 78,
      "id": "I_kwDOJaEkaM6JnBw2",
      "title": "new HTTP headers are supposed to request their registration",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/78",
      "state": "CLOSED",
      "author": "bc-pi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "> It just (re)occurred to me that specs defining new HTTP headers (which the cool kids call fields nowadays) are supposed to request their registration in the [Hypertext Transfer Protocol (HTTP) Field Name Registry](https://www.iana.org/assignments/http-fields/http-fields.xhtml). I don't want to hold up this PR for this but will create an issue from this comment so as not to lose track of it.\r\n\r\n_Originally posted by @bc-pi in https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/issues/74#issuecomment-2123037858_\r\n            ",
      "createdAt": "2024-05-21T16:47:50Z",
      "updatedAt": "2024-08-29T07:40:00Z",
      "closedAt": "2024-08-29T07:40:00Z",
      "comments": []
    },
    {
      "number": 79,
      "id": "I_kwDOJaEkaM6Jqf8l",
      "title": "Usage of \"public clients\" / \"deployments traditionally viewed as a public client\"",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/79",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "              \"public clients\" ... \"to authenticate\" is a contradiction. The text further up speaks about \"deployments traditionally viewed as a public client\", that's a better description. I would even argue either this spec is for confidential clients of a new kind or it is a new type of client. But it is not for public clients.\r\n\r\n_Originally posted by @tlodderstedt in https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/74#discussion_r1606620990_\r\n            ",
      "createdAt": "2024-05-22T05:43:06Z",
      "updatedAt": "2024-09-14T07:58:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "What would be the downside of defining a new type of client, e.g. attested client?",
          "createdAt": "2024-09-11T06:54:30Z",
          "updatedAt": "2024-09-11T06:54:30Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "It sounds similar to 'credentialed client', a concept that OAuth 2.1 toyed with and ultimately decided didn't help: https://github.com/oauth-wg/oauth-v2-1/issues/107",
          "createdAt": "2024-09-11T07:53:32Z",
          "updatedAt": "2024-09-11T07:53:32Z"
        },
        {
          "author": "babisRoutis",
          "authorAssociation": "NONE",
          "body": "> What would be the downside of defining a new type of client, e.g. attested client?\r\n\r\nI am not sure about the spec, yet [Attested Client](https://github.com/eu-digital-identity-wallet/eudi-lib-jvm-openid4vci-kt/blob/1e85b1b2867f6bd47bdcddc1f5a54048e24a172e/src/main/kotlin/eu/europa/ec/eudi/openid4vci/Config.kt#L39) was the term to use in our VCI library.\r\n",
          "createdAt": "2024-09-14T07:58:16Z",
          "updatedAt": "2024-09-14T07:58:16Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "I_kwDOJaEkaM6RA5VD",
      "title": "client_id optional in the request body",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/81",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "OAuth2 chapter 4.1.3 Access Token Request says:\r\n\r\n>  client_id\r\n>         REQUIRED, if the client is not authenticating with the\r\n>         authorization server as described in [Section 3.2.1](https://datatracker.ietf.org/doc/html/rfc6749#section-3.2.1).\r\n\r\nbut then client assertion drafts make client_id optional https://datatracker.ietf.org/doc/html/rfc7521\r\n\r\nWould you agree that client_id should be optional in this draft, too?",
      "createdAt": "2024-07-26T20:24:32Z",
      "updatedAt": "2024-09-11T06:47:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "This draft doesn't directly use the assertion framework anymore, but I think the idea (to not require client_id) makes sense here as well. This would basically mean this?\r\n- if client_id exists, then\r\n  - Attestation `sub` MUST be equal to `client_id`\r\n  - Attestation PoP `iss` MUST be equal to `client_id`\r\n- otherwise client_id is implicit and \r\n  - Attestation `sub` MUST be equal to Attestation PoP `iss` \r\n ",
          "createdAt": "2024-08-21T12:50:06Z",
          "updatedAt": "2024-08-21T12:50:06Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOJaEkaM5P0e5x",
      "title": "Various editorial updates",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/1",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The following changes are encapsulated in this PR:\r\n\r\n- Update references from RFC7523 to RFC7521.\r\n- Added a recommendation around order of validation for the two JWTs in the client_assertion parameter.\r\n- Removed the note from the exp and iat claims for the client key Attestation JWT that imply this cannot be re-used across multiple requests.\r\n- Removed the ability to use MAC based algorithms when producing the client key Attestation JWT.\r\n- Updated the requirements around the presence of the JTI claim for the client key attestation PoP to be a MUST inline with DPoP PoPs for reliable basic replay attack detection mechanism.\r\n- Added references to the JWT RFC.\r\n- Added an implementation consideration that highlights a client instance can re-use a client key attestation JWT in multiple AS interactions/requests.\r\n- Added aud as a required claim in the client attestation pop JWT.\r\n- Add IANA registration request for the new client assertion type and token endpoint authentication method.",
      "createdAt": "2023-05-04T22:52:22Z",
      "updatedAt": "2023-05-07T20:13:02Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "f84b4b49034eca55f9546d11bbbe0a8657b00b86",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/editorial-updates",
      "headRefOid": "5e5a37dd4f2f5acbc11cb543a517d35a35ce49e0",
      "closedAt": "2023-05-07T20:13:02Z",
      "mergedAt": "2023-05-07T20:13:02Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "fcfa55cd1a986edd8c6438b6eee72aeeeea1e91e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOJaEkaM5QCK17",
      "title": "Add refresh token binding implementation consideration and update broken links",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/2",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed over email, this PR drafts some text to capture the requirement around refresh token binding to the client instance not just the client. The PR also addresses some broken links.\r\n\r\nPersonally I'm still not convinced that the best way to do this binding is through the client attestation key, instead I think we could add a claim that identifies the client instance in the client key attestation",
      "createdAt": "2023-05-08T20:25:40Z",
      "updatedAt": "2023-05-11T19:18:01Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "fcfa55cd1a986edd8c6438b6eee72aeeeea1e91e",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/editorial-updates",
      "headRefOid": "525896663b6a46b83e5bba8a3902076add25569c",
      "closedAt": "2023-05-11T19:17:49Z",
      "mergedAt": "2023-05-11T19:17:49Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "a9c23810d7ebbe6131fc9dd944aecae0d0d9267d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5UqJWv",
          "commit": {
            "abbreviatedOid": "e9cb956"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "few suggestions",
          "createdAt": "2023-05-10T10:39:22Z",
          "updatedAt": "2023-05-10T10:40:33Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "```suggestion\r\n# The OAuth 2.0 Attested Key Based Client Authentication\r\n```",
              "createdAt": "2023-05-10T10:39:22Z",
              "updatedAt": "2023-05-10T10:40:33Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThis is the working area for the individual Internet-Draft, \"The OAuth 2.0 Attested Key Based Client Authentication\".\r\n```",
              "createdAt": "2023-05-10T10:39:34Z",
              "updatedAt": "2023-05-10T10:40:33Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nAuthorization servers issuing a refresh token in response to a token request using the \"urn:ietf:params:oauth:client-assertion-type:jwt-key-attestation\" client authentication method MUST bind the refresh token to the client instance, and NOT just the client as specified in section 6 [@!RFC6749]. To prove this binding, the client instance MUST authenticate itself to the authorization server when refreshing an access token using the \"urn:ietf:params:oauth:client-assertion-type:jwt-key-attestation\" authentication method. The client MUST also use the same client attestation key that was used for authentication when the refresh token was issued.\r\n```",
              "createdAt": "2023-05-10T10:40:25Z",
              "updatedAt": "2023-05-10T10:40:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5UtDqu",
          "commit": {
            "abbreviatedOid": "e9cb956"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-10T17:26:36Z",
          "updatedAt": "2023-05-10T17:26:36Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Don't think we want an article here \"The\" as a start of the title. Also 2.0 is problematic in a world where 2.1 will soon be a thing.",
              "createdAt": "2023-05-10T17:26:36Z",
              "updatedAt": "2023-05-10T17:26:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5UtDtb",
          "commit": {
            "abbreviatedOid": "e9cb956"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-10T17:26:43Z",
          "updatedAt": "2023-05-10T17:26:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "As above",
              "createdAt": "2023-05-10T17:26:43Z",
              "updatedAt": "2023-05-10T17:26:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOJaEkaM5Ql_Wl",
      "title": "Add privacy consideration around client instance tracking",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/5",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As highlighted in the title this PR adds a privacy consideration around potential client instance tracking along with a recommendation for client deployments to mitigate such risk.",
      "createdAt": "2023-05-16T09:17:09Z",
      "updatedAt": "2023-05-17T06:46:06Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "a9c23810d7ebbe6131fc9dd944aecae0d0d9267d",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/client-instance-tracking",
      "headRefOid": "1d0783734cbc31749dbe529159351dddefa679e7",
      "closedAt": "2023-05-17T06:38:14Z",
      "mergedAt": "2023-05-17T06:38:14Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "071f2a30565a4428394ab157325fffd212a47277"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5VJsLR",
          "commit": {
            "abbreviatedOid": "2390ceb"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T13:35:52Z",
          "updatedAt": "2023-05-16T13:35:52Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nImplementers should be aware that using the same client attestation across multiple authorization servers could result in correlation of the end user using the client instance through claim values (including the public key in the `cnf` claim). Client deployments are therefore RECOMMENDED to use different client attestations across different authorization servers.\r\n```",
              "createdAt": "2023-05-16T13:35:52Z",
              "updatedAt": "2023-05-16T13:35:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5VOrvQ",
          "commit": {
            "abbreviatedOid": "1d07837"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-17T06:33:55Z",
          "updatedAt": "2023-05-17T06:33:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "PR_kwDOJaEkaM5RCLU9",
      "title": "Introduction Text + Renaming Client Key Attestation to Client Attestation",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/11",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-22T16:08:04Z",
      "updatedAt": "2023-06-13T19:46:10Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "071f2a30565a4428394ab157325fffd212a47277",
      "headRepository": "paulbastian/draft-looker-oauth-attested-key-based-client-authentication",
      "headRefName": "main",
      "headRefOid": "8825f3f2ea5483d053892c8da6b23e5c3ad8acec",
      "closedAt": "2023-06-13T19:46:10Z",
      "mergedAt": "2023-06-13T19:46:10Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "0d942cf0688ed99afccfb16c850bb5ff7b62bfc3"
      },
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please change file/draft name and title, too. ",
          "createdAt": "2023-05-23T07:33:18Z",
          "updatedAt": "2023-05-23T07:43:03Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "> \r\n> I also perceive this draft as a PoP version of urn:ietf:params:oauth:grant-type:jwt-bearer, would it make sense to make that more intuitive and explicit - like urn:ietf:params:oauth:grant-type:jwt-pop? - this can be another issue\r\n\r\nOpened as a separate issue.",
          "createdAt": "2023-06-05T09:04:28Z",
          "updatedAt": "2023-06-05T09:04:28Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "> a new paragraph in intro sectionis great but hard to follow, suggest to break it down into steps and put under the diagram.\r\n\r\n@Sakurann please check my latest suggestion\r\n",
          "createdAt": "2023-06-05T09:32:55Z",
          "updatedAt": "2023-06-05T09:32:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5VwwSj",
          "commit": {
            "abbreviatedOid": "2208c9a"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-05-23T07:25:58Z",
          "updatedAt": "2023-05-23T07:32:48Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n{{RFC7521}} defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification extends this mechanism to provide a way for a client instance to authenticate itself with the authorization server through an assertion that is sender-constrained with a public key, i.e. the client must present the assertion along with a proof of possession for that public key. \r\n```",
              "createdAt": "2023-05-23T07:25:58Z",
              "updatedAt": "2023-05-23T07:32:48Z"
            },
            {
              "originalPosition": 14,
              "body": "what is an \"attestation scheme\"?",
              "createdAt": "2023-05-23T07:26:18Z",
              "updatedAt": "2023-05-23T07:32:48Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThe Authorization Server will communicate its requirements for the attestation scheme through its metadata. A Client instance that wants to request an access token from this Authorization Server will need to obtain a Client Attestation JWT from its client backend first. Therefore the client will generate an ephemeral key (Client Instance Key) and (platform specific) attestations to proof its genuinity and security to the client backend. The Client instance sends this data to the client backend in request for a Client Attestation JWT. If the Client Backend successfully validates the Client Instance Key and further data, it will generate a signed Client Attestation JWT. As the Client Attestation JWT is cryptographically bound to the Client Instance Key generated by the client, the attestation is bound to this particular client instance. The client backend will respond to the client's request by sending the Client Attestation JWT. The client can proceed and generate a Client Attestation Proof of Possession (PoP) for the Client Instance Key. Lastly, the client sends both the Client Attestation JWT and the Client Attestation PoP with the Token Request to the Authorization Server. The Authorization Server will validate the client attestation and thus authenticates the client. The Authorization Server may continue to issue sender-constrained access tokens using DPoP.\r\n```",
              "createdAt": "2023-05-23T07:29:18Z",
              "updatedAt": "2023-05-23T07:32:48Z"
            },
            {
              "originalPosition": 71,
              "body": "```suggestion\r\n   A JSON Web Token (JWT) generated by the client backend that authenticates the client instance.\r\n```",
              "createdAt": "2023-05-23T07:30:10Z",
              "updatedAt": "2023-05-23T07:32:49Z"
            },
            {
              "originalPosition": 141,
              "body": "Why not just use the same client attestation JWT? That would not require any client instance identification and is also not a privacy issue. \r\n\r\nurn:ietf:params:oauth:client-assertion-type:jwt-key-attestation -> urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation",
              "createdAt": "2023-05-23T07:32:42Z",
              "updatedAt": "2023-05-23T07:32:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WH6z9",
          "commit": {
            "abbreviatedOid": "2208c9a"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T03:05:32Z",
          "updatedAt": "2023-05-26T03:05:33Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "This text feels a bit more complex to me? I think the previous text was a bit clearer in this explanation?",
              "createdAt": "2023-05-26T03:05:32Z",
              "updatedAt": "2023-05-26T03:05:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WH69M",
          "commit": {
            "abbreviatedOid": "2208c9a"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T03:06:41Z",
          "updatedAt": "2023-05-26T03:06:42Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "schema is a bit of a loaded word here I think the JWT processing section already makes it clear AS and clients are permitted to add what ever else they wish to the JWTs\r\n```suggestion\r\nThis specification only defines the format of the Client Assertion JWT that a client instance uses to authenticate in its interactions with an authorization server (indicated in step 6), which is comprised of two key parts:\r\n```",
              "createdAt": "2023-05-26T03:06:41Z",
              "updatedAt": "2023-05-26T03:06:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WH7AZ",
          "commit": {
            "abbreviatedOid": "2208c9a"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T03:07:07Z",
          "updatedAt": "2023-05-26T03:07:07Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\n1. A client attestation JSON Web Token (JWT)- produced by the client backend.\r\n```",
              "createdAt": "2023-05-26T03:07:07Z",
              "updatedAt": "2023-05-26T03:07:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WNC7X",
          "commit": {
            "abbreviatedOid": "2208c9a"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T13:40:30Z",
          "updatedAt": "2023-05-26T13:40:30Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "A well know data structure that defines the data an attestation should, shall or may, contain\r\n\r\nShould It be a defined term?\r\n",
              "createdAt": "2023-05-26T13:40:30Z",
              "updatedAt": "2023-05-26T13:40:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Wf73e",
          "commit": {
            "abbreviatedOid": "346ebf2"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-05-30T15:14:03Z",
          "updatedAt": "2023-05-30T15:28:17Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "yes",
              "createdAt": "2023-05-30T15:14:03Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nNote: the protocols for obtaining Client Attestation JWTs (steps 2 and 4) is out of scope of this specification.\r\n```",
              "createdAt": "2023-05-30T15:17:05Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\n1. A client attestation JWT - produced by the client backend.\r\n```",
              "createdAt": "2023-05-30T15:17:43Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 141,
              "body": "```suggestion\r\nAuthorization servers issuing a refresh token in response to a token request using the \"urn:ietf:params:oauth:client-assertion-type:jwt-key-attestation\" client authentication method MUST bind the refresh token to the client instance, and NOT just the client as specified in section 6 [@!RFC6749]. To prove this binding, the client instance MUST authenticate itself to the authorization server when refreshing an access token using the \"urn:ietf:params:oauth:client-assertion-type:jwt-key-attestation\" authentication method. The client MUST also use the same Client Attestation that was used for authentication when the refresh token was issued.\r\n```",
              "createdAt": "2023-05-30T15:18:35Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThis specification defines a new method of client authentication for OAuth 2.0 {{RFC6749}} by extending the approach defined in {{RFC7521}}. This new method enables client deployments that are traditionally viewed as public clients to be able to authenticate with the authorization server through an attestation based authentication scheme.\r\n```",
              "createdAt": "2023-05-30T15:19:28Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n{{RFC7521}} defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification extends this mechanism to provide a way for a client instance to authenticate itself with the authorization server through an assertion that is bound to a public key (for proof of possession). This assertion is designated as Client Attestation.\r\n```",
              "createdAt": "2023-05-30T15:19:47Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThe Authorization Server will communicate its requirements for the client attestation through its metadata. A Client instance that wants to request an access token from this Authorization Server will need to obtain a Client Attestation JWT from its client backend first. Therefore the client will provide attestations to proof its genuineness and security (typically obtained from the platform) along with a fresh Client Instance Key to its backend. If the Client Backend successfully validates the attestation data and the proof of possession of the Client Instance Key, it will generate a signed Client Attestation JWT that is bound to the client instance key. As the Client Attestation JWT is cryptographically bound to the Client Instance Key generated by the client, the attestation is bound to this specific client instance. The client backend will respond to the client's request with this Client Attestation JWT. The client can proceed and generate a Client Attestation Proof of Possession (PoP) for the Client Instance Key. Lastly, the client sends both the Client Attestation JWT and the Client Attestation PoP with the Token Request to the Authorization Server. The Authorization Server will validate the client attestation and thus authenticates the client instance. The Authorization Server may continue to issue sender-constrained access tokens using DPoP.\r\n```",
              "createdAt": "2023-05-30T15:25:54Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WdJUe",
          "commit": {
            "abbreviatedOid": "4c0617b"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T09:10:44Z",
          "updatedAt": "2023-05-30T16:17:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Why is the Client Instance Key ephemeral? Is there an agreement that this key shall not be reused?",
              "createdAt": "2023-05-30T09:10:44Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            },
            {
              "originalPosition": 141,
              "body": "opened as separate issue",
              "createdAt": "2023-05-30T09:15:30Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            },
            {
              "originalPosition": 54,
              "body": "just wanted to clarify that its about protocols and data formats",
              "createdAt": "2023-05-30T15:01:41Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            },
            {
              "originalPosition": 14,
              "body": "@tlodderstedt Do you prefer schema?",
              "createdAt": "2023-05-30T15:03:43Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            },
            {
              "originalPosition": 54,
              "body": "outdated change",
              "createdAt": "2023-05-30T15:59:10Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            },
            {
              "originalPosition": 12,
              "body": "outdated, but approved the change in my commit",
              "createdAt": "2023-05-30T16:01:00Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Wgpyx",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-30T16:51:23Z",
          "updatedAt": "2023-05-30T16:51:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5Whmik",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T19:11:37Z",
          "updatedAt": "2023-05-30T19:11:38Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n{{RFC7521}} defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification extends this assertion to be bound to a public key for proof of possession. This assertion is designated as Client Attestation.\r\n```",
              "createdAt": "2023-05-30T19:11:37Z",
              "updatedAt": "2023-05-30T19:11:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Who6-",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T19:18:46Z",
          "updatedAt": "2023-05-30T19:18:47Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThe Authorization Server will communicate its requirements for the attestation scheme through its metadata. A Client instance that wants to request an access token from this Authorization Server will need to obtain a Client Attestation JWT, for example, from its client backend first. Therefore, the client will generate a key (Client Instance Key) and (platform specific) attestations to prove its authenticity and security to the client backend. The Client instance sends this data to the client backend in request for a Client Attestation JWT. If the Client Backend successfully validates the Client Instance Key and further data, it will generate a signed Client Attestation JWT. As the Client Attestation JWT is cryptographically bound to the Client Instance Key generated by the client, the attestation is bound to this particular client instance. The client backend will respond to the client's request by sending the Client Attestation JWT. The client can proceed and generate a Client Attestation Proof of Possession (PoP) for the Client Instance Key. Lastly, the client sends both the Client Attestation JWT and the Client Attestation PoP with the Token Request to the Authorization Server. The Authorization Server will validate the client attestation and thus authenticates the client. The Authorization Server may continue to issue sender-constrained access tokens using {{oauth-dpop-16}}.\r\n```\r\n\r\nwhat is `(platform specific) attestation` ?\r\nplease be consistent, capitalize `Client` everywhere or not capitalize it.\r\nthe explanation is pretty long. I would suggest to put a short summary before the diagram but break down this paragraph into the steps and put them under the diagram.",
              "createdAt": "2023-05-30T19:18:46Z",
              "updatedAt": "2023-05-30T19:18:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Whpcu",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T19:20:07Z",
          "updatedAt": "2023-05-30T19:20:07Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "```suggestion\r\n   A cryptographic, asymmetric key generated by the client instance and proven to the client backend. The public key is contained in the Client Attestation JWT and is used to sign the Client Attestation Proof of Possession.\r\n```",
              "createdAt": "2023-05-30T19:20:07Z",
              "updatedAt": "2023-05-30T19:20:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WhrvT",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T19:24:48Z",
          "updatedAt": "2023-05-30T19:24:49Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "I perceive this draft as a PoP version of `urn:ietf:params:oauth:grant-type:jwt-bearer`, would it make sense to make that more intuitive and explicit - like `urn:ietf:params:oauth:grant-type:jwt-pop`?",
              "createdAt": "2023-05-30T19:24:48Z",
              "updatedAt": "2023-05-30T19:24:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Whr_p",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T19:25:31Z",
          "updatedAt": "2023-05-30T19:25:31Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "```suggestion\r\nThe following rules apply to validating the Client Attestation JWT. Application of additional restrictions and policy are at the discretion of the Authorization Server.\r\n```\r\nClient Attestation JWT or Client Attestation PoP JWT?\r\nalso capitalization - please be consistent...",
              "createdAt": "2023-05-30T19:25:31Z",
              "updatedAt": "2023-05-30T19:25:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WhuCq",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "a new paragraph in intro sectionis great but hard to follow, suggest to break it down into steps and put under the diagram.\r\n\r\nI also perceive this draft as a PoP version of urn:ietf:params:oauth:grant-type:jwt-bearer, would it make sense to make that more intuitive and explicit - like urn:ietf:params:oauth:grant-type:jwt-pop? - this can be another issue",
          "createdAt": "2023-05-30T19:30:39Z",
          "updatedAt": "2023-05-30T19:30:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5WiY_v",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:35:53Z",
          "updatedAt": "2023-05-30T21:35:53Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Just noting that given we now have OAuth 2.1 saying this is for OAuth 2.0 might give the wrong compatibility impression?",
              "createdAt": "2023-05-30T21:35:53Z",
              "updatedAt": "2023-05-30T21:35:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WiZdE",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:37:44Z",
          "updatedAt": "2023-05-30T21:37:45Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n{{RFC7521}} defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification uses this framework to define a new assertion type that provides a way for a client instance to authenticate itself with the authorization server through an assertion that is bound to a public key (for proof of possession). This assertion is designated with the name of Client Attestation in this draft.\r\n```",
              "createdAt": "2023-05-30T21:37:45Z",
              "updatedAt": "2023-05-30T21:37:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WiZhJ",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:37:56Z",
          "updatedAt": "2023-05-30T21:37:57Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@tlodderstedt originally made this change",
              "createdAt": "2023-05-30T21:37:56Z",
              "updatedAt": "2023-05-30T21:37:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WiZxZ",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:38:57Z",
          "updatedAt": "2023-05-30T21:38:58Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Kind of conflicts with @Sakurann review, we don't extend the assertion we extend the framework or mechanism defined by RFC 7521.",
              "createdAt": "2023-05-30T21:38:57Z",
              "updatedAt": "2023-05-30T21:38:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WiaUS",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:41:08Z",
          "updatedAt": "2023-05-30T21:41:08Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Communication of this requirement may be communicated via metadata I dont think that is the only way though and would prefer we dont imply this. I'd also prefer we dont talk much about how the attestation is obtained by the client instance, much of this paragraph to me is informational and might set the wrong tone for the draft in terms of prescribing a solution.",
              "createdAt": "2023-05-30T21:41:08Z",
              "updatedAt": "2023-05-30T21:41:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Wiaxg",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:42:58Z",
          "updatedAt": "2023-05-30T21:42:58Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Client Attestation JWT is from the terminology, so I capitalize it, other occurences are not in the Terminology (yet), so therefore not capitalized, that should be consistent for now",
              "createdAt": "2023-05-30T21:42:58Z",
              "updatedAt": "2023-05-30T21:42:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WibEh",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:44:12Z",
          "updatedAt": "2023-05-30T21:44:13Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Still prefer the previous language to be honest, data exchanged is a part of the protocol IMO and its one protocol not multiple hence protocol instead of protocols. The diagram also already describes what is happening so the \"request and sending a client attestation JWT\" feels redundant.  ",
              "createdAt": "2023-05-30T21:44:13Z",
              "updatedAt": "2023-05-30T21:44:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Wibc-",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:45:41Z",
          "updatedAt": "2023-05-30T21:45:42Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Im not against this but I think it makes it less clear how it relates to the terminology we have established in the draft e.g this means the type would be ^ but the name of is client attestation?",
              "createdAt": "2023-05-30T21:45:41Z",
              "updatedAt": "2023-05-30T21:45:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WjLPB",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-31T01:19:24Z",
          "updatedAt": "2023-05-31T01:19:25Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "we don't have OAuth 2.1 yet, it's a draft. But I would be fine with just \"OAuth\" (with the existing reference to RFC 6749",
              "createdAt": "2023-05-31T01:19:25Z",
              "updatedAt": "2023-05-31T01:19:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WvdSt",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-01T11:53:46Z",
          "updatedAt": "2023-06-01T11:53:46Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I agree with @tplooker and like the emphasis on client instance",
              "createdAt": "2023-06-01T11:53:46Z",
              "updatedAt": "2023-06-01T11:53:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XJS5l",
          "commit": {
            "abbreviatedOid": "1d893d1"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T08:55:36Z",
          "updatedAt": "2023-06-05T08:55:37Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "I agree with @tplooker , as that could lead to confusion. But no hard feelings here",
              "createdAt": "2023-06-05T08:55:36Z",
              "updatedAt": "2023-06-05T08:55:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XKsZi",
          "commit": {
            "abbreviatedOid": "6ac2b5c"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-06-05T12:28:16Z",
          "updatedAt": "2023-06-05T12:35:57Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "does the status of \"public clients\" be applied also in this case?\r\n\r\nI've the perception that in our use cases whatever are the statuses of the clients is not relevant to this draft",
              "createdAt": "2023-06-05T12:28:16Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            },
            {
              "originalPosition": 53,
              "body": "I'd write using present, removing \"will\"\r\n\r\nWDYT about\r\n\r\n`The flow starts with the AS communicating its requirements for the client authentication to the client, made available in its metadata.`\r\n\r\nHaving said \"the AS\" that would be the same for the Client as well, thus\r\n\r\n`The Client instance makes available its Client Attestation JWS to the AS where an access token is requested`",
              "createdAt": "2023-06-05T12:33:18Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            },
            {
              "originalPosition": 56,
              "body": "I'd not use the future, I think that would be better talking in the present",
              "createdAt": "2023-06-05T12:34:03Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            },
            {
              "originalPosition": 56,
              "body": "`client instance` -> `Client instance`",
              "createdAt": "2023-06-05T12:34:32Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            },
            {
              "originalPosition": 56,
              "body": "is client backend a defined term? If yes, we should uppercase it accordingly",
              "createdAt": "2023-06-05T12:35:10Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            },
            {
              "originalPosition": 60,
              "body": "will validate -> valitades",
              "createdAt": "2023-06-05T12:35:32Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XK2G8",
          "commit": {
            "abbreviatedOid": "6ac2b5c"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T12:48:39Z",
          "updatedAt": "2023-06-05T12:48:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "the clients being authenticated by the approach of this RFC, are to be considered public clients in OAuth speak. Doesn't it make sense to say so?",
              "createdAt": "2023-06-05T12:48:39Z",
              "updatedAt": "2023-06-05T12:48:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XK68l",
          "commit": {
            "abbreviatedOid": "6ac2b5c"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T12:56:53Z",
          "updatedAt": "2023-06-05T12:56:54Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "I will capitalize things later once they have an entry in the terminology",
              "createdAt": "2023-06-05T12:56:53Z",
              "updatedAt": "2023-06-05T12:56:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XK8Ea",
          "commit": {
            "abbreviatedOid": "6ac2b5c"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T12:59:19Z",
          "updatedAt": "2023-06-05T12:59:19Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I'm ok with public client since wallet instances are mobile devices, I was just asking since I read in the specs also the role of client backend without knowing which would be their client registration mechanisms",
              "createdAt": "2023-06-05T12:59:19Z",
              "updatedAt": "2023-06-05T12:59:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XLDS9",
          "commit": {
            "abbreviatedOid": "6ac2b5c"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T13:14:55Z",
          "updatedAt": "2023-06-05T13:14:56Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "changed all introduction text to present",
              "createdAt": "2023-06-05T13:14:55Z",
              "updatedAt": "2023-06-05T13:14:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XLjSU",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T14:11:19Z",
          "updatedAt": "2023-06-05T14:11:19Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I approve this PR with this in mind\r\n\r\nClient Instance, as represented in the Figure 1, should be a defined term as well",
              "createdAt": "2023-06-05T14:11:19Z",
              "updatedAt": "2023-06-05T14:11:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XLjUZ",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-05T14:11:23Z",
          "updatedAt": "2023-06-05T14:11:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5XYPNF",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-06T19:56:39Z",
          "updatedAt": "2023-06-06T19:56:40Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "This paragraph reads like there is a dependency on an AS providing a metadata document for a client to discover when in reality a client could know through an out of band mechanism that its what the AS requires for client authentication",
              "createdAt": "2023-06-06T19:56:39Z",
              "updatedAt": "2023-06-06T19:56:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XYPyC",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-06T19:58:20Z",
          "updatedAt": "2023-06-06T19:58:21Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Again I'm wary of describing the usage of platform attestations in this draft even in a non-normative manner as this mechanism of client authentication is agnostic to these sorts of things, perhaps we should put this in an appendix?",
              "createdAt": "2023-06-06T19:58:20Z",
              "updatedAt": "2023-06-06T19:58:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XYS8R",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-06T20:03:25Z",
          "updatedAt": "2023-06-06T20:03:26Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "```suggestion\r\n   A JSON Web Token (JWT) generated by the client backend which is bound to a key managed by a client instance which can then be used by the instance for client authentication.\r\n```",
              "createdAt": "2023-06-06T20:03:25Z",
              "updatedAt": "2023-06-06T20:03:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XYo5Q",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-06T20:45:21Z",
          "updatedAt": "2023-06-06T20:45:22Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "```suggestion\r\nClient Attestation Proof of Possession (PoP) JWT\r\n```",
              "createdAt": "2023-06-06T20:45:21Z",
              "updatedAt": "2023-06-06T20:45:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XYpF0",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-06T20:45:53Z",
          "updatedAt": "2023-06-06T20:45:53Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "```suggestion\r\n   A Proof of Possession generated by the client instance using the key that the Client Attestation JWT is bound to.\r\n```",
              "createdAt": "2023-06-06T20:45:53Z",
              "updatedAt": "2023-06-06T20:45:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5YF6J7",
          "commit": {
            "abbreviatedOid": "8825f3f"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I would like to see the description under the sequence diagram improved, but if you want to address that in another PR, that is fine too.",
          "createdAt": "2023-06-13T19:45:05Z",
          "updatedAt": "2023-06-13T19:45:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOJaEkaM5RtQi2",
      "title": "adding myself as author",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/16",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-30T17:12:40Z",
      "updatedAt": "2023-05-30T19:07:33Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "071f2a30565a4428394ab157325fffd212a47277",
      "headRepository": "paulbastian/draft-looker-oauth-attested-key-based-client-authentication",
      "headRefName": "editor",
      "headRefOid": "6461cabfe5388ffb6f8de6c9d8ae956ce6c8cc5b",
      "closedAt": "2023-05-30T19:07:33Z",
      "mergedAt": "2023-05-30T19:07:33Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "3006a80ffa8a5375a1d0fc277a93432b29c3409d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5Whktc",
          "commit": {
            "abbreviatedOid": "6461cab"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-30T19:07:27Z",
          "updatedAt": "2023-05-30T19:07:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 19,
      "id": "PR_kwDOJaEkaM5S7FXz",
      "title": "Simplifies introduction",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/19",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Re-simplifies the introduction ",
      "createdAt": "2023-06-13T19:52:21Z",
      "updatedAt": "2023-10-23T20:07:30Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "0d942cf0688ed99afccfb16c850bb5ff7b62bfc3",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/simplify-intro",
      "headRefOid": "2ff3c8cd02361c4d7471a873635da3c78419d4bd",
      "closedAt": "2023-10-23T20:07:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed in favour of changes made in #52 ",
          "createdAt": "2023-10-23T20:07:30Z",
          "updatedAt": "2023-10-23T20:07:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5Zg2lf",
          "commit": {
            "abbreviatedOid": "2ff3c8c"
          },
          "author": "selfissued",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I agree with this direction.  I would try to eliminate places where the spec appears to be make normative statements about having a backend.  (It's fine to say things like \"1. A Client Attestation JWT - typically produced by the client backend.\")",
          "createdAt": "2023-06-27T20:21:36Z",
          "updatedAt": "2023-06-27T20:21:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5Zg-Ej",
          "commit": {
            "abbreviatedOid": "2ff3c8c"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-27T20:45:25Z",
          "updatedAt": "2023-06-27T20:45:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5jJzxf",
          "commit": {
            "abbreviatedOid": "2ff3c8c"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "informally approved, formally requested two small editorial things",
          "createdAt": "2023-10-08T18:42:39Z",
          "updatedAt": "2023-10-08T18:43:28Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n1. A Client Attestation JWT produced by the client backend.\r\n2. A Client Attestation Proof of Possession (PoP) produced by the client instance.\r\n```",
              "createdAt": "2023-10-08T18:42:39Z",
              "updatedAt": "2023-10-08T18:43:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOJaEkaM5TggJG",
      "title": "Renames the draft",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/21",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Renames the draft as per the previous conversation in #11 ",
      "createdAt": "2023-06-21T06:32:21Z",
      "updatedAt": "2023-06-21T06:34:30Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "0d942cf0688ed99afccfb16c850bb5ff7b62bfc3",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/rename-draft",
      "headRefOid": "e353a6a5f1e289d2a11df5448c3081b6576c5811",
      "closedAt": "2023-06-21T06:34:30Z",
      "mergedAt": "2023-06-21T06:34:30Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "c41f00ee49ceaf65aac6d2b1ab85dc5cb8ba41a3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5YzYDI",
          "commit": {
            "abbreviatedOid": "e353a6a"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-21T06:34:20Z",
          "updatedAt": "2023-06-21T06:34:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOJaEkaM5TscnY",
      "title": "fix: small typos in the diagram",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/22",
      "state": "MERGED",
      "author": "peppelinux",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses # <!-- Issue # here -->\r\n\r\n## \ud83d\udcd1 Description\r\n<!-- Add a brief description of the pr -->\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-06-22T21:06:40Z",
      "updatedAt": "2023-06-26T20:21:30Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "4e37428fbe7d51eca28fb8f78b0670460281b321",
      "headRepository": "peppelinux/draft-looker-oauth-attestation-based-client-authentication",
      "headRefName": "patch-1",
      "headRefOid": "e7d8b3dc2cc3a791280f2e84792dff07a6868a7a",
      "closedAt": "2023-06-26T20:21:30Z",
      "mergedAt": "2023-06-26T20:21:30Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "8d559493b23cbfbb31dc36f055d021727a39ae8b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5ZPXzv",
          "commit": {
            "abbreviatedOid": "e7d8b3d"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-25T21:59:52Z",
          "updatedAt": "2023-06-25T21:59:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5ZXmvU",
          "commit": {
            "abbreviatedOid": "e7d8b3d"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-26T20:21:18Z",
          "updatedAt": "2023-06-26T20:21:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOJaEkaM5UEiST",
      "title": "add 2.0 to be consistent with other oauth drafts",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/23",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "## \ud83d\udcd1 Description\r\n\r\nFixes some minor typos",
      "createdAt": "2023-06-27T19:20:08Z",
      "updatedAt": "2023-06-27T19:20:56Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "c797daf4f099359bcc04229d9e92e3fa1f224f35",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/rename-draft",
      "headRefOid": "c4c448cb447c9f393b44ac00e5031d8445588085",
      "closedAt": "2023-06-27T19:20:16Z",
      "mergedAt": "2023-06-27T19:20:16Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "bfc14dddcc864efe25d201159abfedddc08a7496"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 25,
      "id": "PR_kwDOJaEkaM5UFpJH",
      "title": "Mike's pre-publication suggestions",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/25",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #24",
      "createdAt": "2023-06-28T00:13:26Z",
      "updatedAt": "2023-07-05T20:43:16Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "a09c6e079f6fae416a8ac451fdea7ce987884fad",
      "headRepository": "selfissued/draft-looker-oauth-attestation-based-client-authentication",
      "headRefName": "mbj-pre-publication-suggestions",
      "headRefOid": "c6d649d285643da868cae9984655345db9c05a11",
      "closedAt": "2023-07-05T20:43:16Z",
      "mergedAt": "2023-07-05T20:43:16Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "4eb06888fbe89c8129babc26f501a0693a600510"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5aUiqT",
          "commit": {
            "abbreviatedOid": "c6d649d"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-05T20:42:57Z",
          "updatedAt": "2023-07-05T20:42:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 26,
      "id": "PR_kwDOJaEkaM5U1poR",
      "title": "add example",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/26",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses # <!-- Issue # here -->\r\n\r\n## \ud83d\udcd1 Description\r\n<!-- Add a brief description of the pr -->\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-07-06T18:59:16Z",
      "updatedAt": "2023-07-10T06:59:26Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "4eb06888fbe89c8129babc26f501a0693a600510",
      "headRepository": "paulbastian/draft-looker-oauth-attested-key-based-client-authentication",
      "headRefName": "example",
      "headRefOid": "8816f3015746c0974862cfa0e96f7e4c44e0dc27",
      "closedAt": "2023-07-10T06:59:25Z",
      "mergedAt": "2023-07-10T06:59:25Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "ddfbf0d8a096db7362ab478f60f3381eb1c8a8c8"
      },
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "@tlodderstedt please review",
          "createdAt": "2023-07-10T06:53:46Z",
          "updatedAt": "2023-07-10T06:53:46Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5abgTJ",
          "commit": {
            "abbreviatedOid": "a5e3fa1"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-06T19:14:50Z",
          "updatedAt": "2023-07-06T19:14:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n# Appendix A IANA Considerations\r\n```",
              "createdAt": "2023-07-06T19:14:50Z",
              "updatedAt": "2023-07-06T19:14:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5abkQ9",
          "commit": {
            "abbreviatedOid": "f7f835c"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-06T19:27:55Z",
          "updatedAt": "2023-07-06T19:27:56Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n\t\"typ\": \"vc+sd-jwt\",\r\n```",
              "createdAt": "2023-07-06T19:27:55Z",
              "updatedAt": "2023-07-06T19:27:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5abpZy",
          "commit": {
            "abbreviatedOid": "27016e1"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-06T19:42:55Z",
          "updatedAt": "2023-07-06T19:42:55Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\n\t\"typ\": \"wallet-attestation+jwt\",\r\n\t\"alg\": \"ES256\",\r\n\t\"kid\": \"1\"\r\n}\r\n.\r\n{\r\n\t\"iss\": \"https://attestation-service.ssi.tir.budru.de\",\r\n\t\"sub\" : \"https://lissi.org\",\r\n\t\"iat\": 1541493724,\r\n\t\"exp\": 1516247022,\r\n\t\"wallet_name\": \"Lissi Dev\",\r\n```",
              "createdAt": "2023-07-06T19:42:55Z",
              "updatedAt": "2023-07-06T19:42:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5afHlN",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-07-07T07:10:57Z",
          "updatedAt": "2023-07-07T07:12:28Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\n\t\"iss\": \"https://wallet.example.com\",\r\n```",
              "createdAt": "2023-07-07T07:10:57Z",
              "updatedAt": "2023-07-07T07:12:28Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\n\t\"sub\" : \"https://wallet.example.com\"\",\r\n```",
              "createdAt": "2023-07-07T07:11:14Z",
              "updatedAt": "2023-07-07T07:12:28Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\r\n```",
              "createdAt": "2023-07-07T07:11:28Z",
              "updatedAt": "2023-07-07T07:12:28Z"
            },
            {
              "originalPosition": 17,
              "body": "If you mention eIDAS terms, like \"Type-1 configuration\", you also need to add a reference to the ARF.",
              "createdAt": "2023-07-07T07:12:17Z",
              "updatedAt": "2023-07-07T07:12:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5afWY8",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T07:34:11Z",
          "updatedAt": "2023-07-07T07:34:12Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n\t\"key_type\" : \"STRONGBOX\",\r\n```",
              "createdAt": "2023-07-07T07:34:12Z",
              "updatedAt": "2023-07-07T07:34:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5afXGc",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-07-07T07:35:24Z",
          "updatedAt": "2023-07-07T07:35:58Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\n```\r\n\r\nWhy the attestation should disclose information like these?\r\nProbably the User doesn't want to disclose the device name and the wallet version",
              "createdAt": "2023-07-07T07:35:24Z",
              "updatedAt": "2023-07-07T07:35:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ag2bI",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T10:54:41Z",
          "updatedAt": "2023-07-07T10:54:41Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I would rename this to attestation-service.com to signalize that these could be different?",
              "createdAt": "2023-07-07T10:54:41Z",
              "updatedAt": "2023-07-07T10:54:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ag4pN",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T11:00:43Z",
          "updatedAt": "2023-07-07T11:00:43Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "\"wallet_name\" is meant as a human readable name of the wallet solution, the technical identifier for a wallet solution would be registered as \"sub\"\r\n\"wallet_version\" is the version of the wallet instance of the wallet solution. The certification and validity status of a wallet solution probably depends on the version, thus for lookup in a trust registry the version is useful",
              "createdAt": "2023-07-07T11:00:43Z",
              "updatedAt": "2023-07-07T11:00:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ahYBN",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T12:13:01Z",
          "updatedAt": "2023-07-07T12:13:01Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I see some value in the wallet name. wrt the version, as we discussed yesterday, I would assume whatever is needed to lookup data about the authorization of the wallet should be encoded in the iss or sub value. ",
              "createdAt": "2023-07-07T12:13:01Z",
              "updatedAt": "2023-07-07T12:13:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ahZD-",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T12:14:48Z",
          "updatedAt": "2023-07-07T12:14:48Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I think this is a special case, which requires explanation. If you provide text, I could incorporate into https://github.com/vcstuff/oid4vc-haip-sd-jwt-vc/pull/52\r\n\r\nI would like to keep the example as simple as possible.  \r\n\r\n",
              "createdAt": "2023-07-07T12:14:48Z",
              "updatedAt": "2023-07-07T12:15:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ajtJm",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T17:00:01Z",
          "updatedAt": "2023-07-07T17:00:02Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "added attested security context instead",
              "createdAt": "2023-07-07T17:00:02Z",
              "updatedAt": "2023-07-07T17:00:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ajtRO",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T17:00:24Z",
          "updatedAt": "2023-07-07T17:00:25Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "added version to sub",
              "createdAt": "2023-07-07T17:00:24Z",
              "updatedAt": "2023-07-07T17:00:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5arj1h",
          "commit": {
            "abbreviatedOid": "8816f30"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-10T06:52:58Z",
          "updatedAt": "2023-07-10T06:52:59Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\n\t\"key_type\" : \"Strongbox\",\r\n```",
              "createdAt": "2023-07-10T06:52:59Z",
              "updatedAt": "2023-07-10T06:52:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5armix",
          "commit": {
            "abbreviatedOid": "8816f30"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T06:58:55Z",
          "updatedAt": "2023-07-10T06:58:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 40,
      "id": "PR_kwDOJaEkaM5Zu2j5",
      "title": "fix: jti usage language",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/40",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses issues with language about the jti claim in the client attestation and pop jwt.\r\n\r\nCloses #34 \r\nCloses #33 \r\nCloses #37 ",
      "createdAt": "2023-09-07T00:55:00Z",
      "updatedAt": "2023-09-10T20:21:07Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "cb0ef588b56e55d29485b7e7a5e3982f5cd21197",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/jti-fixes",
      "headRefOid": "c4b13bda0033411e98f86928dbd1eb42f5a3c3e1",
      "closedAt": "2023-09-07T21:03:30Z",
      "mergedAt": "2023-09-07T21:03:30Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "69ab12820785d6d9c7eb63c09fc5d0c2ce88b0ea"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5gUIb7",
          "commit": {
            "abbreviatedOid": "c4b13bd"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-07T17:03:37Z",
          "updatedAt": "2023-09-07T17:03:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5gVaqV",
          "commit": {
            "abbreviatedOid": "c4b13bd"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-07T20:53:08Z",
          "updatedAt": "2023-09-07T20:53:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "PR_kwDOJaEkaM5Zu5iZ",
      "title": "fix: cnf claim definition in client attestation",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/41",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Clarifies the purpose of the cnf claim in the client attestation.\r\n\r\nPartially addresses #36",
      "createdAt": "2023-09-07T01:16:34Z",
      "updatedAt": "2023-09-10T20:21:06Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "cb0ef588b56e55d29485b7e7a5e3982f5cd21197",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/cnf-claim",
      "headRefOid": "8cf674e77485a08f1556a176dad155dfb9387982",
      "closedAt": "2023-09-08T21:44:03Z",
      "mergedAt": "2023-09-08T21:44:03Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "5bdd508375492f6d571f4b47b2e8502f81a33457"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5gUKZt",
          "commit": {
            "abbreviatedOid": "8cf674e"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-07T17:07:12Z",
          "updatedAt": "2023-09-07T17:07:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5gdgP9",
          "commit": {
            "abbreviatedOid": "8cf674e"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-08T21:43:58Z",
          "updatedAt": "2023-09-08T21:43:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 42,
      "id": "PR_kwDOJaEkaM5Zu69c",
      "title": "fix refresh token binding issue",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/42",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #31 \r\nCloses #12 ",
      "createdAt": "2023-09-07T01:21:27Z",
      "updatedAt": "2023-09-10T20:21:05Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "cb0ef588b56e55d29485b7e7a5e3982f5cd21197",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/rt-binding",
      "headRefOid": "ae04ddcee9e1797e3977c7ba3b30c24ae8a41f4d",
      "closedAt": "2023-09-08T21:43:04Z",
      "mergedAt": "2023-09-08T21:43:04Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "97c241f3b9baab01e4537750dbed0c29e6544eb1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5gUIoM",
          "commit": {
            "abbreviatedOid": "ae04ddc"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-07T17:04:10Z",
          "updatedAt": "2023-09-07T17:04:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5gdfy2",
          "commit": {
            "abbreviatedOid": "ae04ddc"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-08T21:43:00Z",
          "updatedAt": "2023-09-08T21:43:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOJaEkaM5Zu9AZ",
      "title": "fix: generalise the client authentication section",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/43",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Minor language tweaks aligning more to RFC 7521 in how the client authentication mechanism is defined as to not limit its application to only being used at the token endpoint.\r\n\r\nCloses #27",
      "createdAt": "2023-09-07T01:36:28Z",
      "updatedAt": "2023-09-10T20:21:04Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "cb0ef588b56e55d29485b7e7a5e3982f5cd21197",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/client-auth-generalization",
      "headRefOid": "7dcc424a319113ec6e325869b99161dfb67200fb",
      "closedAt": "2023-09-08T21:45:59Z",
      "mergedAt": "2023-09-08T21:45:59Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "2afbd665e8cbd9e9c2c82fabf918da05ed573037"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5gdhJ1",
          "commit": {
            "abbreviatedOid": "7dcc424"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-08T21:45:54Z",
          "updatedAt": "2023-09-08T21:45:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "PR_kwDOJaEkaM5ZznZW",
      "title": "add to acknowledgments",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/44",
      "state": "MERGED",
      "author": "bc-pi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Asking to add myself to the acknowledgments, which I think is reasonable based on conversations, emails, etc. that I've had with the authors on the topic. \r\n\r\nThere are probably other names that should be added too...\r\n",
      "createdAt": "2023-09-07T17:50:12Z",
      "updatedAt": "2023-09-07T19:00:41Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "cb0ef588b56e55d29485b7e7a5e3982f5cd21197",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "bc-pi-add-to-acks",
      "headRefOid": "236d12dd45d91bd41c05973b9d74b96d4f1319b0",
      "closedAt": "2023-09-07T18:52:02Z",
      "mergedAt": "2023-09-07T18:52:02Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "6dcd84c85bfa441b336b2a1bc8cfc9a230999afb"
      },
      "comments": [
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you :)",
          "createdAt": "2023-09-07T19:00:34Z",
          "updatedAt": "2023-09-07T19:00:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5gUwHl",
          "commit": {
            "abbreviatedOid": "236d12d"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "A PR I should have already raised myself :)",
          "createdAt": "2023-09-07T18:51:50Z",
          "updatedAt": "2023-09-07T18:51:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 48,
      "id": "PR_kwDOJaEkaM5cMdH5",
      "title": "add text on aal",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/48",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses # <!-- Issue # here -->\r\n\r\n## \ud83d\udcd1 Description\r\nOn text on optional aal parameter\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-08T15:01:59Z",
      "updatedAt": "2023-10-09T14:22:41Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "2afbd665e8cbd9e9c2c82fabf918da05ed573037",
      "headRepository": "paulbastian/draft-looker-oauth-attested-key-based-client-authentication",
      "headRefName": "aal",
      "headRefOid": "b843a2a60fa49577b58d083b483823a6e4fc3dd3",
      "closedAt": "2023-10-09T14:22:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry @peppelinux . This PR got somehow messed up in git merge. I will raise a new one, as this was only intended for aal",
          "createdAt": "2023-10-09T14:22:41Z",
          "updatedAt": "2023-10-09T14:22:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5jJzi9",
          "commit": {
            "abbreviatedOid": "b843a2a"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "@paulbastian it seems that this PR doesn't contain nothing about AAL, is this a mistake?\r\n\r\n--- updates ---\r\n\r\nfound it at line 195, my bad",
          "createdAt": "2023-10-08T18:34:06Z",
          "updatedAt": "2023-10-09T09:22:51Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "git merge conflict here, I'm in favor of the first sentence :-)\r\nthen we should put a ref to RFC7519, related to the section where the jti claim is defined",
              "createdAt": "2023-10-08T18:34:07Z",
              "updatedAt": "2023-10-08T18:41:51Z"
            },
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n3. The JWT MUST contain an \"aud\" (audience) claim containing a value that identifies the authorization server as an intended audience. The {{RFC8414}} issuer identifier URL of the authorization server MUST be used as a value for an \"aud\" element to identify the authorization server as the intended audience of the JWT.\r\n```\r\n```suggestion\r\n3. The JWT MUST contain the \"aud\" (audience) claim containing a value that identifies the authorization server as an intended audience. The {{RFC8414}} issuer identifier URL of the authorization server MUST be used as a value for an \"aud\" element to identify the authorization server as the intended audience of the JWT.\r\n```\r\n\r\nI suggest to have in the aud the url of the endpoint where the JWT is intended to be used, then the authz endpoint, the token endpoint ... it could/should be an array as well. When we say `containing a value that identifies the authorization server` we should mention the issuer (entity id) as well and a ref to rfc8414 (issuer claim, that MUST be present within the AS metadata)",
              "createdAt": "2023-10-08T18:35:23Z",
              "updatedAt": "2023-10-08T18:41:51Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n34 The JWT MAY contain the \"jti\" (JWT ID) claim that provides a unique identifier for the token.  The authorization server MAY ensure that JWTs are not replayed by maintaining the set of used \"jti\" values for the length of time for which the JWT would be considered valid based on the applicable \"exp\" instant.\r\n```",
              "createdAt": "2023-10-08T18:37:06Z",
              "updatedAt": "2023-10-08T18:41:51Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n5. The JWT MAY contain the \"nonce\" claim containing the value provided by the authorization server to associate the Client Attestation PoP JWT with a particular transaction and prevent replay attacks.\r\n```",
              "createdAt": "2023-10-08T18:38:24Z",
              "updatedAt": "2023-10-08T18:41:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5jKXCP",
          "commit": {
            "abbreviatedOid": "b843a2a"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T02:05:57Z",
          "updatedAt": "2023-10-09T02:05:58Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n7. The JWT MAY contain a \"jti\" (JWT ID) claim that provides a unique identifier for the token. The authorization server MAY ensure that JWTs are not replayed by maintaining the set of used \"jti\" values for the length of time for which the JWT would be considered valid based on the applicable \"exp\" instant.\r\n```",
              "createdAt": "2023-10-09T02:05:57Z",
              "updatedAt": "2023-10-09T02:05:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5jK8Zi",
          "commit": {
            "abbreviatedOid": "b843a2a"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T06:54:33Z",
          "updatedAt": "2023-10-09T06:54:33Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "`The authorization server MAY ensure that JWTs are not replayed by maintaining the set of used \"jti\" values for the length of time for which the JWT would be considered valid based on the applicable \"exp\" instant.`\r\n\r\nthis is possibile only if `jti` is REQUIRED, that's why I suggest to move that MAY to a MUST, otherwise the text above would not make any sense",
              "createdAt": "2023-10-09T06:54:33Z",
              "updatedAt": "2023-10-09T06:54:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 49,
      "id": "PR_kwDOJaEkaM5cMdpW",
      "title": "Replay prevention",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/49",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses # <!-- Issue # here -->\r\n\r\n## \ud83d\udcd1 Description\r\n<!-- Add a brief description of the pr -->\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-08T15:09:52Z",
      "updatedAt": "2023-10-23T09:14:33Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "2afbd665e8cbd9e9c2c82fabf918da05ed573037",
      "headRepository": "paulbastian/draft-looker-oauth-attested-key-based-client-authentication",
      "headRefName": "replay-prevention",
      "headRefOid": "d5d5ffeb73f28d0a77b5955b78fa7008478823be",
      "closedAt": "2023-10-23T09:14:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed in favor for #54 ",
          "createdAt": "2023-10-23T09:14:33Z",
          "updatedAt": "2023-10-23T09:14:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5jJwGZ",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-10-08T18:18:03Z",
          "updatedAt": "2023-10-08T18:32:10Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "MAY is to weak!\r\n\r\nI really prefer the previous text where the JTI MUST be present and the AS MAY evaluate it. It doesn't cost nothing to the implementers, that would be just an uuid4",
              "createdAt": "2023-10-08T18:18:03Z",
              "updatedAt": "2023-10-08T18:45:21Z"
            },
            {
              "originalPosition": 17,
              "body": "`iat`, `exp` and claims belongin to JWT should include a ref to the RFC that defined them, so that there also the format and any other relevant information could be given in relation to these",
              "createdAt": "2023-10-08T18:26:40Z",
              "updatedAt": "2023-10-08T18:32:10Z"
            },
            {
              "originalPosition": 23,
              "body": "did we say something about the epic alg `none` here? ;-)",
              "createdAt": "2023-10-08T18:27:22Z",
              "updatedAt": "2023-10-08T18:32:10Z"
            },
            {
              "originalPosition": 38,
              "body": "agreed, then we shoudl mandate the presence of `jti` in the WIA as it was before this PR",
              "createdAt": "2023-10-08T18:28:37Z",
              "updatedAt": "2023-10-08T18:32:10Z"
            },
            {
              "originalPosition": 39,
              "body": "may we say something on the minimum length of the nonce?",
              "createdAt": "2023-10-08T18:29:38Z",
              "updatedAt": "2023-10-08T18:32:10Z"
            },
            {
              "originalPosition": 40,
              "body": "here we don't say who's the issuer of the existing artefact and from where and when it was taken.\r\n\r\nI understand the meaning but for editorial sake we should say something more explicit here",
              "createdAt": "2023-10-08T18:32:05Z",
              "updatedAt": "2023-10-08T18:32:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5jJz07",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-10-08T18:44:41Z",
          "updatedAt": "2023-10-08T18:47:37Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n3. The JWT MUST contain the \"aud\" (audience) claim containing a value that identifies the authorization server as an intended audience. The {{RFC8414}} issuer identifier URL of the authorization server MUST be used as a value for an \"aud\" element to identify the authorization server as the intended audience of the JWT.\r\n```\r\n\r\nWDYT about using the instead of \"an\"? If agreed, please change all the occurence accordignly or ask to me to give a suggestion to have them easy to be merged",
              "createdAt": "2023-10-08T18:44:41Z",
              "updatedAt": "2023-10-08T18:47:37Z"
            },
            {
              "originalPosition": 39,
              "body": "as for all the other parameters, it would be better to give a ref to the RFC that have defined them, for the nonce it would be something like \r\n\r\nshall require the nonce parameter defined in Section 3.1.2.1 of [OIDC](https://openid.net/specs/openid-connect-core-1_0.html) in the authentication request.",
              "createdAt": "2023-10-08T18:47:28Z",
              "updatedAt": "2023-10-08T18:47:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k2p0U",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T09:03:37Z",
          "updatedAt": "2023-10-23T09:03:38Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "agreed to this in discussion with Tobias. The PR is from an old repo of mine and I will file a fresh one, sry for that",
              "createdAt": "2023-10-23T09:03:38Z",
              "updatedAt": "2023-10-23T09:03:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k2qC_",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T09:04:08Z",
          "updatedAt": "2023-10-23T09:04:08Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I would leave this to native speakers and to a separate issue, please raise one if thats important to you",
              "createdAt": "2023-10-23T09:04:08Z",
              "updatedAt": "2023-10-23T09:04:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k2qg9",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T09:05:08Z",
          "updatedAt": "2023-10-23T09:05:08Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "This is a good idea, but I would like to keep this PR short",
              "createdAt": "2023-10-23T09:05:08Z",
              "updatedAt": "2023-10-23T09:05:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k2q0S",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T09:05:48Z",
          "updatedAt": "2023-10-23T09:05:48Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I think the text is clear enough here",
              "createdAt": "2023-10-23T09:05:48Z",
              "updatedAt": "2023-10-23T09:05:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k2q_c",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T09:06:09Z",
          "updatedAt": "2023-10-23T09:06:10Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "agreed",
              "createdAt": "2023-10-23T09:06:09Z",
              "updatedAt": "2023-10-23T09:06:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k2tXq",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T09:11:22Z",
          "updatedAt": "2023-10-23T09:11:22Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "done in new PR",
              "createdAt": "2023-10-23T09:11:22Z",
              "updatedAt": "2023-10-23T09:11:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k2tqB",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T09:11:59Z",
          "updatedAt": "2023-10-23T09:11:59Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "I don't see OIDC making it explicit about the nonce length either",
              "createdAt": "2023-10-23T09:11:59Z",
              "updatedAt": "2023-10-23T09:12:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 50,
      "id": "PR_kwDOJaEkaM5cMd2Q",
      "title": "Update referenced rfcs",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/50",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses # <!-- Issue # here -->\r\n\r\n## \ud83d\udcd1 Description\r\n<!-- Add a brief description of the pr -->\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-08T15:12:59Z",
      "updatedAt": "2023-10-23T07:31:05Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "2afbd665e8cbd9e9c2c82fabf918da05ed573037",
      "headRepository": "paulbastian/draft-looker-oauth-attested-key-based-client-authentication",
      "headRefName": "update-referenced-rfcs",
      "headRefOid": "290dbb93a54965e589a81a4d8506bb1d0cccbc84",
      "closedAt": "2023-10-23T07:31:05Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 51,
      "id": "PR_kwDOJaEkaM5cRKk4",
      "title": "add text on aal",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/51",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses #15 \r\nCloses #29 \r\n\r\n## \ud83d\udcd1 Description\r\nAdd text on aal claim\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-09T14:31:36Z",
      "updatedAt": "2024-08-22T06:47:32Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "efa100ca094afee2303275bd8f518b81c9a0c97a",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "aal",
      "headRefOid": "ca1825a223e6f3d9b2dc0d996578e0ad6287f0d7",
      "closedAt": "2024-08-22T06:47:32Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Supported here\r\nhttps://github.com/italia/eudi-wallet-it-docs/pull/155\r\n\r\nanyway it would be better define within the specs the grouping of the security capabilities according to the levels low, medium and high\r\n",
          "createdAt": "2023-11-02T11:53:55Z",
          "updatedAt": "2023-11-02T11:53:55Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "regarding the current ideas developed in OpenID4VCI to separate wallet attestation and key attestation (see https://github.com/openid/OpenID4VCI/issues/355 ) this no longer makes sense here",
          "createdAt": "2024-08-22T06:47:32Z",
          "updatedAt": "2024-08-22T06:47:32Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5k1yrW",
          "commit": {
            "abbreviatedOid": "5972c61"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T06:56:08Z",
          "updatedAt": "2023-10-23T06:56:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n8. The JWT MAY contain a \"aal\" (authenticator assurance level) claim that describes the attested assurance level of the Client Instance and the Client Instance Key. The claim value contains a URI that references a jurisdictional framework. Consumers of the client attestation are RECOMMENDED to evaluate this claim, if they intend to state an assurance level for their issued tokens themselves.\r\n```",
              "createdAt": "2023-10-23T06:56:09Z",
              "updatedAt": "2023-10-23T06:56:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5nVqQ1",
          "commit": {
            "abbreviatedOid": "b58032e"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-16T08:03:30Z",
          "updatedAt": "2023-11-16T08:03:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n8. The JWT MAY contain a \"aal\" (authenticator assurance level) claim that describes the attested assurance level of the Client Instance and the Client Instance Key. The claim value contains a URI that references a jurisdictional framework. Consumers of the Client attestation are RECOMMENDED to evaluate this claim, if they intend to state an assurance level for their issued tokens themselves.\r\n```",
              "createdAt": "2023-11-16T08:03:31Z",
              "updatedAt": "2023-11-16T08:03:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 52,
      "id": "PR_kwDOJaEkaM5dfsiC",
      "title": "redesigning sequence diagram for introduction",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/52",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses #28 \r\n\r\n## \ud83d\udcd1 Description\r\n<!-- Add a brief description of the pr -->\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-23T07:08:55Z",
      "updatedAt": "2023-10-23T20:17:36Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "f3bcbb6d51e53179e5305a87ee77b94e0d05d6c6",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "pb/introduction",
      "headRefOid": "cec19c496f893a2aa174859bd75c2d9057c37a3a",
      "closedAt": "2023-10-23T20:17:36Z",
      "mergedAt": "2023-10-23T20:17:36Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "da0aa67d34880a59621d7a2715d08fbb9f40e60b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5k79LP",
          "commit": {
            "abbreviatedOid": "53f3483"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T20:06:58Z",
          "updatedAt": "2023-10-23T20:06:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5k8ATu",
          "commit": {
            "abbreviatedOid": "53f3483"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T20:15:47Z",
          "updatedAt": "2023-10-23T20:15:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 53,
      "id": "PR_kwDOJaEkaM5dfyGb",
      "title": "remove JWT ID from Client Attestation JWT",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/53",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses # <!-- Issue # here -->\r\n\r\n## \ud83d\udcd1 Description\r\n<!-- Add a brief description of the pr -->\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-23T07:25:56Z",
      "updatedAt": "2023-10-23T18:22:41Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "2afbd665e8cbd9e9c2c82fabf918da05ed573037",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "pb/remove-jti",
      "headRefOid": "7fa2916a9c05756d36b93aa4d03765f0c4d746cc",
      "closedAt": "2023-10-23T18:22:41Z",
      "mergedAt": "2023-10-23T18:22:41Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "c984b2efd5177e8909d731552eefbe45bec5c9f9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5k7JPV",
          "commit": {
            "abbreviatedOid": "7fa2916"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T18:22:35Z",
          "updatedAt": "2023-10-23T18:22:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 54,
      "id": "PR_kwDOJaEkaM5dgaPD",
      "title": "replay attack prevention",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/54",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses #49\r\nCloses #9 \r\n\r\n## \ud83d\udcd1 Description\r\nAdd security consideration for replay attack prevention and add nonce as optional value for PoP JWT\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-23T09:14:13Z",
      "updatedAt": "2023-10-23T20:15:32Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "c6044dced77de65a5706bcafc7baec4587ba8201",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "pb/replay-attack-prevention",
      "headRefOid": "307b46da9a75cd6e6c07622d90ccfe087dc9119f",
      "closedAt": "2023-10-23T20:15:31Z",
      "mergedAt": "2023-10-23T20:15:31Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "f3bcbb6d51e53179e5305a87ee77b94e0d05d6c6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5k7Kpp",
          "commit": {
            "abbreviatedOid": "06f791f"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T18:26:06Z",
          "updatedAt": "2023-10-23T18:26:07Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Should we make this into a sub heading like `Replay Attack Detection`?",
              "createdAt": "2023-10-23T18:26:06Z",
              "updatedAt": "2023-10-23T18:26:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k79uZ",
          "commit": {
            "abbreviatedOid": "06f791f"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T20:08:29Z",
          "updatedAt": "2023-10-23T20:08:29Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n## Replay Attack Detection\r\n\r\nThe following mechanisms exist within this client authentication method in order to allow an authorization server to detect replay attacks for presented client attestation PoPs:\r\n```",
              "createdAt": "2023-10-23T20:08:29Z",
              "updatedAt": "2023-10-23T20:10:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k7-3k",
          "commit": {
            "abbreviatedOid": "29de252"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T20:11:40Z",
          "updatedAt": "2023-10-23T20:11:41Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n## Replay Attack Detection\r\n\r\nThe following mechanisms exist within this client authentication method in order to allow an authorization server to detect replay attacks for presented client attestation PoPs:\r\n```",
              "createdAt": "2023-10-23T20:11:40Z",
              "updatedAt": "2023-10-23T20:11:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k7_jT",
          "commit": {
            "abbreviatedOid": "29de252"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T20:13:40Z",
          "updatedAt": "2023-10-23T20:13:40Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nThe approach using a nonce explicitly provided by the authorization server gives stronger replay attack detection guarantees, however support by the authorization server is OPTIONAL to simplify mandatory implementation requirements. The \"jti\" method is mandatory and hence acts as a default fallback.\r\n```",
              "createdAt": "2023-10-23T20:13:40Z",
              "updatedAt": "2023-10-23T20:14:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k8AI9",
          "commit": {
            "abbreviatedOid": "307b46d"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T20:15:16Z",
          "updatedAt": "2023-10-23T20:15:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 55,
      "id": "PR_kwDOJaEkaM5dkTHB",
      "title": "update acknowledments",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/55",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses # <!-- Issue # here -->\r\n\r\n## \ud83d\udcd1 Description\r\n<!-- Add a brief description of the pr -->\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-23T19:12:05Z",
      "updatedAt": "2023-10-23T20:07:12Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "c984b2efd5177e8909d731552eefbe45bec5c9f9",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "pb/acknowledgments",
      "headRefOid": "dffbd0bf8cd6756d8d2d59e95ab8744918298cff",
      "closedAt": "2023-10-23T20:07:12Z",
      "mergedAt": "2023-10-23T20:07:12Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "a0c84e9505d9d1750ee9a8aabbf3a268a21a3499"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5k78c4",
          "commit": {
            "abbreviatedOid": "dffbd0b"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T20:04:58Z",
          "updatedAt": "2023-10-23T20:04:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 63,
      "id": "PR_kwDOJaEkaM5fST1s",
      "title": "Add text on cnf key rotation",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/63",
      "state": "MERGED",
      "author": "cobward",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses #57 \r\n\r\n## \ud83d\udcd1 Description\r\nThis PR makes explicit an already implicit feature of the specification - that it is not possible to rotate the confirmation key.\r\n<!--\r\n## Preview Link\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)\r\n-->",
      "createdAt": "2023-11-13T10:52:13Z",
      "updatedAt": "2024-02-13T17:42:06Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "4375d894ce7e58c91d5ed282cfd733dd48417812",
      "headRepository": "cobward/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "patch-1",
      "headRefOid": "4e783cc13e5929318a5915c67407e6d184c14aa0",
      "closedAt": "2024-02-13T17:42:06Z",
      "mergedAt": "2024-02-13T17:42:06Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "ac2eec4c4bcc3e206aca6df55910e5dc40da2eac"
      },
      "comments": [
        {
          "author": "cobward",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tlodderstedt @paulbastian Any reason this can't be merged?",
          "createdAt": "2024-02-06T12:13:09Z",
          "updatedAt": "2024-02-06T12:13:09Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": " Waiting for @tplooker approval",
          "createdAt": "2024-02-06T12:15:31Z",
          "updatedAt": "2024-02-06T12:15:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5m-nAU",
          "commit": {
            "abbreviatedOid": "a6df619"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-13T16:20:27Z",
          "updatedAt": "2023-11-13T16:21:25Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n## Rotation of Client Instance Key\r\n\r\nThis specification does not provide a mechanism to rotate the Client Instance Key in the Client Attestation JWT's \"cnf\" claim. If the Client Instance needs to use a new Client Instance Key for any reason, then it MUST request a new Client Attestation JWT from its Client Backend.\r\n\r\n```",
              "createdAt": "2023-11-13T16:20:28Z",
              "updatedAt": "2023-11-13T16:21:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5nHIUt",
          "commit": {
            "abbreviatedOid": "4e783cc"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-14T14:48:08Z",
          "updatedAt": "2023-11-14T14:48:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5nVqln",
          "commit": {
            "abbreviatedOid": "4e783cc"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-16T08:04:25Z",
          "updatedAt": "2023-11-16T08:04:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5nXBlr",
          "commit": {
            "abbreviatedOid": "4e783cc"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-16T10:55:21Z",
          "updatedAt": "2023-11-16T10:55:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5v1UG_",
          "commit": {
            "abbreviatedOid": "4e783cc"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-12T20:48:02Z",
          "updatedAt": "2024-02-12T20:48:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOJaEkaM5fajeK",
      "title": "Adds server-provided nonces for Client Attestation PoP JWT freshness verification",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/64",
      "state": "OPEN",
      "author": "pmhsfelix",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses #59\r\n\r\n## \ud83d\udcd1 Description\r\nThis PR adds server-provided nonces as a way to check the freshness of Client Attestation PoP JWT, in a similar way to what is done in DPoP (RFC 9449).\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\nNA",
      "createdAt": "2023-11-14T14:08:40Z",
      "updatedAt": "2024-08-22T09:02:40Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "4375d894ce7e58c91d5ed282cfd733dd48417812",
      "headRepository": "pmhsfelix/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "add-server-provided-nonce",
      "headRefOid": "fa66a20f14e5e2425f583d1c53ac8e13c3c31c73",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "This is the obvious solution going in the right direction. I'm not convinced yet that this is the ideal solution, especially in combination with DPoP.",
          "createdAt": "2023-11-15T15:53:01Z",
          "updatedAt": "2023-11-15T15:53:01Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @paulbastian:\r\n> This is the obvious solution going in the right direction. I'm not convinced yet that this is the ideal solution, especially in combination with DPoP. \r\n \r\nAgree with the direction and also unsureness around DPoP. There's a lot of overlap and duplicative text and functionality with DPoP in this nonce mechanism and the Client Attestation PoP JWT itself. A lot. It makes me question (again) if it wouldn't be better to use the DPoP Proof JWT as the PoP mechanism in this work rather than recreate so much of it with the Client Attestation PoP JWT. \r\n",
          "createdAt": "2023-11-16T18:17:25Z",
          "updatedAt": "2023-11-16T18:17:25Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bc-pi \r\n\"It makes me question (again) if it wouldn't be better to use the DPoP Proof JWT as the PoP mechanism in this work rather than recreate so much of it with the Client Attestation PoP JWT.\"\r\n\r\nThat ties two mechanisms together that were built for different purposes. I think that would make sense if client attestation would always be used with DPoP bound access tokens. That means: a) no client attestation without sender constrained access tokens and b) no mTLS for sender constrained access tokens when using client attestation. ",
          "createdAt": "2023-11-16T18:26:57Z",
          "updatedAt": "2023-11-16T18:26:57Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That ties two mechanisms together that were built for different purposes. \r\n\r\nThe [DPoP proof JWT ](https://www.rfc-editor.org/rfc/rfc9449.html#name-dpop-proof-jwts) part of RFC9449 was built exactly for the purpose of proving possession of a key in the context of an HTTP request. And can be used without necessarily binding access tokens. ",
          "createdAt": "2023-11-16T18:40:55Z",
          "updatedAt": "2023-11-16T18:40:55Z"
        },
        {
          "author": "pmhsfelix",
          "authorAssociation": "NONE",
          "body": ">@bc-pi\r\n>There's a lot of overlap and duplicative text and functionality with DPoP in this nonce mechanism and the Client Attestation PoP JWT itself. A lot. It makes me question (again) if it wouldn't be better to use the DPoP Proof JWT as the PoP mechanism in this work rather than recreate so much of it with the Client Attestation PoP JWT.\r\n\r\nAlso had the exact same feeling while writing the PR, namely the creation of a duplicate header and a duplicate OAuth error code. Using DPoP for the proof-of-possession did also cross my mind.\r\n\r\nWe could perhaps decouple the DPoP proof of possession JWT from the `DPoP` HTTP header. \r\nMy current understanding is that the `DPoP` header serves *two* purposes when used on a Token Request:\r\n- Convey a public key proof-of-possesion JWT.\r\n- Request the issued tokens to be bound to that public key.\r\nOTOH, when used on a Resource Server request, the `DPoP` header seems to only serve the first purpose.\r\n\r\nIf we want to use DPoP all the way, then this seems to work perfectly. \r\nHowever, if we don't want to bind the access tokens using DPoP, we could still use the DPoP proof of possession JWT but convey it in a different way (e.g. on the token request body or on a different header, instead of on the `DPoP` header). The `DPoP-nonce` and `use_dpop_nonce` could still be used to provide a fresher nonce.\r\n\r\n",
          "createdAt": "2023-11-16T19:04:01Z",
          "updatedAt": "2023-11-16T19:04:01Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> [...] if we don't want to bind the access tokens using DPoP, [...] \r\n\r\nDPoP itself specifically has text in the [DPoP Access Token Request](https://www.rfc-editor.org/rfc/rfc9449.html#name-dpop-access-token-request) section that [allows for an AS to issue access tokens that are not DPoP bound](https://www.rfc-editor.org/rfc/rfc9449.html#section-5-9). It says:\r\n\r\n> An authorization server MAY elect to issue access tokens that are not DPoP bound, which is signaled to the client with a value of Bearer in the token_type parameter of the access token response per [RFC6750].\r\n\r\nAnd this draft could certainly reiterate that, if it went with the DPoP proof as its PoP mechanism.\r\n\r\nThere is and has been (it's come up previously) a lot of resistance to that approach though. But maybe that resistance was from the misconception that DPoP usage at the token endpoint meant that access tokens had to be DPoP bound. ",
          "createdAt": "2023-11-16T21:44:44Z",
          "updatedAt": "2023-11-16T21:45:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> > [...] if we don't want to bind the access tokens using DPoP, [...]\r\n> \r\n> DPoP itself specifically has text in the [DPoP Access Token Request](https://www.rfc-editor.org/rfc/rfc9449.html#name-dpop-access-token-request) section that [allows for an AS to issue access tokens that are not DPoP bound](https://www.rfc-editor.org/rfc/rfc9449.html#section-5-9). It says:\r\n> \r\n> > An authorization server MAY elect to issue access tokens that are not DPoP bound, which is signaled to the client with a value of Bearer in the token_type parameter of the access token response per [RFC6750].\r\n> \r\n> And this draft could certainly reiterate that, if it went with the DPoP proof as its PoP mechanism.\r\n> \r\n> There is and has been (it's come up previously) a lot of resistance to that approach though. But maybe that resistance was from the misconception that DPoP usage at the token endpoint meant that access tokens had to be DPoP bound.\r\n\r\nAt least I'd failed to realise this language existed in DPoP and it feels like because of that I dont really see why we shouldn't consider using the DPoP format for the PoP, it feels both generalised enough for other endpoints AND doesn't mandate the tokens issued from the token endpoint are DPoP bound.",
          "createdAt": "2023-11-17T02:51:48Z",
          "updatedAt": "2023-11-17T02:51:48Z"
        },
        {
          "author": "pmhsfelix",
          "authorAssociation": "NONE",
          "body": "So we would use the DPoP token format *and* convey it via the `DPoP` header? Or just use the DPoP token format (and associated nonce management)?",
          "createdAt": "2023-11-17T16:46:00Z",
          "updatedAt": "2023-11-17T16:46:00Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm somehow hesitant to put everything in the headers.\n\nI think we should evaluate to reuse the key from the client attestation as a key for dpop binding and somehow reuse the nonce providing mechanism. As this is a major use case in mind, we should avoid sending multiple nonces, using multiple keys and proofs.",
          "createdAt": "2023-11-17T18:39:14Z",
          "updatedAt": "2023-11-17T18:39:14Z"
        },
        {
          "author": "ju-cu",
          "authorAssociation": "NONE",
          "body": "I also prefer reusing and building upon existing specs, i.e. DPoP (RFC 9449) and Assertion based client authentication (RFC 7521), over copying text. This spec already profiles RFC 7521 but could also use DPoP to satisfy the key-binding of the client attestation. Instead of concatenating two JWTs into a single assertion, the `client_assertion` parameter should hold a key-binding JWT, aka the client attestation JWT. The DPoP HTTP header holds the DPoP proof JWT that serves as the client attestation PoP JWT. In that way, there is no need to define the client attestation PoP JWT in this spec as it can just point to DPoP and use all the mechanisms defined there, including the nonce mechanism. A token request would look like this:\r\n\r\n```http\r\nPOST /token HTTP/1.1\r\nHost: as.example\r\nContent-Type: application/x-www-form-urlencoded\r\nDPoP: eyJ0eXAiOiJkcG9wK2p3dCIsImp3ayI6eyJhbGciOiJFUzI1NiIsImNydiI6IlAtMjU2Iiwia3R5IjoiRUMiLCJ4IjoiaThReW03NFRNUHVLQXVKUGlZczFSZlVsYTVjemNxelVobEpmRHNMdzd0NCIsInkiOiJGQjlUY2ZmeVZDSEpFQjJjejc4NTE2MUE0SmxlTkh2cG44bXhHRldZMlNjIn0sImFsZyI6IkVTMjU2In0.eyJqdGkiOiIzNTc2ODI5Ny1kZWM1LTQ2ZjYtODVlNS1iNzU4MjE2YWI1ZmYiLCJodG0iOiJQT1NUIiwiaHR1IjoiaHR0cHM6Ly9hcy5leGFtcGxlL3Rva2VuIiwiaWF0IjoxNzAwODEyODAwLCJub25jZSI6ImV5SjdTX3pHLmV5SkgwLVouSFg0dy03diJ9.5VuDrkd8RhMRaps_AzJBs2p-_UXXWT4dVHITBHiQxe31GeDq81otnIh3HBQN8_XjS1diHPq1tti1pn55eZdI5g\r\n\r\ngrant_type=authorization_code&\r\ncode=n0esc3NRze7LTCu7iYzS6a5acc3f0ogp4&\r\nclient_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-client-attestation&\r\nclient_assertion=eyJhbGciOiJSUzI1NiIsImtpZCI6IjIyIn0.eyJpc3Mi[...omitted for brevity...].cC4hiUPo[...omitted for brevity...]\r\n\r\n```\r\n\r\nwhere the DPoP proof JWT decodes as follows:\r\n```json\r\nJOSE Header\r\n{\r\n  \"typ\": \"dpop+jwt\",\r\n  \"jwk\" : {\r\n    \"alg\": \"ES256\",\r\n    \"crv\": \"P-256\",\r\n    \"kty\": \"EC\",\r\n    \"x\": \"i8Qym74TMPuKAuJPiYs1RfUla5czcqzUhlJfDsLw7t4\",\r\n    \"y\": \"FB9TcffyVCHJEB2cz785161A4JleNHvpn8mxGFWY2Sc\"\r\n   },\r\n  \"alg\": \"ES256\"\r\n}\r\n\r\nPayload\r\n{\r\n  \"jti\": \"35768297-dec5-46f6-85e5-b758216ab5ff\",\r\n  \"htm\": \"POST\",\r\n  \"htu\": \"https://as.example/token\",\r\n  \"iat\": \"1700812800\",\r\n  \"nonce\": \"eyJ7S_zG.eyJH0-Z.HX4w-7v\"\r\n}\r\n```\r\n\r\nNote, that the DPoP proof JWT MUST contain the `jwk` parameter in the JOSE header according to RFC 9449. In the context of client authentication as defined in this spec, the authorization server MUST use the public key from the `cnf` claim of the `client_assertion` to validate the DPoP proof. The authorization server MAY ignore the `jwk` parameter of the DPoP proof JWT.",
          "createdAt": "2023-11-24T08:21:29Z",
          "updatedAt": "2023-11-24T08:23:35Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ju-cu's description of how the DPoP proof JWT would serve as the client attestation PoP JWT is pretty much in line with how I'd envisioned it. Although I believe it'd need to be a bit less prescriptive about checking the confirmation/pop key and just say that the public key from the `cnf` of Client Attestation JWT must match the key of the `jwk` header of the DPoP proof JWT. This would allow for the _conventional_ processing order with DPoP where the DPoP proof JWT is validated first followed by binding to or checking the binding of things against the key of the DPoP proof JWT. \r\n\r\n",
          "createdAt": "2023-11-29T21:19:56Z",
          "updatedAt": "2023-11-29T21:19:56Z"
        },
        {
          "author": "pmhsfelix",
          "authorAssociation": "NONE",
          "body": "This conversation made me consider the following:\r\n- There is already [RFC 7523](https://www.rfc-editor.org/rfc/rfc7523.html) for **bearer** JWT-based client authentication (as a profile to [RFC 7521](https://www.rfc-editor.org/rfc/rfc7521)).\r\n- However, there isn't any standard for JWT-based client authentication using **holder-of-key** assertions instead of bearer, which is useful for high assurance scenarios.\r\n\r\nSo, what if, instead of having an attestation specific specification, this work was divided into two parts.\r\n- First, a \"sibling\" of RFC 7523 using **DPoP-based holder-of-key JWT assertions**. \r\n- Second, a set of attestation-specific claims, communicating extra attestation-specific information about the client to the AS.\r\n\r\nSeems a bit more work, but the result is also much more general: a mechanism for client authentication using JWT assertions with proof-of-possession, independent of attestation. And by using the DPoP specification, the proof-of-possession part could be relatively easier to specify.\r\n\r\nIf you think this is a conversation worth having, I can create an issue, since this isn't specifically related to this PR.",
          "createdAt": "2023-12-04T16:09:58Z",
          "updatedAt": "2023-12-04T16:09:58Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Please see #67 for a concrete proposal to shift to using DPoP as the PoP syntax for this client authentication method.",
          "createdAt": "2024-01-15T21:29:42Z",
          "updatedAt": "2024-01-15T21:29:42Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After giving it much thought, I realized that DPoP uses HTTP headers in HTTP requests, and consequently, it makes sense to obtain a nonce within the headers of the received HTTP responses.\r\n\r\nMeanwhile, the nonces we use in OAuth and for endpoint requests utilize GET or POST parameters, and the idea of forcibly using HTTP headers for nonce provisioning doesn't excite me.\r\n\r\nWe already have a nonce endpoint in IETF literature, for example in ACME (RFC8555), and with the aim of creating something highly specialized, reusable in other contexts, efficient, and scalable, I thought of this:\r\n\r\nhttps://github.com/peppelinux/draft-demarco-nonce-endpoint",
          "createdAt": "2024-02-04T00:46:40Z",
          "updatedAt": "2024-02-04T00:46:40Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "We had a discussion on this topic in today's editors call, I posted my thoughts here: https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/59#issuecomment-2304146071",
          "createdAt": "2024-08-22T09:02:39Z",
          "updatedAt": "2024-08-22T09:02:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5nM2UE",
          "commit": {
            "abbreviatedOid": "fa66a20"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-15T07:49:31Z",
          "updatedAt": "2023-11-15T07:49:32Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nThe Client MUST use this new nonce value to create a new Client Attestation PoP JWT and resend the previous request.\r\n```\r\n@pmhsfelix I'm wondering if using Client as defined term in OAuth 2.0. If yes this change is required within the entire text",
              "createdAt": "2023-11-15T07:49:31Z",
              "updatedAt": "2023-11-15T07:49:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5nNIHX",
          "commit": {
            "abbreviatedOid": "fa66a20"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2023-11-15T08:36:46Z",
          "updatedAt": "2023-11-15T08:36:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5nNG8r",
          "commit": {
            "abbreviatedOid": "fa66a20"
          },
          "author": "ju-cu",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "I suggest some normative language for the `nonce` syntax and HTTP error message. All in all good, so green light from me. ",
          "createdAt": "2023-11-15T08:33:54Z",
          "updatedAt": "2023-11-15T10:10:23Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nIn addition, a mismatch between the time reference of a client (e.g. a mobile device) and the time reference of the authorization server, may result in Client Attestation PoP JWT that are never accepted by the authorization server.\r\n```",
              "createdAt": "2023-11-15T08:33:54Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nIncluding a nonce value provided by the authorization server in the Client Attestation PoP JWT MAY be used by authorization servers to limit the lifetime of those proofs, both protecting against attacks and allowing for interoperability with clients with different time references.\r\n```\r\n\"provided\" because it maps the header.",
              "createdAt": "2023-11-15T08:36:55Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 30,
              "body": "Use formative language:\r\n\r\n```suggestion\r\nIf the authorization server requires the use of nonces, the authorization server MUST return an HTTP response with the `400` status and an `error` field with the value `\"use_attestation_nonce\"`, when the Client Attestation PoP JWT present in the HTTP request does not contain a valid nonce.\r\n```",
              "createdAt": "2023-11-15T08:39:18Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nThe server provided nonce must be included in the `nonce` JWT payload claim, as a string.\r\n```\r\nDoesn't \"JWT payload claim\" imply that the data is JSON?",
              "createdAt": "2023-11-15T08:42:15Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nAuthorization servers MAY also include the `Attestation-Nonce` in success responses, as a way to communicate newer nonce values to clients.\r\n```",
              "createdAt": "2023-11-15T08:43:02Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 50,
              "body": "```suggestion\r\nResponses that include the `Attestation-Nonce` HTTP header should be uncacheable (e.g., using `Cache-Control: no-store` in response to a GET request) to prevent returning cached, stale nonce values in subsequent requests.\r\n```",
              "createdAt": "2023-11-15T08:49:45Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 35,
              "body": "Repeating expression:\r\n```suggestion\r\nThe following non-normative example represents a non-success response, including the new nonce in the `Attestation-Nonce` header.\r\n```",
              "createdAt": "2023-11-15T08:51:51Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nThe following non-formative example shows a 200 OK response providing a new nonce value.\r\n```",
              "createdAt": "2023-11-15T08:54:20Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 66,
              "body": "I believe this sentence is missing a formative language. We may even add it above where the`nonce` claim is originally defined.\r\n",
              "createdAt": "2023-11-15T08:55:50Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5nVo7P",
          "commit": {
            "abbreviatedOid": "fa66a20"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "just editorial, consider it approved",
          "createdAt": "2023-11-16T07:59:42Z",
          "updatedAt": "2023-11-16T08:02:42Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nThis section outlines a method that utilizes server-generated opaque nonces to restrict the lifespan of a Client Attestation Proof of Possession (PoP) JWT., similar to the one defined in section 8 of {{RFC9449}}.\r\n```",
              "createdAt": "2023-11-16T07:59:43Z",
              "updatedAt": "2023-11-16T08:02:42Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nWithout this mechanism, a malicious entity, which could include the end-user, controlling the client can generate Client Attestation Proof of Possession (PoP) JWTs for unrestricted future use. Moreover, a discrepancy between the time reference of a benign client (like a mobile device) and the authorization server's time reference could lead to Client Attestation PoP JWTs that the authorization server never accepts.\r\n```",
              "createdAt": "2023-11-16T08:01:05Z",
              "updatedAt": "2023-11-16T08:02:42Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nThis requirement is communicated to the Client by having the authorization server return an HTTP response with the `400` status and an `error` field with the value `\"use_attestation_nonce\"`, when the Client Attestation PoP JWT present in the HTTP request does not contain a valid nonce.\r\n```",
              "createdAt": "2023-11-16T08:01:34Z",
              "updatedAt": "2023-11-16T08:02:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 65,
      "id": "PR_kwDOJaEkaM5gJfwG",
      "title": "Update draft-ietf-oauth-attestation-based-client-auth.md",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/65",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "affiliation status for IETF still unclear",
      "createdAt": "2023-11-22T16:04:05Z",
      "updatedAt": "2023-11-22T19:37:35Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "4375d894ce7e58c91d5ed282cfd733dd48417812",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "affiliation",
      "headRefOid": "edd6ad8fb1b66c78af04b121fb1102c2ba7a37ea",
      "closedAt": "2023-11-22T19:37:35Z",
      "mergedAt": "2023-11-22T19:37:35Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "efa100ca094afee2303275bd8f518b81c9a0c97a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5oBqUA",
          "commit": {
            "abbreviatedOid": "edd6ad8"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-22T19:37:30Z",
          "updatedAt": "2023-11-22T19:37:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 67,
      "id": "PR_kwDOJaEkaM5kIFOQ",
      "title": "feat: initial proposal to use dpop",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/67",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "**DRAFT PR FOR DISCUSSION**\r\n\r\n## \ud83d\udcd1 Description\r\n\r\nFollowing discussion across multiple issues and PR's including #59 and #64. This PR represents a draft proposal to use the DPoP HTTP Header as defined in [RFC9449](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop-16#name-the-dpop-http-header) instead of the client attestation pop.\r\n\r\n## Preview Link\r\n\r\n[click here for rendered preview of PR](https://vcstuff.github.io/draft-ietf-oauth-attestation-based-client-auth/tl/dpop-proof/draft-ietf-oauth-attestation-based-client-auth.html)",
      "createdAt": "2024-01-15T21:23:08Z",
      "updatedAt": "2024-03-28T03:02:34Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "efa100ca094afee2303275bd8f518b81c9a0c97a",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/dpop-proof",
      "headRefOid": "833eea8467ea257c1efdfa109546db2b14b46300",
      "closedAt": "2024-03-28T03:02:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A similar vision was brought by me here\r\n~https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/67/files~ sorry, wrong url, see: https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/issues/45\r\n\r\ngenerally I agree with this, however we still have an issue with DPoP, as explained below.\r\n\r\nThere are discussions about the requirement to provide more than a single wallet attestation in eIDAS.\r\nat the same time, for the purpose of a global standard, I see the requirement to provide a way to allow multiple client_assertion, where an ecosystem might require this, for future features.\r\n\r\nat the current stage, we can provide multiple client_assertion in a single url (see [this](https://github.com/openid/OpenID4VCI/issues/149)) providing their PoP. Using DPoP it is possible for HTTP to carry multiple headers with the same name. This is defined in the HTTP/1.1 specification (RFC 2616). According to the specification, multiple message-header fields with the same field-name may be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list. It must be possible to combine the multiple header fields into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma.\r\n\r\nhowever this approach doesn't give the binding of which PoP is related to which client attestation, requiring to the entity that evaluates assertions+pop to parse and validate them in a loop. This loop has computational costs that can be avoided by design, as the current specs allows.\r\n\r\nanother issue could be that HTTP Header maximum size configured in the httpd services could represent a limit where multiple DPoP are provided. Anyway I feel optimistic about each the DPoP payload size and the number of http headers parameters included in a single http request.\r\n\r\njust to be clear:\r\n\r\nI prefer DPoP and I love to reuse things without redefining new one.\r\nAt the same time the DPoP HTTP header doesn't give a proper mapping to the client assertion where multiple client assertion are provided. The real-world may require this and we should take the best decision in term of design\r\n\r\n",
          "createdAt": "2024-01-16T10:45:01Z",
          "updatedAt": "2024-01-18T07:57:59Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for doing the work on this @tplooker! I am very supportive of this direction. I do wonder if it'd be worthwhile to include some explanatory text with this change about the fact that use of a DPoP proof does not mandate bound access tokens? It was a point of confusion/contention in prior discussions (eg https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/64#issuecomment-1815362871, https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/64#issuecomment-1815668038, etc) which might benefit from a brief mention in this document. \r\n",
          "createdAt": "2024-01-16T14:47:10Z",
          "updatedAt": "2024-01-16T17:43:14Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I understand DPoP correctly, this proposals leads to a situation where authentication with an client attestation always leads to an access token bound to the public key in the 'cnf' claim of the attestation.  \r\n\r\nThis means, clients must always bind their access tokens and cannot use different keys for client authentication and the key binding of their access tokens. \r\n\r\nIs that correct? ",
          "createdAt": "2024-01-18T03:05:05Z",
          "updatedAt": "2024-01-18T03:05:05Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> If I understand DPoP correctly, this proposals leads to a situation where authentication with an client attestation always leads to an access token bound to the public key in the 'cnf' claim of the attestation.\r\n\r\nNo that is not entirely correct, as @bc-pi pointed out [in this comment](https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/64#issuecomment-1815362871) just because you are using a DPoP proof in the token request to convey the client attestation PoP doesn't mean a DPoP enabled access token has to be issued as a response. You are correct though that in the event a DPoP access token is issued, the access token will be bound to the one in the `cnf` claim of the client attestation which I personally find a useful simplification. What are the usecases for wanting a seperate key for client auth vs token binding (in the event it is used)?\r\n",
          "createdAt": "2024-01-18T05:12:48Z",
          "updatedAt": "2024-01-18T05:12:48Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am pretty strongly against this mechanism. I think it is ok to have this as an optimization but mandating using the same PoP for client attestation and DPoP overloads both mechanisms and limits the use-cases.\r\n\r\nPlease see my comment above to ensure you understand what we are proposing here, I don't think this significantly limits use cases and on the flip side it significantly reduces what needs to be defined in this draft. If you still feel the same can you please elaborate on which usecases you think this would limit?",
          "createdAt": "2024-01-18T05:14:55Z",
          "updatedAt": "2024-01-18T05:14:55Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is there any reaction about the potential requirement to provide multiple client assertions in a request and my previous comment, shown below:\r\n\r\n> however this approach doesn't give the binding of which PoP is related to which client attestation, requiring to the entity that evaluates assertions+(d)pop to parse and validate them in a loop. This loop has computational costs that can be avoided by design, as the current specs allows.",
          "createdAt": "2024-01-18T08:00:19Z",
          "updatedAt": "2024-01-18T08:00:19Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "> A similar vision was brought by me here ~https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/67/files~ sorry, wrong url, see: #45\r\n> \r\n> generally I agree with this, however we still have an issue with DPoP, as explained below.\r\n> \r\n> There are discussions about the requirement to provide more than a single wallet attestation in eIDAS. at the same time, for the purpose of a global standard, I see the requirement to provide a way to allow multiple client_assertion, where an ecosystem might require this, for future features.\r\n> \r\n> at the current stage, we can provide multiple client_assertion in a single url (see [this](https://github.com/openid/OpenID4VCI/issues/149)) providing their PoP. Using DPoP it is possible for HTTP to carry multiple headers with the same name. This is defined in the HTTP/1.1 specification (RFC 2616). According to the specification, multiple message-header fields with the same field-name may be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list. It must be possible to combine the multiple header fields into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma.\r\n> \r\n> however this approach doesn't give the binding of which PoP is related to which client attestation, requiring to the entity that evaluates assertions+pop to parse and validate them in a loop. This loop has computational costs that can be avoided by design, as the current specs allows.\r\n> \r\n> another issue could be that HTTP Header maximum size configured in the httpd services could represent a limit where multiple DPoP are provided. Anyway I feel optimistic about each the DPoP payload size and the number of http headers parameters included in a single http request.\r\n> \r\n> just to be clear:\r\n> \r\n> I prefer DPoP and I love to reuse things without redefining new one. At the same time the DPoP HTTP header doesn't give a proper mapping to the client assertion where multiple client assertion are provided. The real-world may require this and we should take the best decision in term of design\r\n\r\nHi Giuseppe,\r\nthe proposed idea in the eIDAS discussion EPIC-09 is the wrong way. Currently client attestation supports one attestation and that's the way it should stay. I have outlined my position here: https://github.com/openid/OpenID4VCI/issues/215",
          "createdAt": "2024-01-18T10:06:40Z",
          "updatedAt": "2024-01-18T10:06:40Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> No that is not entirely correct, as @bc-pi pointed out [in this comment](https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/64#issuecomment-1815362871) just because you are using a DPoP proof in the token request to convey the client attestation PoP doesn't mean a DPoP enabled access token has to be issued as a response.\n\nThe text @bc-pi is referring to leaves it at the discretion of the AS to decide whether the access token is key bound. How would the client influence that decision?",
          "createdAt": "2024-01-18T10:54:49Z",
          "updatedAt": "2024-01-18T10:59:26Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> The text @bc-pi is referring to leaves it at the discretion of the AS to decide whether the access token is key bound. How would the client influence that decision?\r\n\r\nI think that is a general question for DPoP, but one that is important to answer. If by influence you mean the client is able to communicate to the AS that it supports dpop bound access tokens then I would agree, but at the end of the day the decision as to whether to issue a DPop enabled access token is still always at the discretion of the AS. With regard to how this would be achieved practically I would assume client metadata is the most effective way for the client to communicate this and [Section 5.2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop-16#section-5.2) has the `dpop_bound_access_tokens` element registered. Although the definition for this parameter might not intuitively appear to fit, I think the intended normative requirements on the AS do? Specifically this statement which applies to this metadata elements value:\r\n\r\n> If true, the authorization server MUST reject token requests from this client that do not contain the DPoP header.\r\n\r\nAlternatively if we don't think this is sufficient perhaps we can consider registering a new client metadata element.\r\n\r\nPerhaps @bc-pi you have some further thoughts on this?",
          "createdAt": "2024-01-18T20:19:33Z",
          "updatedAt": "2024-01-18T20:19:33Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is there really a reason the client would need to influence that decision? I'd imagine the AS would issue the access token based on expectations/knowledge of the RS(s) it's intended for. ",
          "createdAt": "2024-01-19T20:22:35Z",
          "updatedAt": "2024-01-19T20:22:35Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is there really a reason the client would need to influence that decision? I'd imagine the AS would issue the access token based on expectations/knowledge of the RS(s) it's intended for.\r\n\r\nWith the current revision of the spec (before this PR), a client can use an attestation to just authenticate. If it wants a DPoP bound access token, it would add a DPoP header to the request. With the proposal in this PR, this is no longer possible. This effectively means every client using client attestation must also implement DPoP and use it if the AS decides the access token must be key bound. \r\n\r\nAlso, the client does not have a choice to use different keys for attestation and DPoP. I could think of situations where the DPoP key is managed in a local security module to achieve better performance for subsequent API calls whereas the client attestation key lives in a remote HSM for higher security, which adds significant latency to every signing operation. With the new proposal, the application's performance would suffer simply because any API call might also require a remote signing operation for the DPoP proof. \r\n\r\nAlso, I would like to understand whether the proposed approach would work with PAR. We will most likely need attestation based client authentication at the PAR endpoint. I assume the DPoP header would be used to perform the authentication only. Is that correct?",
          "createdAt": "2024-01-20T01:02:55Z",
          "updatedAt": "2024-01-20T01:02:55Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n>\r\n> With the current revision of the spec (before this PR), a client can use an attestation to just authenticate. If it wants a DPoP bound access token, it would add a DPoP header to the request. With the proposal in this PR, this is no longer possible. This effectively means every client using client attestation must also implement DPoP and use it if the AS decides the access token must be key bound.\r\n\r\nTrue but ultimately the need to use key bound access token comes from the RS so the client would have to already be capable. I don't think it'd really be an issue in practice. But maybe I'm wrong. Some sort of signaling could be added to this - metadata as Tobias mentioned or a new claim in the DPoP proof or similar. \r\n\r\n> \r\n> Also, the client does not have a choice to use different keys for attestation and DPoP. I could think of situations where the DPoP key is managed in a local security module to achieve better performance for subsequent API calls whereas the client attestation key lives in a remote HSM for higher security, which adds significant latency to every signing operation. With the new proposal, the application's performance would suffer simply because any API call might also require a remote signing operation for the DPoP proof.\r\n\r\nIt is true that this PR doesn't allow the client to use of different keys for attestation and DPoP. I don't know if the kind of scenario you describe is likely enough to warrant the extra complexity of requiring two proofs in the other more common and simpler cases. I tend to aim for simplicity as much as possible/appropriate. \r\n\r\n> \r\n> Also, I would like to understand whether the proposed approach would work with PAR. We will most likely need attestation based client authentication at the PAR endpoint. I assume the DPoP header would be used to perform the authentication only. Is that correct?\r\n\r\nIt would work with PAR the same as at the token endpoint as far as I understand it. The authz code would be key bound as a result too but that'd be invisible to the client who anyway needs to present the same attestation auth and proof when subsequently exchange that auth code. So it'd just work while adding a bit of extra security to the code. \r\n",
          "createdAt": "2024-01-21T16:37:11Z",
          "updatedAt": "2024-01-21T16:37:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> With the current revision of the spec (before this PR), a client can use an attestation to just authenticate. If it wants a DPoP bound access token, it would add a DPoP header to the request. With the proposal in this PR, this is no longer possible. This effectively means every client using client attestation must also implement DPoP and use it if the AS decides the access token must be key bound.\r\n\r\nI think the most important point here is highlighted by @bc-pi. In the situation where the AS requires DPoP bound access tokens as per an RS policy, whether we use the DPoP proof syntax in this spec or not, it doesn't change the fact that the client won't be able to get an access token it can actually use with the RS.\r\n\r\nThe only potential gap I see (which I think is highly unlikely) is in the event a client supports this client authentication method, but doesn't support DPoP access tokens AND the RS + AS supports both DPoP and bearer based access tokens, the situation could arise where the client might be sent back a DPoP access token (based on the DPoP header implying support in the token request) which it can't use, when it could have been sent a bearer token. Again as I said above, I find this situation highly unlikely, but I think it could be easily resolved through additional client metadata.\r\n\r\n> Also, the client does not have a choice to use different keys for attestation and DPoP. I could think of situations where the DPoP key is managed in a local security module to achieve better performance for subsequent API calls whereas the client attestation key lives in a remote HSM for higher security, which adds significant latency to every signing operation. With the new proposal, the application's performance would suffer simply because any API call might also require a remote signing operation for the DPoP proof.\r\n\r\nI'm also wary as to how common this use case is and whether the complexity it creates is justifiable. To play the devils advocate, this proposal as it currently stands creates an efficient way (when DPoP access tokens are used), to authenticate that the key the DPoP access token will be bound to, is clearly authenticated back to the client (through the client attestation). If instead we want to continue to support different keys for client authentication and DPoP token binding, the question then becomes how do we get the same assurance e.g that the DPoP key is authenticated for the client? The client attestation PoP, to use the terminology pre this PR would have to somehow reference and authenticate the seperate DPoP key. \r\n\r\n> It would work with PAR the same as at the token endpoint as far as I understand it. The authz code would be key bound as a result too but that'd be invisible to the client who anyway needs to present the same attestation auth and proof when subsequently exchange that auth code. So it'd just work while adding a bit of extra security to the code.\r\n\r\nThis is my understanding too.",
          "createdAt": "2024-01-21T21:46:00Z",
          "updatedAt": "2024-01-21T21:46:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "As a consequence of discussing some of the advantages this PR brings, a new usecase/requirement surfaced which has been captured in PR #69",
          "createdAt": "2024-01-26T03:42:09Z",
          "updatedAt": "2024-01-26T20:12:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favour of #74 ",
          "createdAt": "2024-03-28T03:02:34Z",
          "updatedAt": "2024-03-28T03:02:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5ssQM7",
          "commit": {
            "abbreviatedOid": "d963646"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-16T14:19:03Z",
          "updatedAt": "2024-01-16T14:19:03Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "typo fix\r\n```suggestion\r\n2. The DPoP proof JWT present in the DPoP HTTP header MUST be valid in all other respects per the processing rules defined in {{RFC9449}}.\r\n```",
              "createdAt": "2024-01-16T14:19:03Z",
              "updatedAt": "2024-01-16T14:19:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ssXYo",
          "commit": {
            "abbreviatedOid": "d963646"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-16T14:27:04Z",
          "updatedAt": "2024-01-16T14:27:04Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "What is/was the reason behind this recommendation? I suspect many/most ASs typically do processing of the DPoP proof header first followed by 'application' layer stuff like binding to or checking the binding of other artifacts against the key of the DPoP proof JWT. I'd like to avoid a recommendation against the likely conventional processing pipeline unless there's a concrete reason for it. \r\n\r\n```suggestion\r\n```",
              "createdAt": "2024-01-16T14:27:04Z",
              "updatedAt": "2024-01-16T14:27:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ssbMm",
          "commit": {
            "abbreviatedOid": "d963646"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-16T14:31:45Z",
          "updatedAt": "2024-01-16T14:31:45Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "previously missing word?\r\n\r\n```suggestion\r\n4. The JWT MUST contain an \"cnf\" claim conforming to {{RFC7800}} that conveys the key to be used for producing the DPoP HTTP header for client authentication with an authorization server. The key MUST be expressed using the \"jwk\" representation.\r\n```",
              "createdAt": "2024-01-16T14:31:45Z",
              "updatedAt": "2024-01-16T14:31:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5s4TO3",
          "commit": {
            "abbreviatedOid": "d963646"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I am pretty strongly against this mechanism. I think it is ok to have this as an optimization but mandating using the same PoP for client attestation and DPoP overloads both mechanisms and limits the use-cases.",
          "createdAt": "2024-01-17T08:01:38Z",
          "updatedAt": "2024-01-17T08:01:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5tCUXP",
          "commit": {
            "abbreviatedOid": "3b845b9"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I have discussed this with my colleagues and we came to the following conclusions:\r\n\r\n## status quo:\r\n\r\npreparation: potentially fetch 2x nonce\r\nToken Request: client_attestation + client_attestation_pop + Dpop proof header\r\nToken Response: Dpop-bound access token\r\n\r\n## proposed:\r\n\r\npreparation: potentially fetch 1x nonce\r\nToken Request: client_attestation + Dpop proof header (client_attestation.cnf == Dpop.header.jwk)\r\nToken Response: Dpop-bound access token\r\n\r\n## con:\r\n- concepts are tightly coupled, key must be the same if both concepts want to be used, may have unforeseeable disadvantages\r\n- benefits in auth code flow are unclear if I would use client attestation at PAR endpoint\r\n- jwk present in the client attestation JWT is duplicated to jwk header in Dpop proof\r\n- refresh tokens are automatically dpop-bound?\r\n\r\n## pro: \r\n- only fetch 1x nonce\r\n- do one less key/PoP operation / generate one less key\r\n- wallet attestation makes only sense when coupled with Dpop currently\r\n- leverage better assurance of client_attestation key for Dpop (may be hw-bound)\r\n- draft may leverage the Dpop nonce fetching (although its ugly ;) ) -> may avoid https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/64\r\n\r\nFor me, the advantages are bigger, so I'm **supportive** of this. But I would like to get more feedback and understand @Sakurann concerns. Also, some more editorial work may be needed",
          "createdAt": "2024-01-18T10:12:01Z",
          "updatedAt": "2024-01-18T10:12:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5tqQzg",
          "commit": {
            "abbreviatedOid": "d963646"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-23T19:48:09Z",
          "updatedAt": "2024-01-23T19:48:10Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "As suggested by the diff, I really just updated the language in this particular section from s/Client Attestation PoP/DPoP HTTP header. I'm ok with removing this recommendation based on your feedback.",
              "createdAt": "2024-01-23T19:48:09Z",
              "updatedAt": "2024-01-23T19:48:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5t5Rtg",
          "commit": {
            "abbreviatedOid": "833eea8"
          },
          "author": "awoie",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "I'm also supportive of this PR since it simplifies things since I'm unclear about the use cases for which the proposed approach won't work. It is actually a good higher assurance enforcing function.",
          "createdAt": "2024-01-25T13:19:02Z",
          "updatedAt": "2024-01-25T13:21:15Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I don't think the second sentence is necessary since it is implied by the former sentence.\r\n```suggestion\r\nThe value of the \"client_assertion\" parameter contains a single JWT known as the client attestation JWT as defined defined in [](#client-attestation-jwt).\r\n```",
              "createdAt": "2024-01-25T13:19:02Z",
              "updatedAt": "2024-01-25T13:19:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5t9tqr",
          "commit": {
            "abbreviatedOid": "833eea8"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-26T00:00:17Z",
          "updatedAt": "2024-01-26T00:00:17Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I think we would want this constraint wouldn't we? Why would you like to remove it?",
              "createdAt": "2024-01-26T00:00:17Z",
              "updatedAt": "2024-01-26T00:00:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5uRGQH",
          "commit": {
            "abbreviatedOid": "833eea8"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-29T23:45:43Z",
          "updatedAt": "2024-01-29T23:45:43Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Didn't read your original comment just the suggestion, while I agree I think this makes the normative requirement a little more explicit. I took the language structure from [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523#section-2.2)\r\n\r\n> The value of the \"client_assertion\" parameter contains a single JWT.\r\n   It MUST NOT contain more than one JWT.\r\n\r\nI'm ok with removing this additional sentence though.",
              "createdAt": "2024-01-29T23:45:43Z",
              "updatedAt": "2024-01-29T23:45:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 74,
      "id": "PR_kwDOJaEkaM5q_2E4",
      "title": "feat: initial proposal to use http headers",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/74",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "## \ud83d\udcd1 Description\r\n\r\nBased on the discussions had at IETF 119 in the OAuth WG, this PR attempts to make the following changes to the draft\r\n\r\n- Move away from usage of the assertion framework defined in RFC 7521 and RFC 7523 for conveying the client attestation and client attestation pop.\r\n- Instead use two newly defined HTTP headers OAuth-Client-Attestation and OAuth-Client-Attestation-PoP for conveyance in an HTTP request, akin to how DPoP works.\r\n- Explicitly mention this mechanism could be used in a variety of places including with a resource server.\r\n\r\nNote, there are still many outstanding items I would like to add, however I felt this PR was already big enough as it is, these include\r\n\r\n- Error responses for the token endpoint #73\r\n- Optimisation for when this mechanism is used with DPoP to avoid having to send two PoP's\r\n- Formalising whether this mechanism still constitutes a form of client authentication",
      "createdAt": "2024-03-28T01:21:01Z",
      "updatedAt": "2024-05-29T06:45:30Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "ac2eec4c4bcc3e206aca6df55910e5dc40da2eac",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/header-syntax-proposal",
      "headRefOid": "c6bdd4c68242841db67e999cd3fcdf96c712c717",
      "closedAt": "2024-05-29T06:45:25Z",
      "mergedAt": "2024-05-29T06:45:25Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "2b711a053edd47a06be903cd116a3996dd689a5f"
      },
      "comments": [
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "For some reason it seems to not create an html version?\r\n\r\nThis is the rendered text:\r\nhttps://vcstuff.github.io/draft-ietf-oauth-attestation-based-client-auth/tl/header-syntax-proposal/draft-ietf-oauth-attestation-based-client-auth.txt\r\n",
          "createdAt": "2024-03-28T06:36:38Z",
          "updatedAt": "2024-03-28T06:36:38Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "I think there were potential objections mentioned about moving to headers as to whether we'd run into size limits (I think 8 KB was mentioned as a common restriction) and people felt jwts with embedded x5c headers etc may get close to these limits?",
          "createdAt": "2024-03-28T12:58:31Z",
          "updatedAt": "2024-03-28T12:58:31Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@jogu indeed. We may have a client attestation with an huge x509 certificate chain or an openid federation trust chain with several metadata, trust marks and jwks. \r\n\r\nI don't see the benefit of moving from what it is actually more efficient (wa~wa-pop)\r\n\r\nmore over, technically we can have multiple client_assertions that embedes their pop (using ~), while having multiple http headers that divide attestation from pop forces the implementations to loop all the assertions and all the pop to find the matching ones",
          "createdAt": "2024-03-28T16:28:44Z",
          "updatedAt": "2024-03-28T16:28:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Added client instance definition and updated to use US based spelling of authorization instead of authorisation.",
          "createdAt": "2024-04-03T19:03:16Z",
          "updatedAt": "2024-04-03T19:03:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "@jogu @peppelinux I can understand the desire to want to use X.509 certificates to validate the client assertion (e.g as an alternative key resolution mechanism to resolving a JWKS document from a domain), however I don't see how the certificate chain would be more then 1 certificate (maybe 2) in length (bearing in mind the root certificate(s) would be communicated to the issuer out of band and pre-trusted for the client). W.r.t other aspects of the client attestation or client attestation pop being too big for an HTTP header could you elaborate on what you see as the contents of your attestation @peppelinux? Because IIUC you perhaps want to use the client attestation to convey all client metadata? If that is the case IMO the client attestation isn't for this purpose, client metadata should continue to be communicated outside of these attestations with the pre-existing mechanisms we already have defined.\r\n\r\nFinally even if we did begin to encroach on header payload limits with a client attestation, we aren't talking about hard limits here, rather just the default maximums that common web server platforms have configured, which can always be adjusted. ",
          "createdAt": "2024-04-03T19:10:52Z",
          "updatedAt": "2024-04-03T19:10:52Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "there some point for clarification\r\n\r\n1. assertion weight: a client assertion may have a x5c or an openid federation trust chain within its JWT header. This is an issuer's choice, allowed by RFC 7515 that might be not supported by httpd maximum header body size, that's a deployment/configuration choice that might be different within different domains.\r\n2. chain length: it could be assumed that a chain may not exceed 2 or 3 certificate breaks. This depends on the number of intermediates, an aspect that falls outside the technical specification and is determined by the federation's topology and composition.\r\n3. client metadata: we have some required claims in the wallet attestations and the possibility to include any other custom claim or any other claims pertaining the wallet capabilities or anything else related to the trust framework. My comment is not related to assertion payload, but to the previous point 1 and 2. However, the payload also impacts in the assertion weight, as pointed out at point 1.\r\n\r\nThe missing point concerns the processing of multiple DPoP tokens within the same request. Handling multiple DPoP tokens necessitates a loop to identify the one that matches a specific assertion. This introduces additional computational and development efforts not present in the current approach (WA~WA-POP), which directly associates an assertion with its proof of possession (PoP), facilitating a straightforward and efficient identification of matching pairs.",
          "createdAt": "2024-04-04T05:47:19Z",
          "updatedAt": "2024-04-04T05:49:22Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> assertion weight: a client assertion may have a x5c or an openid federation trust chain within its JWT header. This is an issuer's choice, allowed by RFC 7515 that might be not supported by httpd maximum header body size, that's a deployment/configuration choice that might be different within different domains.\r\n\r\nOk great so do we agree that this isn't an issue because servers are freely able to re-configure the max header size based on their application? Because it isn't a hard limit.",
          "createdAt": "2024-04-05T03:04:37Z",
          "updatedAt": "2024-04-05T03:04:37Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> chain length: it could be assumed that a chain may not exceed 2 or 3 certificate breaks. This depends on the number of intermediates, an aspect that falls outside the technical specification and is determined by the federation's topology and composition.\r\n\r\nUnderstood but based on the above point is this actually an issue if the limit on header size isn't a hard limit?",
          "createdAt": "2024-04-05T03:05:12Z",
          "updatedAt": "2024-04-05T03:05:12Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> The missing point concerns the processing of multiple DPoP tokens within the same request. Handling multiple DPoP tokens necessitates a loop to identify the one that matches a specific assertion. This introduces additional computational and development efforts not present in the current approach (WA~WA-POP), which directly associates an assertion with its proof of possession (PoP), facilitating a straightforward and efficient identification of matching pairs.\r\n\r\nRight but to be clear, the current draft does not handle multiple wallet attestations either though so I think this a new requirement that we should discuss separately, would you mind opening a seperate issue?",
          "createdAt": "2024-04-05T03:06:36Z",
          "updatedAt": "2024-04-05T03:06:53Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The issue extends beyond the realm of multiple wallet attestations, as there could also be multiple DPoP tokens involved.\r\n\r\nAn additional consideration, which we have not yet fully addressed but may emerge as a future requirement, is the scenario where a wallet instance operates under more than one trust framework, necessitating specialized assertions for each. While we have consciously chosen to limit the scope to a single wallet attestation to simplify implementation, it's important to acknowledge that this decision does not preclude the possibility of requiring multiple assertions in the future. Implementers may need to adapt or extend the specification to accommodate such needs. However, to avoid digressing further, let's focus on the matter of handling multiple DPoP headers for now.\r\n\r\nThe approach currently documented, which aims to streamline the process by limiting it to a single attestation, is designed to offer the same benefits while minimizing computational overhead.",
          "createdAt": "2024-04-05T07:08:00Z",
          "updatedAt": "2024-04-05T07:08:00Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "> > assertion weight: a client assertion may have a x5c or an openid federation trust chain within its JWT header. This is an issuer's choice, allowed by RFC 7515 that might be not supported by httpd maximum header body size, that's a deployment/configuration choice that might be different within different domains.\r\n> \r\n> Ok great so do we agree that this isn't an issue because servers are freely able to re-configure the max header size based on their application? Because it isn't a hard limit.\r\n\r\nWhile it is possible to reconfigure these options, it is important to keep default values of the wide-spread implementations in mind to allow an easy path for adoption.\r\n\r\nI took the time to look at some of the frameworks I would say are good indicators:\r\n- nginx: [link](https://nginx.org/en/docs/http/ngx_http_core_module.html#large_client_header_buffers) --> 8KB for 1 header max\r\n- envoy (used in istio): [link](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto) --> 60 KB for headers\r\n- node.js: [link](https://nodejs.org/api/http.html#httpmaxheadersize)  --> 16KB for headers\r\n- traefik: [link](https://github.com/traefik/traefik/issues/8846) --> re-uses go/http: 1MB for headers\r\n\r\n--> After looking at this, I would say we can go with headers",
          "createdAt": "2024-04-05T07:33:39Z",
          "updatedAt": "2024-04-05T07:33:39Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An OpenID Federation trust chain with two intermediates, the trust anchor entity configuration with a long list of trust mark issuers and the leaf entity configuration with a very verbose configuration, such as an AS + Openid4VCI + OpenID4VP (considering an EAA provider), with policies and a consistent number of trust mark might be 20KB.\r\n\r\nA serialized X.509 certificate chain, with 4 intermediates, custom extensions and QWACs ... Considering each certificate up to 2.2KB, might it be 8.8KB? \r\n\r\n(please, consider that openid federation brings policy languages, trust marks and multiple protocol specific metadata)\r\n\r\nI'm worried about these aspects:\r\n\r\n1. loop required for parse/matching the correct DPoP when multiple DPoP are present, while WIA~WIA-POP doesn't bring this problem. What's the benefit of having this breaking change that reduce the flexibility while increasing the complexity?\r\n2. size limitations: Do we have to imagine to standardize something upon the assumption that a federation topology should not have more than 2 or 4 or 8 intermediates, since this decision is out of scope on this specification.\r\n\r\n\r\n",
          "createdAt": "2024-04-05T08:57:18Z",
          "updatedAt": "2024-04-05T08:59:16Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "A bit off-topic for the current discussion:\r\nWe need to fix the examples - they are way too long which breaks the rendering/conversion and will cause problems with the datatracker. I do believe that this is also the reason why the html file was not created.",
          "createdAt": "2024-04-05T14:04:43Z",
          "updatedAt": "2024-04-05T14:05:20Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that rfc9449 does not allow for multiple DPoP headers. It could maybe have been stated more clearly but is kinda implied and was absolutely the intent of the RFC overall and specific text like https://www.rfc-editor.org/rfc/rfc9449.html#section-4.3-2.2",
          "createdAt": "2024-04-05T16:25:54Z",
          "updatedAt": "2024-04-05T16:25:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> loop required for parse/matching the correct DPoP when multiple DPoP are present, while WIA~WIA-POP doesn't bring this problem. What's the benefit of having this breaking change that reduce the flexibility while increasing the complexity?\r\n\r\n@peppelinux as I implied with my earlier comment, the current draft text doesn't support multiple attestations so I don't view this proposal to shift to headers as removing functionality, it appears this is a new usecase and I think we should discuss it in a seperate issue.\r\n\r\n> size limitations: Do we have to imagine to standardize something upon the assumption that a federation topology should not have more than 2 or 4 or 8 intermediates, since this decision is out of scope on this specification.\r\n\r\nNo I dont think we do, what was identified above is that there is no size limit on headers in HTTP rather defaults that servers apply which can be adjusted, in reality web servers also apply limits to the body of an HTTP request (although often much larger then what is allocated for headers).",
          "createdAt": "2024-04-07T21:31:10Z",
          "updatedAt": "2024-04-07T21:31:10Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed with @paulbastian, I will add an implementation consideration around the default size limits for HTTP headers.",
          "createdAt": "2024-04-15T17:10:18Z",
          "updatedAt": "2024-04-15T17:10:18Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tplooker what about using compressed values?\r\n\r\nunfortunately this sounds like giving a solution that may bring other problems, at the same time we can consider zlib (RFC 1950) for doing this.",
          "createdAt": "2024-04-15T17:25:42Z",
          "updatedAt": "2024-04-15T17:25:42Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "Something broke with linking the html rendered versions properly\r\n\r\nRendered html: https://vcstuff.github.io/draft-ietf-oauth-attestation-based-client-auth/tl/header-syntax-proposal/draft-ietf-oauth-attestation-based-client-auth.html\r\n",
          "createdAt": "2024-05-16T09:10:19Z",
          "updatedAt": "2024-05-16T09:10:19Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It just (re)occurred to me that specs defining new HTTP headers (which the cool kids call fields nowadays) are supposed to request their registration in the [Hypertext Transfer Protocol (HTTP) Field Name Registry](https://www.iana.org/assignments/http-fields/http-fields.xhtml). I don't want to hold up this PR for this but will create an issue from this comment so as not to lose track of it. ",
          "createdAt": "2024-05-21T16:47:04Z",
          "updatedAt": "2024-05-21T16:47:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM51lZKj",
          "commit": {
            "abbreviatedOid": "5c172ff"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T06:37:19Z",
          "updatedAt": "2024-04-02T06:37:19Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Add Client Instance as a term",
              "createdAt": "2024-04-02T06:37:19Z",
              "updatedAt": "2024-04-02T06:37:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM51lbAj",
          "commit": {
            "abbreviatedOid": "5c172ff"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T06:41:28Z",
          "updatedAt": "2024-04-02T06:41:28Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Add Motivation, public clients need to authenticate etc..\r\nthis spec for authenticating client instances of public clients",
              "createdAt": "2024-04-02T06:41:28Z",
              "updatedAt": "2024-04-02T06:42:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM51lc32",
          "commit": {
            "abbreviatedOid": "5c172ff"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T06:44:33Z",
          "updatedAt": "2024-04-02T06:44:33Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "add that this can be used as client authentication mechanisms for the AS",
              "createdAt": "2024-04-02T06:44:33Z",
              "updatedAt": "2024-04-02T06:44:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM51uA_Y",
          "commit": {
            "abbreviatedOid": "5c172ff"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T20:47:02Z",
          "updatedAt": "2024-04-02T20:47:02Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "and Authorization rather than Authorisation (sorry, but for consistency with all the other OAuth RFCs that use that spelling) ",
              "createdAt": "2024-04-02T20:47:02Z",
              "updatedAt": "2024-04-02T20:47:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM51uBm-",
          "commit": {
            "abbreviatedOid": "5c172ff"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T20:47:57Z",
          "updatedAt": "2024-04-02T20:47:58Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nThis draft introduces the concept of client attestations to the OAuth 2 protocol, which consists of two JWT's, a Client Attestation and Client Attestation PoP, which are conveyed via HTTP headers in an HTTP request sent by a client to an Authorization Server or Resource Server. The purpose of these headers is to authenticate or attest to the Client Instance.\r\n```",
              "createdAt": "2024-04-02T20:47:57Z",
              "updatedAt": "2024-04-02T20:47:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM53UOm_",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-15T17:33:11Z",
          "updatedAt": "2024-04-15T17:33:12Z",
          "comments": [
            {
              "originalPosition": 196,
              "body": "```suggestion\r\n\r\nImplementers should consider the technical limitations of header sizes of the deployed web servers. If the Client Attestations size is becoming large, e.g. a `x5c` header containing multiple certificates with RSA keys as a trust mechanism, web server implementations receiving the HTTP request could fail as the header does not fit into the buffer dedicated for the HTTP headers. It shall be noted, that this limit is not given by the HTTP standard, but only by the technical implementations. As of 2024, typical limits for HTTP headers is 8 kB or above, which seems sufficient. \r\n```",
              "createdAt": "2024-04-15T17:33:12Z",
              "updatedAt": "2024-04-15T17:33:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM53VHjo",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-15T19:48:27Z",
          "updatedAt": "2024-04-15T19:48:27Z",
          "comments": [
            {
              "originalPosition": 196,
              "body": "```suggestion\r\n\r\n### Web Server Default Maximum HTTP Header Sizes\r\n\r\nBecause the Client Attestation and Client Attestation PoP are communicated using HTTP headers, implementers should consider that web servers may have a default maximum HTTP header size configured which could be too low to allow conveying a Client Attestation and or Client Attestation PoP in an HTTP request. It should be noted, that this limit is not given by the HTTP {{RFC9112}}, but instead web server implementations commonly set a default maximum size for HTTP headers. As of 2024, typical limits for modern web servers configure maximum HTTP headers as 8 kB or more as a default.\r\n```",
              "createdAt": "2024-04-15T19:48:27Z",
              "updatedAt": "2024-04-16T21:05:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM53bu1g",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-16T14:04:52Z",
          "updatedAt": "2024-04-16T14:04:52Z",
          "comments": [
            {
              "originalPosition": 196,
              "body": "I don't think that \"which seems sufficient\" should be included.",
              "createdAt": "2024-04-16T14:04:52Z",
              "updatedAt": "2024-04-16T14:04:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM53dROK",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "This should hopefully fix the rendering",
          "createdAt": "2024-04-16T16:47:23Z",
          "updatedAt": "2024-04-16T16:52:49Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nOAuth-Client-Attestation: eyJhbGciOiAiRVMyNTYiLCJraWQiOiAiMTEifQ.eyJ\\\r\npc3MiOiJodHRwczovL2NsaWVudC5leGFtcGxlLmNvbSIsInN1YiI6Imh0dHBzOi8vY2x\\\r\npZW50LmV4YW1wbGUuY29tIiwibmJmIjoxMzAwODE1NzgwLCJleHAiOjEzMDA4MTkzODA\\\r\nsImNuZiI6eyJqd2siOnsia3R5IjoiRUMiLCJ1c2UiOiJzaWciLCJjcnYiOiJQLTI1NiI\\\r\nsIngiOiIxOHdITGVJZ1c5d1ZONlZEMVR4Z3BxeTJMc3pZa01mNko4bmpWQWlidmhNIiw\\\r\nieSI6Ii1WNGRTNFVhTE1nUF80Zlk0ajhpcjdjbDFUWGxGZEFnY3g1NW83VGtjU0EifX1\\\r\n9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\r\n```",
              "createdAt": "2024-04-16T16:47:23Z",
              "updatedAt": "2024-04-16T16:52:49Z"
            },
            {
              "originalPosition": 102,
              "body": "```suggestion\r\nOAuth-Client-Attestation-PoP: eyJhbGciOiJFUzI1NiJ9.eyJpc3MiOiJodHRwc\\\r\nzovL2NsaWVudC5leGFtcGxlLmNvbSIsImF1ZCI6Imh0dHBzOi8vYXMuZXhhbXBsZS5jb\\\r\n20iLCJuYmYiOjEzMDA4MTU3ODAsImV4cCI6MTMwMDgxOTM4MH0.coB_mtdXwvi9RxSMz\\\r\nbIey8GVVQLv9qQrBUqmc1qj9Bs\r\n```",
              "createdAt": "2024-04-16T16:48:03Z",
              "updatedAt": "2024-04-16T16:52:49Z"
            },
            {
              "originalPosition": 182,
              "body": "```suggestion\r\nPOST /token HTTP/1.1\r\nHost: as.example.com\r\nContent-Type: application/x-www-form-urlencoded\r\nOAuth-Client-Attestation: eyJhbGciOiAiRVMyNTYiLCJraWQiOiAiMTEifQ.eyJ\\\r\npc3MiOiJodHRwczovL2NsaWVudC5leGFtcGxlLmNvbSIsInN1YiI6Imh0dHBzOi8vY2x\\\r\npZW50LmV4YW1wbGUuY29tIiwibmJmIjoxMzAwODE1NzgwLCJleHAiOjEzMDA4MTkzODA\\\r\nsImNuZiI6eyJqd2siOnsia3R5IjoiRUMiLCJ1c2UiOiJzaWciLCJjcnYiOiJQLTI1NiI\\\r\nsIngiOiIxOHdITGVJZ1c5d1ZONlZEMVR4Z3BxeTJMc3pZa01mNko4bmpWQWlidmhNIiw\\\r\nieSI6Ii1WNGRTNFVhTE1nUF80Zlk0ajhpcjdjbDFUWGxGZEFnY3g1NW83VGtjU0EifX1\\\r\n9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\r\nOAuth-Client-Attestation-PoP: eyJhbGciOiJFUzI1NiJ9.eyJpc3MiOiJodHRwc\\\r\nzovL2NsaWVudC5leGFtcGxlLmNvbSIsImF1ZCI6Imh0dHBzOi8vYXMuZXhhbXBsZS5jb\\\r\n20iLCJuYmYiOjEzMDA4MTU3ODAsImV4cCI6MTMwMDgxOTM4MH0.coB_mtdXwvi9RxSMz\\\r\nbIey8GVVQLv9qQrBUqmc1qj9Bs\r\n\r\ngrant_type=authorization_code&\r\ncode=n0esc3NRze7LTCu7iYzS6a5acc3f0ogp4\r\n```",
              "createdAt": "2024-04-16T16:49:50Z",
              "updatedAt": "2024-04-16T16:52:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM53ell8",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-16T20:05:55Z",
          "updatedAt": "2024-04-16T20:05:55Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nThis specification introduces an extension to the OAuth 2.0 protocol, as outlined in {{RFC6749}}, enabling Client Instances to include an attestation in their interactions with Authorization Servers or Resource Servers. This method allows Client Instances, typically considered as public clients in traditional deployments, to authenticate to an Authorization Server or Resource Server by providing an attestation, thereby enhancing the authentication process for Client Instances.\r\n```",
              "createdAt": "2024-04-16T20:05:55Z",
              "updatedAt": "2024-04-16T20:05:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM53enBM",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "peppelinux",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-04-16T20:09:22Z",
          "updatedAt": "2024-04-16T20:22:13Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nPlease note that the protocol details for steps (2) and (4), particularly how the Client Instance authenticates to the client Backend, are beyond the scope of this specification. Furthermore, this specification is designed to be flexible and can be implemented even in scenarios where the client does not have a backend server. In such cases, each Client Instance is responsible for performing the functions typically handled by the backend on its own. \r\n\r\nThis approach acknowledges the evolving landscape of OAuth 2.0 deployments, where the ability for public clients to authenticate securely and reliably has become increasingly important. \r\n```",
              "createdAt": "2024-04-16T20:09:22Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 52,
              "body": "```suggestion\r\n: A specific deployment or instantiation of a client application in the OAuth 2.0 framework, representing a single, distinct version of the client software running on a device or in an environment. Each Client Instance can have its own unique configuration, state, and identity, distinguishing it from other deployments of the same client application. This concept is particularly relevant in contexts where a client application might be installed and operated across multiple devices or environments, each requiring individual authentication and authorization processes with OAuth 2.0 Authorization Servers or Resource Servers.\r\n```",
              "createdAt": "2024-04-16T20:11:41Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 56,
              "body": "```suggestion\r\n:  A cryptographic asymmetric key pair that is generated by the Client Instance where the public key of the key pair is provided to the client backend. This public key is then encapsulated within the Client Attestation JWT and is utilized to sign the Client Attestation Proof of Possession.\r\n```",
              "createdAt": "2024-04-16T20:12:33Z",
              "updatedAt": "2024-05-16T06:47:21Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nThis draft introduces the concept of client attestations to the OAuth 2 protocol, using two JWTs: a Client Attestation and a Client Attestation Proof of Possession (PoP). These JWTs are transmitted via HTTP headers in an HTTP request from a Client Instance to an Authorization Server or Resource Server. The primary purpose of these headers is to authenticate the Client Instance.\r\n```",
              "createdAt": "2024-04-16T20:14:13Z",
              "updatedAt": "2024-05-16T06:49:30Z"
            },
            {
              "originalPosition": 71,
              "body": "```suggestion\r\n: A JWT that conforms to the structure and syntax as defined in [](#client-attestation-jwt)\r\n```",
              "createdAt": "2024-04-16T20:14:52Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 107,
              "body": "```suggestion\r\nAs specified in {{RFC9110}}, header field names are case-insensitive; therefore, OAUTH-CLIENT-ATTESTATION, oauth-client-attestation, and other case variations are all valid and equivalent header field names. However, it is important to consider that the case is significant in the value of the header field.\r\n```",
              "createdAt": "2024-04-16T20:16:25Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 125,
              "body": "```suggestion\r\nThe following rules apply to validating the Client Attestation JWT. Application of additional restrictions and policy are at the discretion of the Authorization Server.\r\n```",
              "createdAt": "2024-04-16T20:16:48Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 148,
              "body": "```suggestion\r\n11. The Authorization Server MUST reject a JWT that is not valid in all other respects per \"JSON Web Token (JWT)\" {{RFC7519}}.\r\n```",
              "createdAt": "2024-04-16T20:17:10Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 166,
              "body": "```suggestion\r\nThe Authorization Server MUST perform all of the checks outlined in [](#checking-http-requests-with-client-attestations) for a received access token request which is making use of the client attestation mechanism as defined by this draft.\r\n```",
              "createdAt": "2024-04-16T20:17:47Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 190,
              "body": "```suggestion\r\nImplementers should be aware that the design of this authentication mechanism deliberately allows for a Client Instance to re-use a single Client Attestation JWT in multiple interactions/requests with an Authorization Server, whilst producing a fresh Client Attestation PoP JWT. Client deployments should consider this when determining the validity period for issued Client Attestation JWTs as this ultimately controls how long a Client Instance can re-use a single Client Attestation JWT.\r\n```",
              "createdAt": "2024-04-16T20:18:26Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 196,
              "body": "anyway, this \"default\" limitation would have huge impacts on the topologies of the infrastructure of trust which will tend to not scale upon multiple intermediates, facilitating therefore the old-single-central-point. \r\n\r\nI see a regression, in a way that is as if we were trying as much as possible to distance ourselves from a potential complexity that we would like to avoid at all costs (and which will therefore haunt us!).",
              "createdAt": "2024-04-16T20:21:47Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM53fAZB",
          "commit": {
            "abbreviatedOid": "383f06f"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-16T21:19:26Z",
          "updatedAt": "2024-04-16T21:19:27Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n  RFC9110: RFC9110\r\n  RFC9112: RFC9112\r\n```",
              "createdAt": "2024-04-16T21:19:26Z",
              "updatedAt": "2024-04-16T21:19:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM536B4V",
          "commit": {
            "abbreviatedOid": "96e6b12"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-19T15:15:58Z",
          "updatedAt": "2024-04-26T13:03:28Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "```suggestion\r\ntoken68                        = 1*( ALPHA / DIGIT / \"-\" / \".\" / \r\n                                     \"_\" / \"~\" / \"+\" / \"/\" ) *\"=\"\r\n```",
              "createdAt": "2024-04-19T15:15:59Z",
              "updatedAt": "2024-04-26T13:03:28Z"
            },
            {
              "originalPosition": 229,
              "body": "Need to remove reference to RFC6755",
              "createdAt": "2024-04-19T15:17:07Z",
              "updatedAt": "2024-04-26T13:03:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM547L4u",
          "commit": {
            "abbreviatedOid": "96e6b12"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-04-29T15:06:24Z",
          "updatedAt": "2024-04-29T15:13:31Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I would argue the client instance authenticates as a certain client id from the perspective of the AS. As a test, a client instance could use different JWTs with different confirmation keys but would be still the same client. ",
              "createdAt": "2024-04-29T15:06:24Z",
              "updatedAt": "2024-04-29T15:13:31Z"
            },
            {
              "originalPosition": 16,
              "body": "attestation -> assertion",
              "createdAt": "2024-04-29T15:07:27Z",
              "updatedAt": "2024-04-29T15:13:31Z"
            },
            {
              "originalPosition": 62,
              "body": "The concept of assertions was introduced in OAuth in RFC 7521 and RFC 7523 introduced use of JWTs as assertions to authenticate clients. This draft adds key binding on top of JWT-based client authentication. ",
              "createdAt": "2024-04-29T15:09:02Z",
              "updatedAt": "2024-04-29T15:13:31Z"
            },
            {
              "originalPosition": 206,
              "body": "Binding the refresh token to a client instance requires this draft to introduce a client instance identifier and makes client instances trackable across key binding JWTs. I suggest to bind the refresh token to the JWT instance id or the binding key instead.",
              "createdAt": "2024-04-29T15:12:40Z",
              "updatedAt": "2024-04-29T15:13:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM56xMlp",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-16T06:35:41Z",
          "updatedAt": "2024-05-16T06:35:42Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nThis specification defines an extension to the OAuth 2 protocol as defined in {{RFC6749}} which enables a Client Instance to include an attestation in interactions with an Authorization Server or a Resource Server. This new method enables Client Instances involved in a client deployment that is traditionally viewed as a public client, to be able to provide an attestation in order to authenticate.\r\n```",
              "createdAt": "2024-05-16T06:35:41Z",
              "updatedAt": "2024-05-16T06:37:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM56xOim",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-16T06:40:55Z",
          "updatedAt": "2024-05-16T06:40:55Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "The existing definition is from an already published RFC and while it is short I believe it accurately captures the required detail",
              "createdAt": "2024-05-16T06:40:55Z",
              "updatedAt": "2024-05-16T06:40:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM56xUcx",
          "commit": {
            "abbreviatedOid": "96e6b12"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-16T06:52:30Z",
          "updatedAt": "2024-05-16T06:52:30Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "We will create a seperate issue to discuss this terminology change.",
              "createdAt": "2024-05-16T06:52:30Z",
              "updatedAt": "2024-05-16T06:52:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM56xU7k",
          "commit": {
            "abbreviatedOid": "96e6b12"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-16T06:53:36Z",
          "updatedAt": "2024-05-16T06:53:36Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "As above I think this is a more general terminology change we will tackle seperately, we have created an issue.",
              "createdAt": "2024-05-16T06:53:36Z",
              "updatedAt": "2024-05-16T06:53:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM56xVha",
          "commit": {
            "abbreviatedOid": "96e6b12"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-16T06:54:56Z",
          "updatedAt": "2024-05-16T06:54:56Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "Im not sure I follow the current language does bind to the key represented in the \"cnf\" claim.",
              "createdAt": "2024-05-16T06:54:56Z",
              "updatedAt": "2024-05-16T06:54:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM56xWVZ",
          "commit": {
            "abbreviatedOid": "013d25c"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-16T06:56:52Z",
          "updatedAt": "2024-05-16T06:56:52Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "I think the current language is sufficient even though it is a little more brief.",
              "createdAt": "2024-05-16T06:56:52Z",
              "updatedAt": "2024-05-16T06:56:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57BkHP",
          "commit": {
            "abbreviatedOid": "f8953ea"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-17T17:12:29Z",
          "updatedAt": "2024-05-17T17:12:30Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nThis approach acknowledges the evolving landscape of OAuth 2 deployments, where the ability for public clients to authenticate securely and reliably has become increasingly important.\r\n```",
              "createdAt": "2024-05-17T17:12:30Z",
              "updatedAt": "2024-05-17T17:12:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57BlmC",
          "commit": {
            "abbreviatedOid": "f8953ea"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-05-17T17:16:31Z",
          "updatedAt": "2024-05-17T17:39:56Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "The example neither include nonce nor jti, so it does not have replay protection?",
              "createdAt": "2024-05-17T17:16:31Z",
              "updatedAt": "2024-05-17T17:39:56Z"
            },
            {
              "originalPosition": 175,
              "body": "```suggestion\r\n3. The signature of the Client Attestation PoP JWT obtained from the OAuth-Client-Attestation-PoP HTTP header verifies with the Client Instance Key contained in the `cnf` claim of the Client Attestation JWT obtained from the OAuth-Client-Attestation HTTP header.\r\n```",
              "createdAt": "2024-05-17T17:37:04Z",
              "updatedAt": "2024-05-17T17:39:56Z"
            },
            {
              "originalPosition": 177,
              "body": "```suggestion\r\n# Client Attestation at the Token Endpoint\r\n```",
              "createdAt": "2024-05-17T17:38:19Z",
              "updatedAt": "2024-05-17T17:39:56Z"
            },
            {
              "originalPosition": 179,
              "body": "```suggestion\r\nWhile usage of the the client attestation mechanism defined by this draft can be used in a variety of different HTTP requests to different endpoints, usage within the token request as defined by {{RFC6749}} has particular additional considerations outlined below.\r\n```",
              "createdAt": "2024-05-17T17:38:57Z",
              "updatedAt": "2024-05-17T17:39:56Z"
            },
            {
              "originalPosition": 204,
              "body": "Should we explcitly say that this may be used at the PAR endpoint?",
              "createdAt": "2024-05-17T17:39:43Z",
              "updatedAt": "2024-05-17T17:39:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57FfWN",
          "commit": {
            "abbreviatedOid": "f8953ea"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-19T09:39:15Z",
          "updatedAt": "2024-05-19T09:39:15Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "Agreed, created an issue.",
              "createdAt": "2024-05-19T09:39:15Z",
              "updatedAt": "2024-05-19T09:39:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57FfbZ",
          "commit": {
            "abbreviatedOid": "f8953ea"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-19T09:40:54Z",
          "updatedAt": "2024-05-19T09:40:54Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Agreed created an issue to track seperately.",
              "createdAt": "2024-05-19T09:40:54Z",
              "updatedAt": "2024-05-19T09:40:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57FfrG",
          "commit": {
            "abbreviatedOid": "e2a05bf"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-19T09:46:55Z",
          "updatedAt": "2024-05-19T09:46:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM57F0gg",
          "commit": {
            "abbreviatedOid": "e2a05bf"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I do believe there should be a discussion about terminology (attestation vs assertion) as it seems to create quite a bit of confusion, but I do think a different issue/PR is better suited for that.\r\n\r\nMinor nit: Client Attestation seems to be used in lower and upper case somewhat inconsistently. Should every usage be upper case (e.g., also client attestation mechanism)? ",
          "createdAt": "2024-05-19T18:09:25Z",
          "updatedAt": "2024-05-19T18:09:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM57JD9x",
          "commit": {
            "abbreviatedOid": "e2a05bf"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-05-20T11:19:20Z",
          "updatedAt": "2024-05-20T11:34:29Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nThis specification defines an extension to the OAuth 2 protocol as defined in {{RFC6749}} which enables a Client Instance to include an attestation in interactions with an Authorization Server or a Resource Server. This new method enables Client Instances involved in a client deployment that is traditionally viewed as a public client, to be able to authenticate.\r\n```",
              "createdAt": "2024-05-20T11:19:20Z",
              "updatedAt": "2024-05-20T11:34:29Z"
            },
            {
              "originalPosition": 43,
              "body": "\"public clients\" ... \"to authenticate\" is a contradiction. The text further up speaks about \"deployments traditionally viewed as a public client\", that's a better description. I would even argue either this spec is for confidential clients of a new kind or it is a new type of client. But it is not for public clients.",
              "createdAt": "2024-05-20T11:23:01Z",
              "updatedAt": "2024-05-20T11:34:29Z"
            },
            {
              "originalPosition": 63,
              "body": "it is difficult if the text states client backend is out of scope but refers to the backend in the definition. Perhaps a more abstract definition would help. In the end, there must be a party trusted by the AS that signs the client attestations/assertions. It does not matter whether that is the client backend. ",
              "createdAt": "2024-05-20T11:26:46Z",
              "updatedAt": "2024-05-20T11:34:29Z"
            },
            {
              "originalPosition": 67,
              "body": "I still believe the term \"attestation\" should be replaced by \"assertion\". That's more appropriate and it does not confuse the audience as the term \"attestation\". ",
              "createdAt": "2024-05-20T11:28:05Z",
              "updatedAt": "2024-05-20T11:34:29Z"
            },
            {
              "originalPosition": 206,
              "body": "you are right, I resolve the comment. ",
              "createdAt": "2024-05-20T11:33:03Z",
              "updatedAt": "2024-05-20T11:34:29Z"
            },
            {
              "originalPosition": 228,
              "body": "```suggestion\r\nImplementers should be aware that using the same client attestation across multiple authorization servers could result in correlation of the end user using the Client Instance through claim values (including the Client Instance Key in the `cnf` claim). Client deployments are therefore RECOMMENDED to use different Client Attestation JWTs with different Client Instance Keys across different authorization servers.\r\n```",
              "createdAt": "2024-05-20T11:34:18Z",
              "updatedAt": "2024-05-20T14:21:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57KZBT",
          "commit": {
            "abbreviatedOid": "e2a05bf"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-20T14:14:31Z",
          "updatedAt": "2024-05-20T14:14:32Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "How about that? If we rename the draft we may rename attestation, but until then I would keep it\r\n```suggestion\r\nThis specification defines an extension to the OAuth 2 protocol as defined in {{RFC6749}} which enables a Client Instance to include a key-bound attestation in interactions with an Authorization Server or a Resource Server. This new method enables Client Instances involved in a client deployment that is traditionally viewed as a public client, to be able to utilize this key-bound attestation to authenticate.\r\n```",
              "createdAt": "2024-05-20T14:14:31Z",
              "updatedAt": "2024-05-20T14:14:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57KaQ3",
          "commit": {
            "abbreviatedOid": "e2a05bf"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-20T14:17:00Z",
          "updatedAt": "2024-05-20T14:17:00Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "The text doesn't say Client Backend is out of scope as `iss` of the Client Attestation JWT is the Client Backend but only that how Client Backend authenticates the client instance is out of scope",
              "createdAt": "2024-05-20T14:17:00Z",
              "updatedAt": "2024-05-20T14:17:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57Ka5n",
          "commit": {
            "abbreviatedOid": "e2a05bf"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-20T14:18:14Z",
          "updatedAt": "2024-05-20T14:18:14Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "It will be a dedicated discussion in OAuth Interims Call and we have a separate Issue #71, but it shouldn't delay this PR in my mind",
              "createdAt": "2024-05-20T14:18:14Z",
              "updatedAt": "2024-05-20T14:18:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57Kcgj",
          "commit": {
            "abbreviatedOid": "e2a05bf"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-20T14:21:29Z",
          "updatedAt": "2024-05-20T14:21:29Z",
          "comments": [
            {
              "originalPosition": 228,
              "body": "applied with some additional corrections",
              "createdAt": "2024-05-20T14:21:29Z",
              "updatedAt": "2024-05-20T14:21:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57Y-AP",
          "commit": {
            "abbreviatedOid": "30ae9a8"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-22T05:43:39Z",
          "updatedAt": "2024-05-22T05:43:40Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I created Issue #79 to pursue this topic",
              "createdAt": "2024-05-22T05:43:40Z",
              "updatedAt": "2024-05-22T05:43:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57w7pj",
          "commit": {
            "abbreviatedOid": "567e381"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-24T09:52:34Z",
          "updatedAt": "2024-05-24T09:52:34Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I like your proposal. ",
              "createdAt": "2024-05-24T09:52:34Z",
              "updatedAt": "2024-05-24T09:52:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 80,
      "id": "PR_kwDOJaEkaM5w2nJL",
      "title": "fix broken links after moving the repo",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/80",
      "state": "MERGED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-05-29T08:39:24Z",
      "updatedAt": "2024-05-31T09:20:12Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "2b711a053edd47a06be903cd116a3996dd689a5f",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "c2bo/fix-links-repo-move",
      "headRefOid": "db0f5bc72b821dd8c296dfb1d7b8a72dc91ec63b",
      "closedAt": "2024-05-31T09:20:09Z",
      "mergedAt": "2024-05-31T09:20:09Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "d5b5558c1f045a4e358ce79f3efae453fc1857b6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM58l0gE",
          "commit": {
            "abbreviatedOid": "db0f5bc"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-31T09:20:04Z",
          "updatedAt": "2024-05-31T09:20:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 82,
      "id": "PR_kwDOJaEkaM55t96Y",
      "title": "add http field name (header) iana registration",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/82",
      "state": "MERGED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "closes #78\r\n",
      "createdAt": "2024-08-28T14:21:54Z",
      "updatedAt": "2024-08-29T07:40:03Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "94b0fdfbd3ee492f07b2334063565d47ed15ef34",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "c2bo/iana-headers",
      "headRefOid": "60320c0726879d8cfca666f55dc45424f41f6343",
      "closedAt": "2024-08-29T07:39:59Z",
      "mergedAt": "2024-08-29T07:39:59Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "26212a233b69350ee92b1e437341c8ab347eee72"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6HLcHg",
          "commit": {
            "abbreviatedOid": "60320c0"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-29T07:39:42Z",
          "updatedAt": "2024-08-29T07:39:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6HLcN9",
          "commit": {
            "abbreviatedOid": "60320c0"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-29T07:39:53Z",
          "updatedAt": "2024-08-29T07:39:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 83,
      "id": "PR_kwDOJaEkaM55yTud",
      "title": "add christian as author",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/83",
      "state": "MERGED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We should run the \"Update generated files\" action after this PR - that will also upgrade all of the github actions to current versions",
      "createdAt": "2024-08-29T06:31:36Z",
      "updatedAt": "2024-08-29T07:39:00Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "94b0fdfbd3ee492f07b2334063565d47ed15ef34",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "c2bo/add-as-author",
      "headRefOid": "bf6da6e87b46c88a993769141fcccded834014df",
      "closedAt": "2024-08-29T07:38:57Z",
      "mergedAt": "2024-08-29T07:38:57Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "b14788f752878703c82a2719e63f6270cf7b792c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6HLbd-",
          "commit": {
            "abbreviatedOid": "bf6da6e"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-29T07:38:27Z",
          "updatedAt": "2024-08-29T07:38:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6HLbqw",
          "commit": {
            "abbreviatedOid": "bf6da6e"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-29T07:38:49Z",
          "updatedAt": "2024-08-29T07:38:49Z",
          "comments": []
        }
      ]
    }
  ]
}