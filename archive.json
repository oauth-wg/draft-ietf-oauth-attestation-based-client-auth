{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-09-04T00:11:23.014756+00:00",
  "repo": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "pending-close",
      "description": "",
      "color": "D76CC5"
    },
    {
      "name": "discuss",
      "description": "",
      "color": "03BA91"
    },
    {
      "name": "ready-for-pr",
      "description": "",
      "color": "19E11B"
    },
    {
      "name": "has-pr",
      "description": null,
      "color": "aaaaaa"
    }
  ],
  "issues": [
    {
      "number": 3,
      "id": "I_kwDOJaEkaM5lbyhk",
      "title": "Trust",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/3",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "make it clear that the receiver of the attestation needs to trust the signer of the attestation and pre-obtain(?) the keys to validate it?",
      "createdAt": "2023-05-09T10:10:14Z",
      "updatedAt": "2025-08-12T06:58:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would imagine the client is configured/registered with the AS and the jwks or jwks_uri of that client is where the verification keys are found. Basically the trust comes from the client configuration record at the AS (however that comes to be) and the keys are obtained from the client jwks/jwks_uri metadata.",
          "createdAt": "2023-05-10T17:58:41Z",
          "updatedAt": "2023-05-10T17:58:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with Brian, I dont think we want this draft to define how the keys required to validate the attestation MUST be obtained because that is really based on how the client comes to be configured at the AS and as a result there could be multiple mechanisms. There may be a need to add some language that makes this clearly however I will note that RFC 7523 doesn't speak to this for the assertions it defines.",
          "createdAt": "2023-05-11T09:54:19Z",
          "updatedAt": "2023-05-11T09:54:19Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "The key point is the digital trust relationship that allows a client to be registered and attestable as realiable and eligible in relation to one or more trust frameworks, and for any following transactions, outside the client registration, that may happen in a defined period of time, beyond which trust with that client must be re-evaluated.\r\n\r\nGiven that having a client registered previously or obtaining its public keys though TLS doesn't give any assurance about the compliance of that client in the present, in relation to privacy and security preserving trust model. We shoudl consider that a client, that's a participant in a Auth/eID infrastructure, may lose its compliance and consequently be banned because of this. The requirement to be met is to allow an automatic method for evaluating the revocation status of the client, if the determining authority (TTP) is outside the party (AS and Client)\r\n\r\nanother key point is that trusted attestations, which allow a customer to be registered and then allow data interchange with it, are considered long-lived attestations, for the satisfaction of non-repudiation requirements for years to come.",
          "createdAt": "2023-05-11T14:49:33Z",
          "updatedAt": "2023-05-11T14:49:33Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just to add a bit of context about the comment about RFC 7523 - it doesn't speak to this stuff in specific terms but does have some discussion in [Interoperability Considerations](https://datatracker.ietf.org/doc/html/rfc7523#section-5) that's pretty open ended. RFC7523 came before \"Dynamic Client Registration\" in RFC7591. But since then the metadata defined in RFC7591, and registered extensions to it, have come to imply a general data model for clients that is useful and used for authorization server implementations, even when the Dynamic Client Registration Protocol isn't in play. That includes jwks/jwks_uri metadata as the place for key(s). OIDC core kinda follows and pushes that pattern too and even 'profiles' RFC7591 somewhat with its definition of `private_key_jwt`.  So, regardless of how a client comes to be configured, the jwks or jwks_uri client metadata fields really have become the de facto for where/how client keys are obtained. I think this draft could acknowledge and/or provide some guidance in that direction. The AS would have one client config record for the whole client system and the verification keys for the attestation assertion come from the jwks or jwks_uri fields of that record. \"Trust\" comes from how that client record comes to be configured, but that how is out of scope of this draft. \r\n",
          "createdAt": "2023-05-11T18:28:31Z",
          "updatedAt": "2023-05-18T23:39:21Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "I start from the assumption that OpenID Connect Federation confirms the traditional methods to get the jwks, using jwks/jwks_uri, enabling the jwks claim for the openid connect providers metadata as well.\r\n\r\nI want to start from the example below and answering to the question \"How can you trust such client?\"\r\n\r\n````\r\n{\r\n  \"alg\": \"ES256\",\r\n  \"kid\": \"11\",\r\n  \"trust_chain\": [ ... ]\r\n}\r\n.\r\n{\r\n  \"iss\": \"https://client.example.com\",\r\n  \"sub\": \"https://client.example.com\",\r\n  \"nbf\":1300815780,\r\n  \"exp\":1300819380,\r\n  \"cnf\": {\r\n    \"jwk\": {\r\n      \"kty\": \"EC\",\r\n      \"use\": \"sig\",\r\n      \"crv\": \"P-256\",\r\n      \"x\": \"18wHLeIgW9wVN6VD1Txgpqy2LszYkMf6J8njVAibvhM\",\r\n      \"y\": \"-V4dS4UaLMgP_4fY4j8ir7cl1TXlFdAgcx55o7TkcSA\"\r\n    }\r\n  }\r\n}\r\n````\r\n\r\nif we would have a x5c header parameter instead of the Federation Trust Chain, the Key Attestation would be realiable according to a x509 PKI.\r\n\r\nUsing the Federation Trust Chain we are able to:\r\n\r\n- get the public key corresponding to the kid 11\r\n- get the trust relationships between the client and one or more Trusted Third Parties\r\n- get the metadata related to that client (and all its jwks ...)\r\n- get the policy to be applicable to the metadata, following what configured by the Trusted Third Parties for this client\r\n-  verify the trust chain over years, even if the public keys needed for verification are changed to one or multiple trusted third party or in the client as well\r\n\r\nI'm aware that attesting keys is just attesting keys but the model would require how to attest the owner of that key as reliable?\r\nHow do you trust that client, since it has self issued that attestation?\r\n\r\nI suggest to introduce the topic of Trust Establishment in this Draft, to give some pointers or refs to the ways we have todate to verify the reliability of an attestation, since a self-signed attestation is not attestable as secure.\r\n\r\nAt the same time there may be the possibility that a client attestation should be issued by a trusted third party, so the question would are: \r\n\r\n- Is there a single Trusted Third Party? \r\n- Is there any way the Trusted Third Party has to delegate the issuing of the attestations to another party as an intermediate?\r\n- Is there the need to obtain the public keys of all the Trusted Third Parties, if more than a single? If yes, how to know who these are?\r\n\r\nI'm asking since I found these answers in OpenID Connect Federation and the questions above are the classical questions the analysts/implementers have when deals with client attestations or dynamic client registrations ",
          "createdAt": "2023-05-20T17:01:34Z",
          "updatedAt": "2023-05-20T22:56:42Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "Another example to exemplify the differences bwtween key attestation and assurance of reliability. \r\n\r\nA crypto key Is a key Just as a Key of a hotel room\r\n\r\nGiven that that Key effectively works for its hotel room, the question Is: which reputation has that hotel?\r\nHow many \"stars\" does It have?\r\nWho give those \"stars\"?\r\nWhich are the evaluation parameters and for how long  will these be valid?\r\nWill be a day when the hotel owner may say to have never give that room to a client, or that such client was never seen before?\r\nWhich trust framework will protect both hotel owner and client from unwanted actions they may do against each other?\r\n\r\nassurance of reliability is something verifiable, even If I'm aware that Trust is more a strategy and the Trust Model should define the rules and the architectural components to implement this strategy. A Strategy won't give us the assurance that a bad action won't be made by an Entity but at the same time the model must give also the assurance that every proof must be non repudiable and issued as long-lived, to give the guarantee to the participants that even if a rogue participant will break the rules of the trust, the proofs will be always verifiable in the future (especially when public keys will change)",
          "createdAt": "2023-05-21T21:55:39Z",
          "updatedAt": "2023-05-21T21:56:17Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "We should add a bit of guidance in regards to this to the spec imho - similar to what we did in token status list imho",
          "createdAt": "2025-08-12T06:58:50Z",
          "updatedAt": "2025-08-12T06:58:50Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOJaEkaM5l2HJe",
      "title": "`sub` value",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/4",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "pending-close"
      ],
      "body": "The text currently says:\r\n> The JWT MUST contain a \"sub\" (subject) claim with a value corresponding to the \"client_id\" of the OAuth client.\r\n\r\nthe thing is.. when there could been no pre-existing relationship between the issuer and the wallet. probably worth noting that `sub` (and `client_id` value) can be self-attested by the wallet frontend",
      "createdAt": "2023-05-13T16:58:41Z",
      "updatedAt": "2025-08-12T07:02:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I dont think we want to offer too much commentary here about how the client ends up with a client ID that is recognised and trusted by the AS (credential issuer), but I agree the case you raise is permitted.",
          "createdAt": "2023-05-14T23:47:44Z",
          "updatedAt": "2023-05-14T23:47:44Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Shouldn't we at least describe what identifier is used for further processing (whether to lookup further data or in audit logs)? If the AS trusts the Issuer of the JWT, it should trust it to put a reasonable value in the `sub` field for further usage. ",
          "createdAt": "2023-05-16T13:49:05Z",
          "updatedAt": "2023-05-16T13:49:05Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I assume in some cases the issuer will out the `iss` in the `sub` claim, i.e. whatever data is looked up will be about the issuer (e.g. a wallet provider).",
          "createdAt": "2023-05-16T13:50:03Z",
          "updatedAt": "2023-05-16T13:50:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Apologies im not following you here, I'm inclined to make the iss the client ID as I think the most common case here is that its the client attesting a client instance and make the sub value a client instance ID that is unique per authorization server.",
          "createdAt": "2023-05-18T07:00:03Z",
          "updatedAt": "2023-05-18T07:00:03Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How have you come to the conclusion that this is the most common case?\r\n\r\nMy rationale is as follows: if the issuer wants to client id to be the iss value, it puts the iss value in the sub. If the issuer wants the client id to be something else, it uses a different value. I don\u2019t see a need for a client instance identification (at all or as default).",
          "createdAt": "2023-05-18T07:08:33Z",
          "updatedAt": "2023-05-18T07:08:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> How have you come to the conclusion that this is the most common case?\r\n\r\nI think the most common party signing the client attestation will be the client itself (e.g the backend component), as the AS will need to be able to relate the attestation keys back to the client in order to trust it any way. Do you have usecases where the attester is not the client, I believe this model is complex and we should seriously consider whether we support it. If the attester isn't the client then what do you set the iss value to, what does it mean and how should it influence validation of the attestation?",
          "createdAt": "2023-05-18T08:27:19Z",
          "updatedAt": "2023-05-18T08:28:37Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In general, I would assume the provider of the client to sign the attestation. However, Bundesdruckerei has implemented as solution where the attestation is issued by a trusted 3rd party. \n\nWith respect to the spec: I think it doesn't matter who signs the attestation as long as the AS trusts that party.",
          "createdAt": "2023-05-18T08:41:44Z",
          "updatedAt": "2023-05-18T08:41:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that in effect a trusted 3rd party could do the signing, however I dont believe their identity should be known to the AS (e.g as another protocol participant) instead their identity should still be considered part of the client.",
          "createdAt": "2023-05-18T09:41:38Z",
          "updatedAt": "2023-05-18T09:41:38Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why?",
          "createdAt": "2023-05-18T10:43:02Z",
          "updatedAt": "2023-05-18T10:43:02Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm unsure that it provides any value having another identified participant in the protocol seperate from the client. Can you elaborate on the value of why this trusted third party needs be independently identifiable from the client to the AS? How would its identity become know and managed by the AS?",
          "createdAt": "2023-05-18T10:47:20Z",
          "updatedAt": "2023-05-18T10:47:57Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Again. As long as the AS trusts the issuer of the assertion, it can accept it. I don\u2019t think we need to specify more than that + the sub is the client id. That\u2019s sufficient for interoperability.\n\nTo the contrary, I don\u2019t see a benefit in limiting the issuer to \u201ethe client\u201c.\nOn 18. May 2023 at 12:47 +0200, Tobias Looker ***@***.***>, wrote:\n> I'm unsure that it provides any value having another participant in the protocol seperate from the client. Can you elaborate on the value of why this trusted third party needs be independently identifiable from the client to the AS? How would its identity become know and managed by the AS?\n> \u2014\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n> You are receiving this because you commented.Message ID: ***@***.***>\n",
          "createdAt": "2023-05-18T10:51:28Z",
          "updatedAt": "2023-05-18T10:51:28Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree the most common use case is the iss being the client backend but we should not limit ourselves here.\nI propose iss is the attestation service and sub is a common name for the client aka wallet solution.\nIn some cases both might be the same but they don't need to be.\nBoth identifiers might be relevant for a lookup in a trust list ",
          "createdAt": "2023-05-18T11:08:02Z",
          "updatedAt": "2023-05-18T11:08:02Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Understood but I disagree, how does the attestation service become registered with the AS and managed beyond this point e.g in the event of key rotation, we would be adding another entirely new protocol participant for OAuth2 and I'm not sure we've identified any use cases where this would be valuable. Having the attestation service independently identified to the AS would only appear to be valuable when more than one client deployment wants to use the same attestation service, how common is that pattern? Because if we believe its not very common then the most common case where attestation service == client will likely pay a cost of increased complexity. Also what are the implications on the trust model for the AS, when things go wrong in which situations does it blame the client and others when it blames the attestation service?",
          "createdAt": "2023-05-18T19:46:46Z",
          "updatedAt": "2023-05-18T19:46:46Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How and why the AS trusts the issuer of an attestation is out of scope since it is not relevant on the protocol level. We also haven't defined this in the high assurance profile between verifier and issuer of a VC. I don't understand why we should take a different route here.\n\nJust as an example:\nIn the EU, the issuer will be maintained in a trusted list all issuers trust.\nIn a closed deployment, I would assume the trusted attestation issuers are directly maintained at the issuer.\n\nMany ways to get to Rome. We don't need to know all of them, just cater for them.",
          "createdAt": "2023-05-18T19:56:20Z",
          "updatedAt": "2023-05-18T19:56:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> How and why the AS trusts the issuer of an attestation is out of scope since it is not relevant on the protocol level\r\n\r\nOk I think perhaps our disconnect is here, how can the notion of \"the attestation service\" be entirely out of scope of this protocol? Its a party to the protocol who's identity will be crucial in the AS making a trust decision. Do we not need to define at least that the iss value of the client attestation IS an identifier for the attestation service and also how you resolve its keys and manage it in lifecycle? Also as I said before I think giving the AS two things to trust in reference to a client enormously increases the complexity in the trust decision it must make. ",
          "createdAt": "2023-05-18T20:09:49Z",
          "updatedAt": "2023-05-18T20:09:49Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Are all of those details defined in RFC 7523? I don't think so. This a base spec that is further detailed in profiles and deployments. The vc-sd-jwt spec s add also doesn't require a certain key resolution method for the same reason.\nIt doesn't matter for this spec whether the JWT is issued by a client backend or any other source. Important is that the AS needs to trust this issuer and that this JWT issuer determines the sub value, which is the client id. Anything beyond is subject to other specs in my opinion.\nFor the high assurance profile, I would assume keys are resolved either web based or with x509, like for the VCs. Other profiles can do it differently.",
          "createdAt": "2023-05-18T20:54:48Z",
          "updatedAt": "2023-05-18T20:54:48Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Right but RFC 7523 also doesn't formally define a new protocol participant either that the AS must trust independent of the client, instead its implied the keys required to verify the client attestation are associated to the client which is the model I'm proposing we recognise more formally. Are there any deployments of RFC 7523 that exist where the iss value in the assertion is not in some way an identifier for the client?",
          "createdAt": "2023-05-18T21:17:32Z",
          "updatedAt": "2023-05-18T21:17:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Something that was also pointed out to me is that RFC7523 may not require the iss to be the client_id but OpenID's profiling of it [did](https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication) and from what I understand there was no particular reason for RFC7523 to not constrain the iss value in this way, it just didn't. Nor are there really any deployments that have used RFC7523 in a way where the iss value is not the client id. ",
          "createdAt": "2023-05-19T00:43:33Z",
          "updatedAt": "2023-05-19T00:43:33Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "here I share something that emerged during the implementations and comparisons that took place with other analysts\r\n\r\niss and sub should not contain the same value, since the wallet provider (iss) is a separate entity with respect to the wallet instance (sub)\r\n\r\nFor this reason iss and sub must contain different identifiers, being related to distinct entities.\r\n\r\nThere are some cases where the client should not have a unique identifier, in this case the sub claim should not be included in the claim, because having iss and sub with identical values \u200b\u200bwould not make sense.\r\n\r\nFor this reason I propose to make the sub claim OPTIONAL rather than REQUIRED (MUST).",
          "createdAt": "2023-06-05T08:30:49Z",
          "updatedAt": "2023-06-05T08:30:49Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> iss and sub should not contain the same value, since the wallet provider (iss) is a separate entity with respect to the wallet instance (sub)\r\n\r\nWhy is that and what did emerge during implementations?",
          "createdAt": "2023-06-05T08:33:36Z",
          "updatedAt": "2023-06-05T08:33:36Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the discussion goes somewhere else now.\n\nOriginally the question was whether the attesting entity must be the client backend or can be a trusted third party.",
          "createdAt": "2023-06-05T11:07:53Z",
          "updatedAt": "2023-06-05T11:07:53Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "> Why is that and what did emerge during implementations?\r\n\r\nexactly was I wrote in the thread\r\n\r\n\r\n",
          "createdAt": "2023-06-05T12:25:14Z",
          "updatedAt": "2023-06-05T12:25:14Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess you mean \"iss and sub should not contain the same value, since the wallet provider (iss) is a separate entity with respect to the wallet instance (sub)\"\r\n\r\nWhile I agree on a conceptual level, I don't follow your conclusion that that an attestation needs to have different values for iss and sub. From the issuer's standpoint it is important to know it is talking to an instance of the respective wallet provider/product. It does not need to have an identity/identifier, nevertheless. You seem to agree as you propose to make the sub optional. Why do you think this is the better option than using sub == iss (i.e. self asserted, which to me makes sense). ",
          "createdAt": "2023-06-05T14:14:14Z",
          "updatedAt": "2023-06-05T14:14:34Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "I got your point.\r\n\r\nI don't think that iss == sub because the wallet provider attests this to the wallet instance as a personal mobile device.\r\nThere might be some cases where the wallet instance is provided as a cloud service, thus this would be a specialized case compatible to your vision.\r\n\r\nIn the cases where the wallet instance is a personal device, the Wallet Instance Attestation is not self-asserted since Provider and Instance are actually different entities. The issuer attests information in possession and control of the instance, that's a distinct entity under the sole control of the user.\r\n\r\nIf the attestation is self asserted the private key should be in control of the wallet provider, while this is not the case where personal device are involved.\r\n\r\nthe wallet provider doesn't have any control on the private keys and general details of the wallet instance, since these are arbitraries\r\n\r\n",
          "createdAt": "2023-06-05T16:10:57Z",
          "updatedAt": "2023-06-05T16:12:37Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #12 and #31",
          "createdAt": "2023-09-06T06:57:52Z",
          "updatedAt": "2023-09-06T06:57:52Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Related discussion also occuring in #13 ",
          "createdAt": "2023-11-08T00:22:50Z",
          "updatedAt": "2023-11-08T00:22:50Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Editors Call:\n- we are happy with the current text of the draft, basically being a little vague and saying \"The sub (subject) claim MUST specify client_id value of the OAuth Client.\"\n- this leaves it open whether we have traditional OAuth meaning of 1 client_id = 1 instance or not\n- ecosystems using this draft could make further statements, that's what we did in [OpenID4VCI](https://openid.github.io/OpenID4VCI/openid-4-verifiable-credential-issuance-wg-draft.html#name-wallet-attestation-subject)\n- we are fine, please comment if you disagree\n- pending close",
          "createdAt": "2025-08-12T07:02:16Z",
          "updatedAt": "2025-08-12T07:02:38Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOJaEkaM5mDAKH",
      "title": "Change name of the JWT to Client Attestation ",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/6",
      "state": "CLOSED",
      "author": "tlodderstedt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm struggling with the terminology currently used in this draft. For me, it describes a mechanism to use JWTs to authenticate OAuth clients. \r\n\r\nHowever, the draft currently designates those JWTs as \"Key Attestation\" or \"attestation key\" or \"jwt-key-attestation\", which sounds like the focus is on attesting something about a certain key to the AS. But that's obviously not the case since, this draft is about client authentication and the key is \"just\" used to protect the JWT against replay. \r\n\r\nI think the name is confusing and suggest to change it to \"Client Attestation\". ",
      "createdAt": "2023-05-16T13:45:01Z",
      "updatedAt": "2023-09-06T06:57:13Z",
      "closedAt": "2023-09-06T06:57:13Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, what about \"Client Attestation based Client Authentication\" as a draft title?",
          "createdAt": "2023-05-18T06:55:37Z",
          "updatedAt": "2023-05-18T06:55:52Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I revisited the title of RFC 7523. What about \u201eSender-Constrained JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication\u201c?",
          "createdAt": "2023-05-18T07:24:52Z",
          "updatedAt": "2023-05-18T07:24:52Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "@tlodderstedt thats a proposal for the title of the RFC I guess? I'm ok with that..\r\nI propose \"Client Attestation JWT\" for the actual thing, that we call wallet attestation in our scenario",
          "createdAt": "2023-05-19T16:27:53Z",
          "updatedAt": "2023-05-19T16:27:53Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Renaming the Client Attestation covered by #11 .\r\nRenaming topic in this issue is about the title?",
          "createdAt": "2023-05-22T16:22:45Z",
          "updatedAt": "2023-05-22T16:22:45Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "After thinking about this more I propose \"Attestation Based Client Authentication for OAuth 2\"",
          "createdAt": "2023-05-30T21:47:55Z",
          "updatedAt": "2023-05-30T21:47:55Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What is the meaning of this title? What does \"Attestation based\" mean?",
          "createdAt": "2023-05-31T01:21:47Z",
          "updatedAt": "2023-05-31T01:21:47Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "that the Client backend/Attestation Service attests the Client Instance",
          "createdAt": "2023-06-05T13:24:21Z",
          "updatedAt": "2023-06-05T13:24:21Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How is that different from \"JWT-based client authentication\"? The JWT also contains claims about the client.",
          "createdAt": "2023-06-05T14:08:44Z",
          "updatedAt": "2023-06-05T14:08:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Resolved in draft-00",
          "createdAt": "2023-09-06T06:57:13Z",
          "updatedAt": "2023-09-06T06:57:13Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOJaEkaM5mMD6N",
      "title": "Introduction text",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/7",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft says:\r\n\r\n> [[RFC7521](https://vcstuff.github.io/draft-looker-oauth-attested-key-based-client-authentication/draft-looker-oauth-attested-key-based-client-authentication.html#RFC7521)] defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification extends this mechanism to provide a way for a client instance to authenticate it self with the authorization server through an attested key based authentication scheme.\r\n\r\nI don't like the description of a \"an attested key based authentication scheme\", as key attestations are not always possible and it is more about attesting the wallet and the key being a mechanism.\r\n\r\n I would rather describe the current approach as a\r\n- remote client (instance) attestation scheme\r\n- remote wallet (instance) attestation scheme",
      "createdAt": "2023-05-17T18:27:28Z",
      "updatedAt": "2023-09-06T06:56:38Z",
      "closedAt": "2023-09-06T06:56:38Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed I dont like it particularly either, what about just \r\n\r\n\r\n[[RFC7521](https://vcstuff.github.io/draft-looker-oauth-attested-key-based-client-authentication/draft-looker-oauth-attested-key-based-client-authentication.html#RFC7521)] defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification extends this mechanism to provide a way for a client instance to authenticate itself with the authorization server through an attestation based authentication scheme.",
          "createdAt": "2023-05-18T06:54:25Z",
          "updatedAt": "2023-05-18T06:54:39Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine to close this, see #11 ",
          "createdAt": "2023-05-22T16:21:37Z",
          "updatedAt": "2023-05-22T16:21:37Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Rephrased in #39 ",
          "createdAt": "2023-09-06T06:56:38Z",
          "updatedAt": "2023-09-06T06:56:38Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOJaEkaM5mMRNY",
      "title": "Improvements to the diagram",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/8",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current diagram describes 6 steps:\r\n(1) Generate Attestation Key \r\n(2) Request  Client Key Attestation for generated key\r\n(3) Generate Client Key Attestation\r\n(4) Repond with Generated Client Key Attestation\r\n(5) Generate Key Attestation PoP\r\n(6) Interaction using Client Key Attestation + PoP for authentication\r\n\r\nI would propose for:\r\n(1) Generate key and client app attestations\r\n(2) Request Client Attestation JWT\r\n(3) Validate attestations and generate Client Attestation JWT\r\n(4) Issue Client Attestation JWT\r\n(5) Generate DPoP for Client Attestation JWT\r\n(6) Authenticate using Client Attestation JWT + DPoP\r\n",
      "createdAt": "2023-05-17T18:59:35Z",
      "updatedAt": "2023-09-06T06:55:34Z",
      "closedAt": "2023-09-06T06:55:34Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "A couple of thoughts w.r.t this\r\n\r\nIm not sure how much we want to talk about app attestations in this draft as it assumes the client instance is say a native app.\r\n\r\nI think this issue has some good terminology suggestions WDYT about the following\r\n\r\nClient Attestation JWT - Generated by the client backend\r\nClient Instance PoP JWT - Generated by the client instance during client authentication (I dont think DPoP is right to use here w.r.t how it conflicts with DPoP)\r\nClient Instance Key - What the client attestation jwt is bound to\r\n\r\n",
          "createdAt": "2023-05-18T06:52:53Z",
          "updatedAt": "2023-05-18T06:52:53Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, is this covered by #11 ?\r\nOk to close for me",
          "createdAt": "2023-05-22T16:20:31Z",
          "updatedAt": "2023-05-22T16:20:31Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOJaEkaM5mPkLA",
      "title": "Replay attack prevention through AS contributed nonce",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/9",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "Currently the specification does not define a mechanism for an AS contributed nonce to feature in the client attestation PoP meaning replay attack detection by authorisation servers requires tracking the JTI within the time window set by the PoP's iat claim. We should elaborate on an AS contributed nonce for the specification.",
      "createdAt": "2023-05-18T10:00:50Z",
      "updatedAt": "2023-10-23T20:15:32Z",
      "closedAt": "2023-10-23T20:15:32Z",
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "What about using the authorization code or pre auth code as suggested in our demo?",
          "createdAt": "2023-05-18T11:03:02Z",
          "updatedAt": "2023-05-18T11:03:02Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is an option, however the nonce for client authentication becomes dependent on the grant type which creates a bit of an awkward coupling when an application wants to say use this mode of client authentication for grant type other than pre auth code or authorisation code.",
          "createdAt": "2023-05-18T20:35:12Z",
          "updatedAt": "2023-05-18T20:35:35Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "How many implemantations out there actually use different grant types than auth-code?\r\nGiven that this serves our purposes and imo everybody is using auth-code, I think that we should RECOMMEND that scenario but I#m ok with showing up alternatives as you suggested.\r\n@tlodderstedt What's your opinion on this?",
          "createdAt": "2023-05-22T16:13:22Z",
          "updatedAt": "2023-05-22T16:13:22Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the flow can be used with and without nonce. \r\n\r\nIf it is used without nonce, jti and short expiration must be used to limit the risk. \r\nIf a nonce is used, I think using the codes is a pragmatic option. Alternatively, the AS could provide a dedicated nonce with the credential offer or authorization response. It could also provide the nonce with a token error response. ",
          "createdAt": "2023-05-23T07:35:49Z",
          "updatedAt": "2023-05-23T07:35:49Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "discussion on 23.05 is leaning towards DpoP-style error providing nonce",
          "createdAt": "2023-05-23T19:28:50Z",
          "updatedAt": "2023-05-23T19:28:50Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "can we please bring this issue forward, it is very important?\r\n\r\n> discussion on 23.05 is leaning towards DpoP-style error providing nonce\r\n\r\nI see some advantages in that approach as it would allow the AS to request nonce use for all endpoints (including PAR).",
          "createdAt": "2023-07-30T15:43:23Z",
          "updatedAt": "2023-07-30T15:43:23Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "on that topic, I would suggest such an AS provided nonce should be good up until the AS says otherwise. That would allow a client to use the same nonce for PAR and token endpoint.",
          "createdAt": "2023-07-30T15:44:37Z",
          "updatedAt": "2023-07-30T15:44:37Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Update provided in #39",
          "createdAt": "2023-09-06T06:56:35Z",
          "updatedAt": "2023-09-06T06:56:35Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "PR #49 ",
          "createdAt": "2023-10-08T15:17:05Z",
          "updatedAt": "2023-10-08T15:17:05Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "PR #49 ",
          "createdAt": "2023-10-08T15:18:03Z",
          "updatedAt": "2023-10-08T15:18:03Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOJaEkaM5mhKRe",
      "title": "Explain and discuss the options of ad-hoc and long-lasting client attestations",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/10",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "Options on requesting/generating the client/wallet attestation ad-hoc or in advance have been discussed and there are pros and cons for both sides. Is a short explanation of this suited for the RFC?",
      "createdAt": "2023-05-22T15:52:23Z",
      "updatedAt": "2023-09-06T06:56:00Z",
      "closedAt": "2023-09-06T06:56:00Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Suggest closing as we shouldn't comment on attestation token lifetimes anymore then OAuth2 comments on expected AT lifetimes, its at the discretion of the implementation which is often highly deployment specific.",
          "createdAt": "2023-09-06T06:56:00Z",
          "updatedAt": "2023-09-06T06:56:00Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOJaEkaM5nOgXk",
      "title": "Why not just use the same client attestation JWT? That would not require any client instance identification and is also not a privacy issue.",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/12",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tplooker"
      ],
      "labels": [],
      "body": "              Why not just use the same client attestation JWT? That would not require any client instance identification and is also not a privacy issue. \r\n\r\nurn:ietf:params:oauth:client-assertion-type:jwt-key-attestation -> urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation\r\n\r\n_Originally posted by @tlodderstedt in https://github.com/vcstuff/draft-looker-oauth-attested-key-based-client-authentication/pull/11#discussion_r1201683953_\r\n            ",
      "createdAt": "2023-05-30T09:15:06Z",
      "updatedAt": "2023-09-08T21:43:06Z",
      "closedAt": "2023-09-08T21:43:06Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #31. The problem with this model is that the refresh token if bound to the client attestation JWT then limits the RT lifetime.",
          "createdAt": "2023-09-06T06:53:51Z",
          "updatedAt": "2023-09-06T06:53:51Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOJaEkaM5nQFkc",
      "title": "Client Key Attestation JWT Example",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/13",
      "state": "OPEN",
      "author": "fmarino-ipzs",
      "authorAssociation": "NONE",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "In the example in section 3.1.1. the issuer and the sub parameters should not be the same since the Wallet provider and the wallet instance are distinct entities. The private key in sole control of the wallet instance is referenced in the attestation while the subject refers to the Wallet Provider. \r\n\r\nMoreover, is the given example meant to be normative? I'm asking since in the example we find the JWS header parameter kid without any explanatory text about the key resolution mechanism allowed in the specs. (x5c, trust_chain, jwk)\r\n\r\n",
      "createdAt": "2023-05-30T13:22:00Z",
      "updatedAt": "2023-11-12T14:11:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "re 1: the wallet instance is an instance of the software published by the wallet provider. Setting the sub to the issuer value is a plausible option as the wallet provider issued an attestation to one of its instances. It most notably prevents tracking of wallet instances (aka super cookies).\r\nre 2: this draft (as all OAuth WG drafts) is a base module to be used in the context of a certain profile. Such a profile would define how the keys are resolved. There will be definitely be a definition on the level of the OID4VC High Assurance Interoperability Profile.  ",
          "createdAt": "2023-07-05T12:47:01Z",
          "updatedAt": "2023-07-05T12:47:01Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "regarding the value of the sub claim in the WAI: since the wallet instance attestation is binded to a public key, we are not forced to use a unique and immutable subject identifier but instead a unique identifier with the same lifetime of the related key. That's why I suggest to place the jwk thumbprint value as sub or any other collision resistant value\r\n\r\nanyway I think that's an implementation choice if not of interest in this specs, I'd ask to remove any constraint to have iss equal to sub, since doesn't make any sense following the awareness that the wallet provider and the wallet instance are distinct entities, even if part of the same wallet solution, then they should not use the same entity identifier\r\n\r\n",
          "createdAt": "2023-07-05T23:36:44Z",
          "updatedAt": "2023-07-05T23:36:44Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see any constraints in the spec regarding the `sub` value. Please point our if I missed one. ",
          "createdAt": "2023-07-06T06:56:05Z",
          "updatedAt": "2023-07-06T06:56:05Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "I had a check, now I can confirm.\r\nHappy to have put a stone with you on that\r\n",
          "createdAt": "2023-07-06T09:22:14Z",
          "updatedAt": "2023-07-06T09:22:14Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Following the generalisation proposed in #32 if merged then we will need to constrain the sub value to being the client_id to ensure client identification and authentication can take place. Multiple client instances sharing a single client_id is not a new pattern and is common place for public clients.",
          "createdAt": "2023-09-06T06:51:43Z",
          "updatedAt": "2023-09-06T06:51:43Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "As of now, I think there is consensus to have `sub` as client_id.\r\nPending close if no objections",
          "createdAt": "2023-10-08T15:19:18Z",
          "updatedAt": "2023-10-08T15:19:18Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "I agreed that `sub` must have the same value of `client_id` but I didn't agreed that the specs should say which must be their value.\r\nI agree @TakahikoKawasaki 's comment [here](https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/issues/32#issuecomment-1637028939) and I think that different implementations and models may distinguish the wallet instance from the wallet provider as different entities",
          "createdAt": "2023-10-09T09:14:20Z",
          "updatedAt": "2023-10-09T09:14:20Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> I agreed that sub must have the same value of client_id but I didn't agreed that the specs should say which must be their value.\r\nI agree @TakahikoKawasaki 's comment https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/issues/32#issuecomment-1637028939 and I think that different implementations and models may distinguish the wallet instance from the wallet provider as different entities\r\n\r\n@peppelinux apologies we are struggling to understand what you mean here, can you possibly clarify?",
          "createdAt": "2023-11-06T08:06:08Z",
          "updatedAt": "2023-11-06T08:06:08Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "Ciao @tplooker \r\n\r\n`iss` is the entity that attests an instance, while `sub` is the instance.\r\nin my current implementation the first is the wallet provider, the latter is the End-User personal device.\r\n\r\nWe have found a good compromise with @paulbastian to not force in the specs a specific value, in a way to not force that `iss` value must be equal to `sub`. Wee agreed and everything seems fine to date.",
          "createdAt": "2023-11-06T17:31:46Z",
          "updatedAt": "2023-11-06T17:31:46Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @peppelinux, if you dont mind, could you copy in an example of your client attestation JWT just so we can be 100% aligned, what I'm trying to understand is whether the sub value you are using is unique per user? Because our proposal above is simply for the sub value to be the client ID which for public clients would mean the same sub value across multiple instances of the same client.",
          "createdAt": "2023-11-06T21:52:28Z",
          "updatedAt": "2023-11-06T21:52:28Z"
        },
        {
          "author": "TakahikoKawasaki",
          "authorAssociation": "NONE",
          "body": "@tplooker \r\nThe example of \"wallet instance attestation\" (which corresponds to the \"client attestation JWT\") in the [page 9](https://docs.google.com/presentation/d/1xcUyrPZbOyAS5-aSk189L0n7CMIZyuGI7jqLtmZfHPE/#slide=id.g6340a851bc_0_56) of \"[Discover the Italian Wallet](https://docs.google.com/presentation/d/1xcUyrPZbOyAS5-aSk189L0n7CMIZyuGI7jqLtmZfHPE/)\" indicates that the value of the `sub` is not a client application identifier but an identifer unique per user (per client instance key).\r\n\r\nTo be exact, the Italian technical document, \"[Wallet Instance Attestation](https://italia.github.io/eudi-wallet-it-docs/versione-corrente/en/wallet-instance-attestation.html)\", defines the `sub` as follows.\r\n\r\n> Thumbprint value of the JWK of the Wallet Instance for which the attestation is being issued.\r\n\r\nAs an implementer of an authorization server that plans to support the \"OAuth 2.0 Attestation-Based Client Authentication\" specification, I'm looking for a way to support both the cases at the same time where (1) `sub` is a client application identifier or (2) `sub` is a unique identifier per client instance key.",
          "createdAt": "2023-11-06T23:33:30Z",
          "updatedAt": "2023-11-06T23:33:30Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @TakahikoKawasaki can you elaborate on the usecase/rationale for why the client attestation needs to include a client instance (or user unique) identifier in the attestation? For example the reason the attestation must include a client_id somewhere is because the authorisation server needs to know which client is making the request, but generally as is the case with public clients, the authorisation server doesn't care which specific instance is making the request. ",
          "createdAt": "2023-11-06T23:37:52Z",
          "updatedAt": "2023-11-06T23:37:52Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #57 ",
          "createdAt": "2023-11-06T23:39:41Z",
          "updatedAt": "2023-11-06T23:39:41Z"
        },
        {
          "author": "TakahikoKawasaki",
          "authorAssociation": "NONE",
          "body": "@tplooker \r\nTo be honest, I don't care about the rationale behind the value of the `sub` claim in the \"Client Attestation JWT\". Because authorization server implementations can know the client application identifier from the `iss` claim in \"Client Attestation **PoP** JWT\", the value of the `sub` claim in the \"Client Attestation JWT\" is not necessary to identify the client application.\r\n\r\nIf the specification says \"the `sub` claim in the Client Attestation JWT must be identical to the client application identifier\", authorization server implementations must reject requests from Italian wallets. On the contrary, if the specification says \"the `sub` claim in the Client Attestation JWT must be the JWK thumbprint of the client instance key\", authorization server implementations must reject requests from other wallets (e.g. IDunion wallets?) that set the client application identifier to the `sub` claim.\r\n\r\nGeneral-purpose authorization server implementations want to accept both requests at runtime, or at least want to be (statically) configurable to accept either of the two patterns. A simple resolution would be to define the value of the `sub` claim of the Client Attestation JWT as follows.\r\n\r\n- The client identifier or the JWK thumbprint of the client instance key\r\n\r\n",
          "createdAt": "2023-11-07T00:05:49Z",
          "updatedAt": "2023-11-07T00:05:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> To be honest, I don't care about the rationale behind the value of the sub claim in the \"Client Attestation JWT\". Because authorization server implementations can know the client application identifier from the iss claim in \"Client Attestation PoP JWT\", the value of the sub claim in the \"Client Attestation JWT\" is not necessary to identify the client application.\r\n\r\nI understand the AS can use the PoP to identify who the client is, but without a client_id in the client attestation its not really a client attestation instead its just a key attestation. Perhaps @peppelinux can you elaborate on why the sub value needs to be a JWK thumbprint in your implementation what does this enable?",
          "createdAt": "2023-11-07T04:13:57Z",
          "updatedAt": "2023-11-07T04:13:57Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "@tplooker \r\n\r\nThe `cnf.jwk` represents the identifier of the wallet instance. A wallet instance may have more than a private key and more than a single wallet instance attestation. Even using `iss` == `sub` the wallet instance attestation can be implicitly identified with the `cnf.jwk`.\r\n\r\nThe value of the `sub` claim is something to uniquely identify the subject, we should not mandate a specific value type but the only requirement to have unique value per wallet instances, while `iss` == `sub` == `client_id` doesn't make sense to me.\r\n\r\nI agree with Taka and at the same time I foudn a compromise with @paulbastian and at the end if `iss` == `sub` this will be ignored by the implementations because it doesn't bring any value, sense or benefit. It would be then better to remove `client_id` and `sub`. Anyway if this compromise to ignore the sub value helps the interop, I can buy but in Italy we're prone to distinguish the issuer from the subject because they are distinct entities, the first is the wallet instance attestation issuer, the latter is the wallet instance.",
          "createdAt": "2023-11-07T11:44:18Z",
          "updatedAt": "2023-11-07T23:49:29Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the explanation @peppelinux.\r\n\r\n> The value of the sub claim is something to uniquely identify the subject, we should not mandate a specific value type but the only requirement to have unique value per wallet instances, while iss == sub == client_id doesn't make sense to me.\r\n\r\nI think perhaps here is where there is a disconnect. At present in the specification, the attestation is called a \"client attestation\" not \"user attestation\" which is because the issuer of the attestation is a client and the subject is an instance that particular client.\r\n\r\nIf we make the change proposed in #32 then the issuer of the client attestation is no longer necessarily the client (or client backend) instead it could be any party that the authorization server trusts to make attestations about clients. However in that model the subject of the attestation is still always a client instance not a user.\r\n\r\nSo with the adoption of #32 the iss will no longer be the client ID meaning instead the client_id must feature somewhere else in the client attestation, otherwise the authorization server has no way to validate for which client an attestation it is presented has been produced for. The most practical change I see here would be for us to require the `sub` value to be the client_id of the client being attested.\r\n\r\nIn short with the change proposed above the iss value could be any string but the sub would then still have to be the client_id, would that work for your implementation? For a concrete example see here https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/issues/32#issuecomment-1637028939 as proposed by @TakahikoKawasaki ",
          "createdAt": "2023-11-08T00:15:08Z",
          "updatedAt": "2023-11-09T20:29:33Z"
        },
        {
          "author": "TakahikoKawasaki",
          "authorAssociation": "NONE",
          "body": "The following table summarizes the current spec, the Italian ecosystem, and possible compromises.\r\n\r\n| No. | Client Attestation JWT `iss` | Client Attestation JWT `sub` | Client Attestation JWT, new claim | Client Attestation PoP JWT `iss` | Memo |\r\n|:-:|:--|:--|:--|:--|:--|\r\n| 1 | Attester | Client ID | N/A | Client ID | The current spec. |\r\n| 2 | Client ID | Client ID | N/A | Client ID | The example in the current spec (excerpted in #32). My understanding is that the example is misleading because the current spec conceptually treats the attester and the client as different things. |\r\n| 3 | Attester | Thumbprint of Client Instance Key | N/A | Client ID | The Italian ecosystem |\r\n| 4 | Attester | Any | N/A | Client ID | Compromise A |\r\n| 5 | Attester | Client ID or Thumbprint of Client Instance Key | N/A | Client ID | Compromise B |\r\n| 6 | Attester | Client ID | Thumbprint of Client Instance Key | Client ID | Compromise C |\r\n| 7 | Attester | Thumbprint of Client Instance Key | Client ID | Client ID | Compromise D |\r\n| 8 | Attester | Any | Client ID | Client ID | Compromise E |\r\n| 9 | Attester | Any | Thumbprint of Client Instance Key | Client ID | Compromise F |\r\n| 10 | Attester | Client ID or Thumbprint of Client Instance Key | Client ID | Client ID | Compromise G |\r\n| 11 | Attester | Client ID or Thumbprint of Client Instance Key | Thumbprint of Client Instance Key | Client ID | Compromise H |\r\n",
          "createdAt": "2023-11-08T01:09:27Z",
          "updatedAt": "2023-11-08T01:09:27Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @TakahikoKawasaki for your write up. @peppelinux if the main intent of your use-case is to support identifying the client instance, then I believe as you highlight above that can be accomplished via the `cnf` claim. Therefore we can leave the `sub` claim as the client_id value. Will that work for your deployment?\r\n\r\n",
          "createdAt": "2023-11-09T20:33:52Z",
          "updatedAt": "2023-11-09T20:33:52Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "@tplooker \r\n\r\n> If we make the change proposed in #32 then the issuer of the client attestation is no longer necessarily the client (or client backend) instead it could be any party that the authorization server trusts to make attestations about clients. However in that model the subject of the attestation is still always a client instance not a user.\r\n\r\nI didn't mention any user, a subject could be any kind of entity, like a robot, a machine, a client, etc.\r\n\r\n> Therefore we can leave the sub claim as the client_id value. Will that work for your deployment?\r\n\r\nIn my deployment the `sub` value, then the client_id, is the thumbprint value of the cnf.jwk and this is therefore different from the `iss` value.\r\n\r\nThanks to @TakahikoKawasaki for his memorable contributions.\r\n",
          "createdAt": "2023-11-12T14:11:44Z",
          "updatedAt": "2023-11-12T14:11:44Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOJaEkaM5nQJz8",
      "title": "The Entity Attestation Token (EAT)",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/14",
      "state": "CLOSED",
      "author": "peppelinux",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Is there any considerations about adopting *The Entity Attestation Token (EAT)* [draft-ietf-rats-eat-12](https://datatracker.ietf.org/doc/draft-ietf-rats-eat/12/) for the Attestation JWT?",
      "createdAt": "2023-05-30T13:31:55Z",
      "updatedAt": "2023-09-06T06:48:55Z",
      "closedAt": "2023-09-06T06:48:55Z",
      "comments": [
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it is sufficient to add that JWT Claims defined in EAT draft can be put in the attestation JWT?",
          "createdAt": "2023-07-06T19:05:10Z",
          "updatedAt": "2023-07-06T19:05:10Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "EAT is a more general purpose token format, however as highlight by @Sakurann implementations are free to make use of claims registered by EAT for their purposes.",
          "createdAt": "2023-09-06T06:48:47Z",
          "updatedAt": "2023-09-06T06:48:47Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOJaEkaM5nQSkv",
      "title": "Security levels in the attestation",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/15",
      "state": "CLOSED",
      "author": "fmarino-ipzs",
      "authorAssociation": "NONE",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "Since the EUDI Wallet instance may have different level of security depending on its own hardware and/or software capabilities, here the proposal: define a claim name for exposing different level of security of the wallet instance.\r\n\r\nExample:\"gold\", \"silver\" and \"bronze\" or \"high\", \"medium\", \"low\" depending on the framework used. \r\n\r\nThis proposal enables the security evaluation to the credential issuing side (or any other Relying Party) without knowing any specific hardware or software features (e.g. OS, etc.). ",
      "createdAt": "2023-05-30T13:52:15Z",
      "updatedAt": "2024-10-09T06:57:33Z",
      "closedAt": "2024-10-09T06:57:33Z",
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "The RFC may be used to issue wallet attestations in the eIDAS use case, giving additional information on the key type of the `cnf` and the user authenticaiton mechanisms, see more info [here](https://www.linkedin.com/feed/update/urn:li:activity:7056179875635724289/). A Wallet alone does not achieve a LoA but only supports the issuer in achieving an LoA for the lifecycle of an issues credential. However, a claim `supported_LoA` could be useable",
          "createdAt": "2023-05-30T15:18:52Z",
          "updatedAt": "2023-05-30T15:18:52Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "Here the proposal raised in the italian implementation\r\n\r\n`asc_values_supported` and `asc`\r\n\r\nwhere ASC is the acronym of Attested Security Context\r\n\r\nthis aims do disambiguate the meaning of LoA, that is referred to person identities, to the scope of this attestation, that's entirely related to the security context of a personal device \r\n\r\n#### asc_values_supported\r\n\r\nis a capability of the wallet provider, that defines which kind of checks/levels is able to attests to its wallet instances\r\n\r\n#### asc \r\n\r\nis the claim issued in the Wallet Instance Attestation",
          "createdAt": "2023-06-17T12:46:20Z",
          "updatedAt": "2023-06-17T12:47:50Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "the parameter name was renamed to `attested_security_context` (ASC) and we read it here:\r\nhttps://github.com/vcstuff/draft-looker-oauth-attestation-based-client-auth/blob/main/draft-looker-oauth-attestation-based-client-auth.md#wallet-instance-attestation\r\n\r\nIn that form **it is just a non-normative example, so some explanatory/normative text is needed**.\r\n\r\nASC aims to introduce a classification for the common capabilities of the device/mobile-app and a simple evaluation by the issuers.\r\n\r\nGenerally, it\r\n\r\n- avoids that the issuers should take any responsability by attesting `key_type` and `user_authentication`, since the sole responsability of the wallet security compliance is up to the wallet provider\r\n\r\n- avoids the implicit disclosure of system internals or mobile os name/brand. These could be derived by knowing the `key_type`, since there are some technologies that are only available on some specific platforms/os/versions. Then it improves the privacy, because the issuer cannot know which mobile os the user prefers or simply uses.\r\n\r\n-  requires a common framework where different device capabilities and user auth method must be mapped, classified and grouped in the ASC levels. A matrix with the key_types and user_auth values, grouped by each ASC level, is then required (but probably outside of the scope of this specs). \r\n\r\n- avoids that future features that today still don't exist, for example `key_type: \"super-Strong-box-3.0\"`, don't introduce anything more to the issuers that just need to know which are the ASC level and the one carried in the WIA, without any details (mandated to a common framework)\r\n\r\nexample of how the ACS levels could be defined can be found in literature as they was for ACR and AMR.",
          "createdAt": "2023-07-29T21:44:38Z",
          "updatedAt": "2023-07-30T18:13:20Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "While I agree that ASC is a good idea, the argument for privacy is negligible as every browser user sends the OS information anyway, additional information of the key type is very small.\n\nThe argument for simplicity, that the issuer does not need to do a mapping, is the strong argument here, but we are missing the mapping right now.",
          "createdAt": "2023-07-29T22:23:36Z",
          "updatedAt": "2023-07-29T22:24:54Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "good point,\r\n\r\nfor my personal experience I think that the level of privacy of a web browser can be configured by the User that is able to install additional privacy extensions as well.\r\n\r\nthe mapping is in the todo list, would this specs hosts a baseline of this mapping or do you think that it would be better to have it out of this spec? ",
          "createdAt": "2023-07-30T18:10:38Z",
          "updatedAt": "2023-07-30T18:10:38Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #29 ",
          "createdAt": "2023-09-06T06:47:46Z",
          "updatedAt": "2023-09-06T06:47:46Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Solved in #48 ",
          "createdAt": "2023-10-08T15:21:44Z",
          "updatedAt": "2023-10-08T15:21:44Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "I think we can close this?",
          "createdAt": "2024-08-28T13:42:56Z",
          "updatedAt": "2024-08-28T13:42:56Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "key attestations and associated parameters will be handled separately in [OpenID4VCI](https://github.com/openid/OpenID4VCI/pull/389)",
          "createdAt": "2024-10-09T06:57:33Z",
          "updatedAt": "2024-10-09T06:57:33Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOJaEkaM5nyl4B",
      "title": "Reanme Grant Type to JWT-PoP?",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/17",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "Issue raised by Kristina:\r\nI also perceive this draft as a PoP version of urn:ietf:params:oauth:grant-type:jwt-bearer, would it make sense to make that more intuitive and explicit - like urn:ietf:params:oauth:grant-type:jwt-pop? - this can be another issue\r\n\r\n_Originally posted by @Sakurann in https://github.com/vcstuff/draft-looker-oauth-attested-key-based-client-authentication/pull/11#pullrequestreview-1451679914_\r\n            ",
      "createdAt": "2023-06-05T08:59:41Z",
      "updatedAt": "2023-11-06T08:00:33Z",
      "closedAt": "2023-11-06T08:00:33Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "@Sakurann can you please review the latest terminology in the draft and let us know if you have any issue with it?",
          "createdAt": "2023-09-06T06:46:52Z",
          "updatedAt": "2023-09-06T06:46:52Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that this draft is defining an OAuth client authentication method and *not* a grant type (yes RFC7521 has both but this draft only deals with client auth). So there may well be room for improvement in terminology but it shouldn't be about grant type.",
          "createdAt": "2023-09-25T18:40:04Z",
          "updatedAt": "2023-09-25T18:40:04Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Pending close if there are no objections",
          "createdAt": "2023-10-08T15:22:24Z",
          "updatedAt": "2023-10-08T15:22:24Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOJaEkaM5oo1Wx",
      "title": "client_assertion_type",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/18",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "              I perceive this draft as a PoP version of `urn:ietf:params:oauth:grant-type:jwt-bearer`, would it make sense to make that more intuitive and explicit - like `urn:ietf:params:oauth:grant-type:jwt-pop`?\r\n\r\n_Originally posted by @Sakurann in https://github.com/vcstuff/draft-looker-oauth-attested-key-based-client-authentication/pull/11#discussion_r1210728395_\r\n            ",
      "createdAt": "2023-06-13T19:34:04Z",
      "updatedAt": "2023-09-06T06:45:42Z",
      "closedAt": "2023-09-06T06:45:42Z",
      "comments": [
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "is this duplicate of #17 ?",
          "createdAt": "2023-07-06T19:02:12Z",
          "updatedAt": "2023-07-06T19:02:12Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOJaEkaM5pQ52B",
      "title": "Change Client Attestation JWT to SD-JWT",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/20",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If we use SD-JWT instead of JWT for Client Attestation, things might be easier and its a good test case for using SD-JWT without Disclosures",
      "createdAt": "2023-06-20T19:38:28Z",
      "updatedAt": "2023-07-07T15:36:19Z",
      "closedAt": "2023-07-07T15:36:19Z",
      "comments": [
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "SD-JWT VC as defined in [draft-terbu-sd-jwt-vc](https://github.com/vcstuff/draft-terbu-sd-jwt-vc) without SD, right? (we should differentiate with core sd-jwt)",
          "createdAt": "2023-07-06T19:01:00Z",
          "updatedAt": "2023-07-06T19:01:08Z"
        },
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "what is the use-case for the wallet attestation with selective disclosure?",
          "createdAt": "2023-07-06T19:09:01Z",
          "updatedAt": "2023-07-06T19:09:01Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "we probably don't need selective disclosure. SD-JWT-VC gives some feature like easy holder-binding with tilde and key discovery etc that we would need replicate with plain JWTs",
          "createdAt": "2023-07-06T19:18:51Z",
          "updatedAt": "2023-07-06T19:18:51Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "whether to rely on SD-JWT or SD-JWT-VC is yet another option to discuss",
          "createdAt": "2023-07-06T19:19:37Z",
          "updatedAt": "2023-07-06T19:19:37Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "in the discussion on July 6th, it was agreed to stay with plain JWT for now",
          "createdAt": "2023-07-07T15:36:19Z",
          "updatedAt": "2023-07-07T15:36:19Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOJaEkaM5p9Z-V",
      "title": "Terms and Definitions are run together",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/24",
      "state": "CLOSED",
      "author": "selfissued",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the Terminology section, the term names and term definitions are run together with no punctuation between them.  For example:\r\n> Client Attestation JWT A JSON Web Token (JWT) generated by the client backend which is bound to a key managed by a client instance which can then be used by the instance for client authentication.\r\n\r\nI suggest emulating the formatting in https://openid.bitbucket.io/connect/openid-4-verifiable-credential-issuance-1_0.html#name-terminology.",
      "createdAt": "2023-06-27T20:29:52Z",
      "updatedAt": "2023-07-05T20:43:17Z",
      "closedAt": "2023-07-05T20:43:17Z",
      "comments": []
    },
    {
      "number": 27,
      "id": "I_kwDOJaEkaM5q6iJF",
      "title": "Send Client Attestation with Authorization Request instead of Token Request",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/27",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tplooker"
      ],
      "labels": [],
      "body": "There is an idea to send the Client attestation already in Authorization Request or PAR instead of with the Token Request.\r\nI see the following advantages:\r\n - the client attestation could act as some kind of mobile capability descriptor, thus allowing the Authorization Server(Issuer) to check these before the user performs user authentication, otherwise this could result in poor UX as the user authenticates and the AS realizes only afterwards in Token Request that the level of client attestation is not enough (e.g. wallet can only handle key type xyz or LoA low)\r\n\r\nI see the following disadvantage:\r\n- some flows do not require Authorization Request\r\n- the user usually does not give consent before sending Authorization Request",
      "createdAt": "2023-07-07T15:20:37Z",
      "updatedAt": "2023-09-08T21:46:00Z",
      "closedAt": "2023-09-08T21:46:00Z",
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The client attestation can for sure be used to authenticate with PAR. The HAIP already requires that. ",
          "createdAt": "2023-07-07T15:23:06Z",
          "updatedAt": "2023-07-07T15:23:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "The draft just needs to be clarified that this is a general purpose client authentication method that can be used with any interaction with an AS that is requiring or making use of client authentication.",
          "createdAt": "2023-09-06T06:45:35Z",
          "updatedAt": "2023-09-06T06:45:35Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOJaEkaM5rDmRt",
      "title": "Diagram exceeds 72 charaters",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/28",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "IETF drafts are expected to not exceed 72 characters per line. The diagram in the Introduction currently takes 91",
      "createdAt": "2023-07-10T06:55:56Z",
      "updatedAt": "2023-10-23T20:17:37Z",
      "closedAt": "2023-10-23T20:17:37Z",
      "comments": []
    },
    {
      "number": 29,
      "id": "I_kwDOJaEkaM5rEv0s",
      "title": "[IANA Registry] attested_security_context as JWT parameter",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/29",
      "state": "CLOSED",
      "author": "peppelinux",
      "authorAssociation": "NONE",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "The brand new parameter called `attested_security_context`, as defined [here](https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-auth/pull/26/files#diff-55e05bec82593426ed363ab5c93ddf1e82b0f64cdf164f98e85fe1236b8783edR325), requires a IANA section for the registration of this parameter name\r\n\r\n",
      "createdAt": "2023-07-10T09:57:59Z",
      "updatedAt": "2024-10-09T06:57:51Z",
      "closedAt": "2024-10-09T06:57:50Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Registration is no longer required as this section was shifted to a non-normative example. We are still discussing as editors whether registration of some form of claim for this purpose is valuable for the draft.",
          "createdAt": "2023-09-06T06:43:00Z",
          "updatedAt": "2023-09-06T06:43:00Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "key attestations and associated parameters will be handled separately in [OpenID4VCI](https://github.com/openid/OpenID4VCI/pull/389)",
          "createdAt": "2024-10-09T06:57:50Z",
          "updatedAt": "2024-10-09T06:57:50Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOJaEkaM5rrKKF",
      "title": "typ values for Client Attestation JWT and Client Attestation PoP JWT",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/30",
      "state": "CLOSED",
      "author": "TakahikoKawasaki",
      "authorAssociation": "NONE",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "The current draft does not require the Client Attestation JWT and Client Attestation PoP JWT to have the `typ` JWS header parameter. Do you have any plans to define specific `typ` values for these JWTs?",
      "createdAt": "2023-07-16T07:29:52Z",
      "updatedAt": "2024-10-21T19:03:23Z",
      "closedAt": "2024-10-21T19:03:23Z",
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. Need to properly define header section",
          "createdAt": "2023-09-06T06:39:22Z",
          "updatedAt": "2023-09-06T06:39:22Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "May also require IANA considerations for registration.",
          "createdAt": "2023-09-06T06:40:11Z",
          "updatedAt": "2023-09-06T06:40:11Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposing `jwt-client-attestation` , `jwt-client-attestation-pop`",
          "createdAt": "2023-09-06T06:42:02Z",
          "updatedAt": "2023-09-06T06:42:02Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "JWS/JWT typ is a media type and based on https://datatracker.ietf.org/doc/html/rfc8725#name-use-explicit-typing I'd propose something like `oauth-client-attestation+jwt` and `oauth-client-attestation-pop+jwt`\r\n\r\nAnd FWIW you can kinda follow how DPoP registered and used the `application/dpop+jwt` media type to allow for explicit typing there https://www.rfc-editor.org/rfc/rfc9449.html or `application/at+jwt` from https://datatracker.ietf.org/doc/html/rfc9068 ",
          "createdAt": "2023-11-03T19:48:07Z",
          "updatedAt": "2023-11-03T19:48:07Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOJaEkaM5rrPuP",
      "title": "The same client attestation for the refresh token flow",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/31",
      "state": "CLOSED",
      "author": "TakahikoKawasaki",
      "authorAssociation": "NONE",
      "assignees": [
        "tplooker"
      ],
      "labels": [],
      "body": "The \"Refresh token binding\" section requires _\"The client MUST also use the same Client Attestation.\"_\r\n\r\nWhat is the intention of the requirement from the following options?\r\n\r\n1. **The exactly same client attestation JWT.** The refresh token becomes invalid after the client attestation JWT expires. **Even if the attester issues a new client attestation JWT for the same client key, the new client attestation JWT would not work with the refresh token.** If the requirement expects this behavior, AS implementations would simply use the hash of the client attestation JWT to judge whether the client attestation JWT presented in the refresh token flow is identical to the previous one.\r\n2. **Any client attestation JWT for the same client key issued by the same attester.** If this is the actual intention of the requirement, even after the original client attestation JWT expires, the refresh token can be used with a new client attestation JWT issued by the same attester. In this case, AS implementations would check the combination of the attester's identifier and the client key during the refresh token flow.\r\n3. **Any client attestation JWT for the same client key issued by any attester the AS trusts.** If this is the actual intention of the requirement, even after the original client attestation JWT expires and/or even after the attester ceases its service, the refresh token can be used with a new client attestation issued by any attester the AS trusts. In this case, AS implementations would check the JWK thumbprint of the client key only during the refresh token flow and would not check whether the attester is identical to the one of the previous client attestation JWT.\r\n\r\nFYI: [RFC 8705](https://www.rfc-editor.org/rfc/rfc8705.html) defines a mechanism to bind an X.509 certificate to an access token. The specification states that a JWT access token should include `\"x5t#S256\"` (which represents the SHA-256 thumprint of an X.509 certificate) in its payload if the access token is bound to a certain X.509 certificate. It results in that certificate-bound access tokens and refresh tokens expire when their X.509 certificates expire and that renewing X.509 certificates for the same subject does NOT revive the access tokens and refresh tokens. Therefore, client applications have to go through an authorization flow again to get a new access token once the X.509 certificate bound to the previous access token expires.\r\n\r\nThere are pros and cons. The requirement will need to be rephrased depending on what the \"refresh token binding\" wants to achieve.",
      "createdAt": "2023-07-16T08:37:24Z",
      "updatedAt": "2023-09-08T21:43:05Z",
      "closedAt": "2023-09-08T21:43:05Z",
      "comments": [
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, the statement \"The client MUST also use the same Client Attestation that was used for authentication when the refresh token was issued.\" is problematic and needs to be removed or rephrased. \r\n\r\nThe intent, as I understand it from previously discussing/pushing the issue of RT binding for this draft, is that the RT needs to be bound to the client instance. And that means binding the RT to the client instance's key. I think Tobias didn't want to go so far as saying that b/c he thought it was too inflexible. But the client instance's key is currently the only thing here that uniquely identifies the client instance. ",
          "createdAt": "2023-07-20T21:28:07Z",
          "updatedAt": "2023-07-20T21:28:07Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "@bc-pi is correct around the intent here, I agree the wording makes it unclear so it should be clarified that the binding is to the client instance key used when the RT was issued.",
          "createdAt": "2023-09-06T06:38:30Z",
          "updatedAt": "2023-09-06T06:38:30Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOJaEkaM5rrQsf",
      "title": "Client Backend -> Client Attester",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/32",
      "state": "CLOSED",
      "author": "TakahikoKawasaki",
      "authorAssociation": "NONE",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "\"Client Backend\" in the specification should be replaced with \"Client Attester\".\r\n\r\n\"Client Backend\" creates the impression that both the client and the system issuing the attestation for the client are managed by the same entity. While it is possible for actual deployments to be structured in this manner, it appears that the specification intends to treat them as separate entities.",
      "createdAt": "2023-07-16T08:52:40Z",
      "updatedAt": "2025-04-03T06:54:56Z",
      "closedAt": "2025-04-03T06:54:55Z",
      "comments": [
        {
          "author": "TakahikoKawasaki",
          "authorAssociation": "NONE",
          "body": "In that sense, the example payload of the Client Attestation JWT in the \"Client Attestation JWT\" section should be updated from\r\n\r\n```json\r\n{\r\n  \"iss\": \"https://client.example.com\",\r\n  \"sub\": \"https://client.example.com\",\r\n  \"nbf\":1300815780,\r\n  \"exp\":1300819380,\r\n  \"cnf\": {\r\n    \"jwk\": {\r\n      \"kty\": \"EC\",\r\n      \"use\": \"sig\",\r\n      \"crv\": \"P-256\",\r\n      \"x\": \"18wHLeIgW9wVN6VD1Txgpqy2LszYkMf6J8njVAibvhM\",\r\n      \"y\": \"-V4dS4UaLMgP_4fY4j8ir7cl1TXlFdAgcx55o7TkcSA\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nto\r\n\r\n\r\n```json\r\n{\r\n  \"iss\": \"https://attester.example.com\",\r\n  \"sub\": \"https://client.example.com\",\r\n  \"nbf\":1300815780,\r\n  \"exp\":1300819380,\r\n  \"cnf\": {\r\n    \"jwk\": {\r\n      \"kty\": \"EC\",\r\n      \"use\": \"sig\",\r\n      \"crv\": \"P-256\",\r\n      \"x\": \"18wHLeIgW9wVN6VD1Txgpqy2LszYkMf6J8njVAibvhM\",\r\n      \"y\": \"-V4dS4UaLMgP_4fY4j8ir7cl1TXlFdAgcx55o7TkcSA\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n(Changing the value of the `\"iss\"` from `\"https://client.example.com\"` to `\"https://attester.example.com\"`)",
          "createdAt": "2023-07-16T08:58:45Z",
          "updatedAt": "2023-07-16T08:58:45Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Hello @TakahikoKawasaki we are having the exact same discussions between the editors, so thanks for your feedback! If you have any further rationale for having separate entities, please let us know",
          "createdAt": "2023-07-16T10:17:53Z",
          "updatedAt": "2023-07-16T10:17:53Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I've discussed this issue today with my colleague, we agree to this change.\r\nEspecially `sub` should match the `client_id` in the issuance.\r\nVersion might be separated into an additional, optional attribute",
          "createdAt": "2023-07-18T14:16:55Z",
          "updatedAt": "2023-07-18T14:16:55Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "add text on iss and sub",
          "createdAt": "2023-09-06T06:52:17Z",
          "updatedAt": "2023-09-06T06:52:17Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The `iss` of the Client Attestation JWT should identify the issuer of the Client Attestation JWT. When it's the client backend (which I think will be a common case), the `iss` value should be the client id value and the verification key should be found from the `jwks_uri` or `jwks_uri` field of that client (however that client info comes to exist with the AS). When the Client Attestation JWT is issued by some attestation service, the `iss` value should identify that service. And the AS needs to trust the service for this purpose and know how to find verification keys for it. \r\n\r\nThe `sub` of the Client Attestation JWT should be the client id value. ",
          "createdAt": "2023-11-09T22:07:39Z",
          "updatedAt": "2023-11-09T22:07:39Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "> The `iss` of the Client Attestation JWT should identify the issuer of the Client Attestation JWT. When it's the client backend (which I think will be a common case), the `iss` value should be the client id value and the verification key should be found from the `jwks_uri` or `jwks_uri` field of that client (however that client info comes to exist with the AS). When the Client Attestation JWT is issued by some attestation service, the `iss` value should identify that service. And the AS needs to trust the service for this purpose and know how to find verification keys for it. \n> \n> The `sub` of the Client Attestation JWT should be the client id value. \n\nThis is exactly my opinion.",
          "createdAt": "2023-11-09T22:17:13Z",
          "updatedAt": "2023-11-09T22:17:13Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, I'm not totally convinced there's really a need to allow for an attestation service that's not managed by the same entity as the client but other folks seem to want it so my prior comment assumes it. ",
          "createdAt": "2023-11-09T22:30:44Z",
          "updatedAt": "2023-11-09T22:32:18Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Solved by #100 ",
          "createdAt": "2025-04-03T06:54:55Z",
          "updatedAt": "2025-04-03T06:54:55Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDOJaEkaM5sKCbK",
      "title": "Attestation JWT should be reusable but there's contradictory text ",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/33",
      "state": "CLOSED",
      "author": "bc-pi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tplooker"
      ],
      "labels": [],
      "body": "The Client Attestation JWT seems like a long(er) lived credential that should be reusable so the client instance doesn't have to go get a new one each time (right?*).  But this text [here](https://www.ietf.org/archive/id/draft-looker-oauth-attestation-based-client-auth-00.html#section-4.1.1-2.7) for the Client Attestation JWT has 'The authorization server MAY ensure that JWTs are not replayed by maintaining the set of used \"jti\" values for the length of time for which the JWT would be considered valid based on the applicable \"exp\" instant' that suggests the AS might limit them to single use. I think that sentence can just be removed. \r\n\r\n\r\n\\* right: https://www.ietf.org/archive/id/draft-looker-oauth-attestation-based-client-auth-00.html#name-reuse-of-a-client-attestati ",
      "createdAt": "2023-07-20T18:26:11Z",
      "updatedAt": "2023-09-07T21:03:31Z",
      "closedAt": "2023-09-07T21:03:31Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, need to remove this sentence from step 7 of 4.1.1.",
          "createdAt": "2023-09-06T06:34:06Z",
          "updatedAt": "2023-09-06T06:34:06Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "I_kwDOJaEkaM5sKH5r",
      "title": "PoP JWT example is not consistent with spec text",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/34",
      "state": "CLOSED",
      "author": "bc-pi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tplooker"
      ],
      "labels": [],
      "body": "The text says jti is required https://www.ietf.org/archive/id/draft-looker-oauth-attestation-based-client-auth-00.html#section-4.1.2-2.3 but the example doesn't have jti https://www.ietf.org/archive/id/draft-looker-oauth-attestation-based-client-auth-00.html#section-4.1.2-3\r\n",
      "createdAt": "2023-07-20T18:38:19Z",
      "updatedAt": "2023-09-07T21:03:31Z",
      "closedAt": "2023-09-07T21:03:31Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate of #37 ",
          "createdAt": "2023-09-06T06:32:25Z",
          "updatedAt": "2023-09-06T06:32:25Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "I_kwDOJaEkaM5sN-zP",
      "title": "Should token_endpoint_auth_signing_alg be considered?",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/35",
      "state": "OPEN",
      "author": "TakahikoKawasaki",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "[OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html), [Section 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata), defines the `token_endpoint_auth_signing_alg` client metadata as follows.\r\n\r\n>OPTIONAL. [JWS](https://openid.net/specs/openid-connect-registration-1_0.html#JWS) [JWS] `alg` algorithm [[JWA]](https://openid.net/specs/openid-connect-registration-1_0.html#JWA) that MUST be used for signing the JWT [[JWT]](https://openid.net/specs/openid-connect-registration-1_0.html#JWT) used to authenticate the Client at the Token Endpoint for the `private_key_jwt` and `client_secret_jwt` authentication methods. All Token Requests using these authentication methods from this Client MUST be rejected, if the JWT is not signed with this algorithm. Servers SHOULD support `RS256`. The value `none` MUST NOT be used. The default, if omitted, is that any algorithm supported by the OP and the RP MAY be used.\r\n\r\nShould server-side implementations of the `attest_jwt_client_auth` client authentication method take the client metadata into consideration? To be concrete, should server-side implementations reject requests when the Client Attestation PoP JWT is not signed with the algorithm specified by the client metadata if the metadata is set, or may server-side implementations ignore the client metadata when processing the `attest_jwt_client_auth` client authentication method?",
      "createdAt": "2023-07-21T10:56:23Z",
      "updatedAt": "2025-08-12T06:52:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "In general I agree that a piece of metadata like this is useful, the other option which springs to mind is to reuse the token_endpoint_auth_signing_alg metadata property for this auth method instead of defining a new metadata element.",
          "createdAt": "2023-09-06T06:29:07Z",
          "updatedAt": "2023-09-06T06:29:07Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Which ever metadata element we choose for this purpose it should apply to BOTH the attestation JWT and PoP JWT.",
          "createdAt": "2023-09-06T06:29:43Z",
          "updatedAt": "2023-09-06T06:29:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "We would also need to clarify that the signing algorithm used for the attestation JWT and PoP JWT do not need to be the same however both would need to be permitted for the client making the request to the authorization server.",
          "createdAt": "2023-09-06T06:32:05Z",
          "updatedAt": "2023-09-06T06:32:05Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Considering this more I think it is safer to have a new seperate metadata element for signalling support algorithms for this client authentication mechanism.",
          "createdAt": "2023-11-06T07:59:13Z",
          "updatedAt": "2023-11-06T07:59:13Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "This probably now duplicates #70.",
          "createdAt": "2025-08-05T11:53:24Z",
          "updatedAt": "2025-08-05T11:53:24Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "I_kwDOJaEkaM5sTgXa",
      "title": "Sender-Constrained Access Token",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/36",
      "state": "CLOSED",
      "author": "TakahikoKawasaki",
      "authorAssociation": "NONE",
      "assignees": [
        "tplooker"
      ],
      "labels": [],
      "body": "The specification contains sentences related to sender-constrained acess tokens as follows.\r\n\r\n#### In the \"1. Introduction\" section:\r\n>... The Authorization Server may continue to issue sender-constrained access tokens using DPOP.\r\n\r\n#### In the \"4.1.1. Client Attestation JWT\" section:\r\n> The JWT MUST contain an \"cnf\" claim conforming RFC7800 that conveys the key to be used for sender constraining tokens issued by the authorization server. The key MUST be expressed using the \"jwk\" representation.\r\n\r\n### Questions\r\n\r\n**Q1.** \"**Client authentication**\" and \"**sender-constrained access token**\" are different. Is the specification trying to define requirements not only for client authentication but also for sender-constrained access tokens? (FYI: [RFC 8705](https://www.rfc-editor.org/rfc/rfc8705.html) defines \"client authentication\" in [Section 2](https://www.rfc-editor.org/rfc/rfc8705.html#section-2) and defines \"sender-constrained access token\" in [Section 3](https://www.rfc-editor.org/rfc/rfc8705.html#section-3).)\r\n\r\n**Q2.** DPOP is mentioned abruptly in the Introduction section but not referenced anywhere else. Is this mention of DPOP merely an example of sender-constrained access tokens, or is it a requirement to bind the Client Instance Key to the access token as if it were specified by DPOP? If it is not a normative requirement, mentioning DPOP would only cause confusion without any benefits. On the contrary, if it is a normative requirement, detailed explanation is needed.\r\n\r\n**Q3.** The explanation about the `cnf` claim of the Client Attestation JWT requires authorization server implementations to bind the Client Instance Key to access tokens. Is this normative requirement really intended? If it is intended, how does the client prove that it possesses the private key of the Client Instance Key when accessing protected resource endpoints? DPOP?",
      "createdAt": "2023-07-23T09:11:07Z",
      "updatedAt": "2024-01-26T03:43:14Z",
      "closedAt": "2024-01-26T03:43:13Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "The introduction text is fixed by #19 ",
          "createdAt": "2023-09-06T06:21:21Z",
          "updatedAt": "2023-09-06T06:21:21Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Q2 - We will clarify that any usage of this client authentication method with DPoP is entirely optional. It is as you highlight first and foremost a client authentication method.\r\n\r\nQ3 - This is a mistake in the language, thanks for highlighting as above, DPoP is entirely optional.",
          "createdAt": "2023-09-06T06:24:46Z",
          "updatedAt": "2023-09-06T06:24:46Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "The explicit reference to DPoP was removed from the introduction for now.\r\n\r\nI would consider adding it to implementation considerations as a recommendation to use DPoP-bound access tokens after client authentication with this spec to achieve a consistent security level",
          "createdAt": "2023-11-01T15:51:22Z",
          "updatedAt": "2023-11-01T15:51:22Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this issue has now been addressed, intend to close soon if there are no objections.",
          "createdAt": "2023-11-09T20:56:36Z",
          "updatedAt": "2023-11-09T20:56:36Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as I believe this now resolved, please reopen if need be.",
          "createdAt": "2024-01-26T03:43:13Z",
          "updatedAt": "2024-01-26T03:43:13Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "I_kwDOJaEkaM5s9MJ6",
      "title": "Client Attestation PoP JWT does not contain mandatory \"jti\" claim",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/37",
      "state": "CLOSED",
      "author": "tlodderstedt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tplooker"
      ],
      "labels": [],
      "body": "The spec states: \r\n\r\n\"The JWT MUST contain a \"jti\" (JWT ID) claim that provides a unique identifier for the token. The authorization server MAY ensure that JWTs are not replayed by maintaining the set of used \"jti\" values for the length of time for which the JWT would be considered valid based on the applicable \"exp\" instant.\"\r\n\r\nHowever the `jti` is not shown in the example in the same section. ",
      "createdAt": "2023-07-30T15:41:43Z",
      "updatedAt": "2023-09-07T21:03:32Z",
      "closedAt": "2023-09-07T21:03:32Z",
      "comments": []
    },
    {
      "number": 38,
      "id": "I_kwDOJaEkaM5s9MrT",
      "title": "endpoint URL in pop JWT?",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/38",
      "state": "CLOSED",
      "author": "tlodderstedt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tplooker"
      ],
      "labels": [
        "pending-close"
      ],
      "body": "Should the actual URL the client attestation pop JWT shall be sent to be included in the pop JWT?\r\n\r\nDPoP has it but I assume the nonce is powerful enough to protect against replay but want to make sure we have thought about it.",
      "createdAt": "2023-07-30T15:48:54Z",
      "updatedAt": "2023-10-23T20:31:40Z",
      "closedAt": "2023-10-23T20:31:40Z",
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "I didn't get the \"actual URL\" , do you mean the `htu` value?",
          "createdAt": "2023-07-30T18:06:57Z",
          "updatedAt": "2023-07-30T18:06:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "@tlodderstedt can you confirm what you mean, I read your issue as meaning we should be including the endpoint that the PoP is going to be presented at (e.g the token endpoint)?",
          "createdAt": "2023-09-06T06:17:02Z",
          "updatedAt": "2023-09-06T06:17:02Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yes, that's what I mean. The PoP should be restricted to the endpoint URL it is sent to. ",
          "createdAt": "2023-09-12T19:22:51Z",
          "updatedAt": "2023-09-12T19:22:51Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "The HTU claim in DPoP serves a couple of purposes which are freshness and audience constraint. With this draft the client attestation PoP already has normative text around populating the aud value for audience constraint and a mechanism around jti for a limited solution to detecting freshness (replay attacks). We also have #39 discussing a solution to a server generated nonce which will improve the freshness (replay attacks). With those mechanisms in place I dont believe we also need an HTU style claim.",
          "createdAt": "2023-09-13T22:22:06Z",
          "updatedAt": "2023-09-13T22:22:06Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "I_kwDOJaEkaM5wQR5G",
      "title": "Replay prevention",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/39",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "To prevent replay attacks the following mechanisms could be used:\r\n- AS/Issuer providing a nonce\r\n- reuse of existing of existing parameters as nonce\r\n- limiting the lifetime of PoP (through JTI)\r\n\r\n### AS/Issuer providing a nonce\r\nThis requires an additional endpoint/ an additional roundtrip\r\n\r\n### reuse of existing of existing parameters as nonce\r\nFor some flows it might be doable to reuse the auth code/pre-auth code as a nonce, this saves another roundtrip but might not work for all flows, like PAR endpoint\r\n\r\n### limiting the lifetime of PoP (through JTI)\r\nThis is the existing mechanism described in the spec, the JWT PoP includes a jti and the AS needs to keep track of used jti values until they are expired",
      "createdAt": "2023-09-06T06:17:55Z",
      "updatedAt": "2025-03-03T19:07:28Z",
      "closedAt": "2025-03-03T19:07:28Z",
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Option 2 is grant specific and not desired.\r\nOption 3 is in the text as a MAY\r\nOption 1 should be considered in DPoP-style and be added to the text",
          "createdAt": "2023-09-06T07:02:52Z",
          "updatedAt": "2023-09-06T07:02:52Z"
        },
        {
          "author": "PieterKas",
          "authorAssociation": "NONE",
          "body": "Support for a server generated nonce over which the attestation can be generated is something that is highly desirable to protect against pre-computation attacks. We have seen attacks where attackers deploy malware an pre-compute signatures (including manipulation of the system clock) and then exfiltrating these signatures for future use. This was one of the reasons why we strongly advocated for the inclusion of server supplied nonces in the DPoP standard. \r\n \r\nPerhaps we can use a similar mechanism as in DPoP to include an optional server supplied nonce when generating the attestation (see Section 8 and 9 in DPoP for inspiration on supplying nonces as part of the interaction with the authorization and resource servers). The inclusion of  the nonce as part of a 200 response helps save on roundtrips (bar the first need for a nonce).\r\n",
          "createdAt": "2023-09-07T10:42:47Z",
          "updatedAt": "2023-09-07T10:42:47Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "todo: describe how a nonce request error look like",
          "createdAt": "2023-10-23T20:32:12Z",
          "updatedAt": "2023-10-23T20:32:12Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDOJaEkaM5x3qkF",
      "title": "[client_assertion_pop] JWTs concatenated and separated by ~ vs self-explanatory parameter names",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/45",
      "state": "CLOSED",
      "author": "peppelinux",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the current solution under development in Italy, the debate on the use of this wonderful draft has been alive for months.\r\n\r\nFrom the experiences and positions collected there seems to be a general refusal to recognize as \"beautiful\" the concatenation of JWTs divided by the ~ character within the `client_assertion` parameter.\r\n\r\nFor those who don't know, the crime of ugliness does not yet exist in Italy but there is great sensitivity in the search for beauty even in implementations.\r\n\r\nThere are alternative ways to proof the PoP, like DPoP. Unfortunately convey large JWT in a HTTP header like DPoP may have impacts on the tuning of the httpd services that would require a specialized configuration to allow http headers larger than 4KB. This has relevant impacts in the cases where a JWT carries x5c or Federation trust chains within its headers, where a JWT could be more than 4KB.\r\n\r\nEven if there are other specs that uses concatenation of JWTs using `~` as separator char, like SD-JWT. However SD-JWT tends to be self-contained artifact, general purpose and agnostic from the way it is transported. Then I'd tend to leave out SD-JWT from this thread.\r\n\r\nConsidering that this draft aims to extend RFC7521, I'd suggest to not use the concatenation two JWTs using `~` but the definition of a new parameter, that we may call `client_assertion_pop` to convey the client attestation PoP. This proposal suggests a good semantic with self-explanatory parameter names, in a modular way that aims to extend RFC7521 with explicit parameters as additional modules, that may be used where PoP is required.\r\n\r\n",
      "createdAt": "2023-09-24T23:25:42Z",
      "updatedAt": "2023-10-09T12:34:18Z",
      "closedAt": "2023-10-09T12:34:17Z",
      "comments": [
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "[Giuseppe asked for my thoughts]  \r\nRFC7521 largely only envisioned a single assertion so building on it for the intended functionality of this draft isn't a perfect fit. The current approach of the `client_assertion` parameter value having the two tilde separated JWTs is fine, though, in my opinion. And I don't believe that defining  new parameter for the Client Attestation PoP JWT would be a material improvement.    \r\n\r\n",
          "createdAt": "2023-09-25T15:10:41Z",
          "updatedAt": "2023-09-25T18:28:32Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "Then you definitively suggest to detect the `client_assertion` value format by filter with the `client_assertion_type`",
          "createdAt": "2023-09-25T17:09:30Z",
          "updatedAt": "2023-09-25T17:09:30Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, the value of the `client_assertion_type` is intended to indicate the format (and other aspects) of the `client_assertion` value.",
          "createdAt": "2023-09-25T17:39:32Z",
          "updatedAt": "2023-09-25T17:39:32Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "Since an agreement was found about the adoption of the current specs as they are and without requesting any breaking change, this thread doesn't represent an issue anymore.\r\n[\r\nHere the related PR](https://github.com/italia/eudi-wallet-it-docs/pull/138) that uses this specs as it is in the it wallet",
          "createdAt": "2023-10-09T12:34:17Z",
          "updatedAt": "2023-10-09T12:34:17Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "I_kwDOJaEkaM5x3sO_",
      "title": "extend use beyond authorization servers",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/46",
      "state": "CLOSED",
      "author": "peppelinux",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "According to RFC7521 this draft aims to give specification about how to get authenticated with an AS, as we read in the introductory text\r\n\r\n> [[RFC7521](https://vcstuff.github.io/draft-ietf-oauth-attestation-based-client-auth/draft-ietf-oauth-attestation-based-client-auth.html#RFC7521)] defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification uses this framework to define a new assertion type that provides a way for a client instance to authenticate itself with the authorization server through an assertion that is bound to a public key (for proof of possession).\r\n\r\nIf the usefulness and purpose of this draft is clear, at the same time we perceive a great potential that could also be useful in other contexts.\r\n\r\nLately there has been a lot of talk about the use of the nonce as a definitive prevention against replay attacks, and the importance of the nonce endpoint for issuing these is often discussed.\r\n\r\nIn the background we have the emerging wallet ecosystem which proposes reversed roles at different times, where the wallet is a client in the issuance phase towards a credential issuer which is an AS, while it is a sort of AS in the presentation phase towards the Relying Party.\r\n\r\nThis draft could enable the authentication of a client (wallet) to a third party (either this AS or RP) before obtaining the nonce.\r\n\r\nthe possible nonce endpoint could present itself as a protected endpoint, the nonce should only be issued to authenticated parties.\r\n\r\nThis generalization would require greater flexibility compared to the current purposes of the draft, which envisages its use only when the audience is an AS, while it could also be an RP, where the wallet instance attestation with PoP can be provided before any kind of transaction takes place (allowing the RP to discover the wallet capabilities before issuing the signed request object).",
      "createdAt": "2023-09-24T23:50:46Z",
      "updatedAt": "2024-10-21T18:41:40Z",
      "closedAt": "2024-10-21T18:41:40Z",
      "comments": [
        {
          "author": "David-Chadwick",
          "authorAssociation": "NONE",
          "body": "From a trust perspective I think that issuing and presentation of credentials are different. The user/wallet typically trusts the issuer, otherwise why would it ask for a credential from it? OTOH, the user/wallet cannot trust any random RP that it connects to. Therefore the user/wallet should expect the issuer to authenticate itself first to the user/wallet, before authenticating itself to the issuer. OTOH the user should expect the verifier to identify itself first, so that it can determine if this verifier is trustworthy, before progressing any further with authentication or capability determination.",
          "createdAt": "2023-09-25T09:50:31Z",
          "updatedAt": "2023-09-25T09:50:31Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "I fully agree with you @David-Chadwick, in any cases the parties must establish trust before any protocol specific flow (issuance or presentation) may happen.\r\n\r\nthis issue aims to use an verifiable attestation based approach not just for client-AS (issuance) but also from AS-client (presentation), where the flow is conditioned by which entity has availability of endpoints (CI, RP) and which one not (wallet instances)",
          "createdAt": "2023-09-25T11:16:25Z",
          "updatedAt": "2023-09-25T11:16:25Z"
        },
        {
          "author": "fbaud",
          "authorAssociation": "NONE",
          "body": "@David-Chadwick @peppelinux, I agree that issuing and verifiying are entirely different from a trust perspective. But my angle would be to emphasize this from the issuer/verifier perspective:\r\n\r\n- as an issuer, I want to trust the wallet I'm issuing a credential to. At the minimum, I want to check that the wallet has received some form of authorization to receive a credential that was defined by a user agent (a widget in our case at Primus Money)\r\n- as a verifier, I may just want to identify who is presenting a credential so that I can reconcile it with my backend data server. Most of the time, identification could be self-contained within the presentation itself. The more empediment (excessive authentication requirement) for the wallet to provide a credential, the less useful it is for the verifier.\r\n\r\nI agree that from the wallet perspective, the angle is the symetric: more requirements on the verifier to identify itself, no excessive requirement on the issuer for most of the types of credentials.\r\n\r\nI must stress that in our architecture, we have the additional element that is the widget which is the first interface between the user and the issuer/verifier. We are in a context where the widget connects to a SaaS infrastructure and we have again different trust requirements between issuing and verifying:\r\n\r\n- for issuing, the widget needs to authentify to specify the type of credentials it authorizes the SaaS server to issue\r\n-  for verification, except the concerns about Denial Of Service, the requirement to authentify are much less stringent and we can imagine workflows where we let anyone who wants to submit a presentation to let them do that. ",
          "createdAt": "2023-09-25T11:52:05Z",
          "updatedAt": "2023-09-25T11:52:05Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "@fbaud I agree with you and I'd buy also this \r\n\r\n> Most of the time, identification could be self-contained within the presentation itself. The more empediment (excessive authentication requirement) for the wallet to provide a credential, the less useful it is for the verifier.\r\n\r\nAt the same time the RP should know the wallet capabilities to know which are the supported sign and enc alg (and enc), if the wallet solution supports the presentation_definition_uri and so on.\r\n\r\nIn italy we use the wallet instance also to carry these capabilities, [here an example](https://italia.github.io/eudi-wallet-it-docs/versione-corrente/en/wallet-instance-attestation.html#format-of-the-wallet-instance-attestation)\r\n\r\nthis feature consolidates how a wallet capabilities discovery is required for a good interoperability, let's consider that a signature alg may be discovered vulnerable or the continuous technology advancement and innovation that will introduce periodically new features and algs.\r\n\r\nI believe that having a wallet capabilities discovery process, seamless in both issuance and presentation, is a future proof approach\r\n",
          "createdAt": "2023-09-25T12:29:50Z",
          "updatedAt": "2023-09-25T12:29:50Z"
        },
        {
          "author": "fbaud",
          "authorAssociation": "NONE",
          "body": "@peppelinux I think that the discovery process between the wallet and the server can be done without authentication.\r\nIt is more part of a protocol negotiation than part of a transaction. Transaction may need authentication, but for the verifier the point was more: \"give me all you can give and I'll sort it out\". While for the issuing, after possibly negotiating what alg, trust_chain, credential format,.. will be used, the server may need to authenticate the wallet (or check that it has the right authorisations) before delivering the credential. But nevertheless, we should also imagine that a wallet can request a credential without having to authenticate (like for a server delivering a timestamped credential for a process requiring a dead-man switch).",
          "createdAt": "2023-09-25T13:35:57Z",
          "updatedAt": "2023-09-25T13:36:54Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "@fbaud How an RP discovers the wallet capabilities is something that should happen before the issuance of the signed request object. At the same time the RP must be sure that the WIA is in the legitimate possession of the Holder, with the authentication through the WIA+PoP\r\n\r\nthis approach would fit with the nonce_endpoint discussed here: https://github.com/openid/OpenID4VCI/issues/71#issuecomment-1733791449 where in addition we protect the issuance of the nonce with a wallet instance authz\r\n\r\n>  But nevertheless, we should also imagine that a wallet can request a credential without having to authenticate (like for a server delivering a timestamped credential for a process requiring a dead-man switch).\r\n\r\nyes, the autentication would be quite modular and for Type 1 and some Type 2 credentials, according to the required LoA\r\n",
          "createdAt": "2023-09-25T14:21:46Z",
          "updatedAt": "2023-09-25T14:22:57Z"
        },
        {
          "author": "David-Chadwick",
          "authorAssociation": "NONE",
          "body": "The verifier must trust the issuer, otherwise it cannot accept the issued credentials that are held by the user/wallet, regardless of the capabilities of the wallet. However, we know that the wallet must have the capability to accept the credential from the issuer.\r\nConsequently the verifier should obtain the meta data of the issuer, and this will provide the verifier with (possibly a superset of) the capabilities of the wallet. Thus I think it is a false requirement for the verifier to determine the capabilities of the wallet. Rather it should determine the capabilities of the issuer. If the verifier is capable of accepting all of these capabilities, then it knows that it can accept the credential from the wallet, regardless of what capability the wallet has. Now, I accept that a wallet may only support a subset of the capabilities of the issuer, but providing the verifier can support all the capabilities of the issuer this is not be a problem. The problem arises if we have both a verifier and a wallet that only support a subset of the capabilities of the issuer, and these are disjoint sets. But in this case there is little point in the verifier determining the capabilities of the wallet, as it cannot interwork with it. Thus the verifier should request the credential from the wallet using (a subset of) the capabilities of the issuer, and see if the wallet can provide it in this format. I don't believe the verifier needs to pre-determine the capabilities of the wallet.",
          "createdAt": "2023-09-25T21:13:25Z",
          "updatedAt": "2023-09-25T21:13:25Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "What if ... \r\n\r\n1. The wallet instance encrypts the presentation response with an enc alg that's not supported by the verifier?\r\n2. The wallet instance doesn't support presentation_definition_uri? (see `presentation_definition_uri_supported`)\r\n3. The wallet instance doesn't support a specific vp format? (see `vp_formats_supported`)\r\n4. The wallet instance has to provide the `authorization_endpoint` to the verifier? (... Can be custom URI scheme, or Universal Links/App links ...)\r\n\r\nthen, having these previous, why the wallet capabilities discovery would be a false requirement?",
          "createdAt": "2023-09-26T07:04:37Z",
          "updatedAt": "2023-09-26T07:04:37Z"
        },
        {
          "author": "David-Chadwick",
          "authorAssociation": "NONE",
          "body": "@peppelinux In answer to the above\r\n1. This is a (lack of) capability of the verifier. If it is constrained in this way it should inform the wallet in the request for the VP or via its metadata\r\n2. The wallet will return an error to the RP\r\n3. It is most likely that the wallet will support the same formats for VCs as for VPs. I think it highly unlikely that a wallet will support say a JWT VC and not a JWT VP. Thus the verifier can infer what vp format(s) will be supported by seeing what VC format(s) the issuer provides to the wallet.\r\n4. In our interworking tests the RP had to have a web page with the correct wallet endpoints so that the user could click on the correct one. In the case of a cloud wallet, the user had to enter this URL to the RP (since the RP cannot know the endpoints of all (or any) cloud wallets. If the RP knows nothing about the user's wallet how do you expect the two to communicate? In our opinion, the connection had to be initiated by the user, and the user knows the endpoint of its own wallet",
          "createdAt": "2023-09-26T07:54:26Z",
          "updatedAt": "2023-09-26T07:54:26Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "I got your point @David-Chadwick and I'd make your also mine, however I'm aware that having a proper discovery we would remove any fault, errors and failed transaction that may happen in the real world, in particular with an open ecosystem where different tecnologies and implementations profiles will end to be mixed. I see a future where an EIDAS Wallet solution may implements external features and then also did resolvers and additional capabilities. This would build an open ecosystem where interop and capabilities discovery represent a concrete and future proof requirement\r\n\r\nNot at least, preventing faults saves both users time and electricity :-)",
          "createdAt": "2023-09-26T08:56:46Z",
          "updatedAt": "2023-09-26T08:56:46Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @David-Chadwick here mostly. My observations are:\r\n- The Verifier will most certainly know which credentials he requires and the technical requirements are clear from the issuers, that the Verifier will accept\r\n- Wallet Capabilities and Wallet Attestations is not necessarily the same concept, indeed the Verifier metadata may be transmitted unsigned as well today in OpenID4VP\r\n- Wallet technical capabilities should be omitted or very constrained to not open up privacy issues\r\n- if the technical capabilities of the Wallet and Verifier do not match, this will ultimately result in an error, no matter if the Verifier detects the capabilities or not\r\n\r\nAs this discussion is happening in the Client attestation draft, I would like to limit this discussion mostly to the question whether we need client authentication for Wallet-Verifier interaction and what would be necessary for this draft to accomplish this",
          "createdAt": "2023-11-01T16:23:02Z",
          "updatedAt": "2023-11-01T16:23:02Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "I_kwDOJaEkaM5x3vhj",
      "title": "PoP attestation binding ",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/47",
      "state": "OPEN",
      "author": "peppelinux",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Even if remote, there is the possibility that an implementation re-uses the same cryptographic keys for different scopes.\r\n\r\nthe PoP JWT could be used with the same cryptograhic key attested in more than a single attestation and therefore be replicated for different endpoints/audience\r\n\r\nWhat do you think about getting the `ath` claim inside the DPoP token as requested?\r\n\r\nIn this way, a DPoP token cannot be replicated when the key that proves possession is the same within different attestations.\r\n\r\nEven if DPoP specs defines `ath` in relation to an access token, may we consider that any kind of JWT could represent an access token, in relation of its scope, the flow where it is used and its usage in general?\r\n\r\nThen, could we provide a binding of the PoP to a specific attestation where the possession aims to be proved?",
      "createdAt": "2023-09-25T00:16:42Z",
      "updatedAt": "2023-11-06T07:50:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "For better clarity\r\n\r\nan aud is not enough where a pop is used on a different attestation that has in common the same key used for the signature of another attestation\r\n\r\nit's an implementation risk where an implementer would use the same key for different attestations\r\n\r\nonce you have one, you can replay the same PoP for another/different attestation that has in common the same key\r\nhash of the attestation is then required, WDYT?",
          "createdAt": "2023-09-25T11:07:05Z",
          "updatedAt": "2023-09-25T11:07:05Z"
        },
        {
          "author": "Sh-Amir",
          "authorAssociation": "NONE",
          "body": "> Even if remote, there is the possibility that an implementation re-uses the same cryptographic keys for different scopes.\r\n> \r\n> the PoP JWT could be used with the same cryptograhic key attested in more than a single attestation and therefore be replicated for different endpoints/audience\r\n> \r\n> What do you think about getting the `ath` claim inside the DPoP token as requested?\r\n> \r\n> In this way, a DPoP token cannot be replicated when the key that proves possession is the same within different attestations.\r\n> \r\n> Even if DPoP specs defines `ath` in relation to an access token, may we consider that any kind of JWT could represent an access token, in relation of its scope, the flow where it is used and its usage in general?\r\n> \r\n> Then, could we provide a binding of the PoP to a specific attestation where the possession aims to be proved?\r\n\r\nI can see the benefits of binding the wallet instance attestations to the specific proof to avoid the possibility that it could be swapped in the case that the same cryptography keys are used by the implementers. I agree that the usage of a similar countermeasure like `ath` that is defined in the DPoP specification can work here as a mitigation. However, it would be better to introduce a new claim for this to be included in PoP as `ath` meant for the Access Token, and here as we deal with Wallet Instance Attestation maybe we can use the following claim `wiah`?",
          "createdAt": "2023-09-25T13:00:08Z",
          "updatedAt": "2023-09-25T13:00:08Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you propose a new claim in the Client Attestation PoP JWT thats value is the hash of the corresponding Client Attestation JWT?",
          "createdAt": "2023-11-01T16:48:21Z",
          "updatedAt": "2023-11-01T16:48:21Z"
        },
        {
          "author": "Sh-Amir",
          "authorAssociation": "NONE",
          "body": "> Do you propose a new claim in the Client Attestation PoP JWT thats value is the hash of the corresponding Client Attestation JWT?\r\n\r\nYes Paul. That is the idea. ",
          "createdAt": "2023-11-01T17:04:13Z",
          "updatedAt": "2023-11-01T17:04:13Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "We will explore this, but initially it does not seem like a bad idea",
          "createdAt": "2023-11-06T07:50:03Z",
          "updatedAt": "2023-11-06T07:50:03Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "I_kwDOJaEkaM50wRKQ",
      "title": "Authorization code binding to client instance",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/56",
      "state": "OPEN",
      "author": "cobward",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, section 5.2 \"Refresh token binding\"  gives requirements for how an authorization server must bind the client instance to the refresh token. Could we reuse this mechanism to bind the authorization code to the client instance in the case that client auth was performed in the authorization request?",
      "createdAt": "2023-10-24T08:59:21Z",
      "updatedAt": "2025-05-28T08:16:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "@cobward do you mean in the event we are using something like a signed PAR request?",
          "createdAt": "2023-10-31T19:23:36Z",
          "updatedAt": "2023-10-31T19:23:36Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "If I understand you correctly, you get a similar set of assurances like with PKCE, so I'm unsure if we want to duplicate this mechanism.",
          "createdAt": "2023-11-06T07:42:59Z",
          "updatedAt": "2023-11-06T07:42:59Z"
        },
        {
          "author": "cobward",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @cobward do you mean in the event we are using something like a signed PAR request?\r\n\r\nI'm not sure that it only applies to signed PAR request. I mean just generally that if client authentication is required at the authorization endpoint then the same requirements of binding the client instance to the authorization code still apply.\r\n\r\n> If I understand you correctly, you get a similar set of assurances like with PKCE, so I'm unsure if we want to duplicate this mechanism.\r\n\r\nIf that is the case then would it make sense to add text to that effect? Something along the lines of:\r\n\r\n_The Authorization Server is not required to bind the client instance to the authorization code, as PKCE provides sufficient mitigation of security risks._\r\n",
          "createdAt": "2023-11-06T13:49:21Z",
          "updatedAt": "2023-11-06T13:49:21Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "PKCE is actually a weaker mechanism, and DPoP has mechanisms that provide additional security that Pieter nicely explains here: https://bitbucket.org/openid/fapi/issues/503/dpop-par-and-authorization-code-binding#comment-63863178\n\nHowever the current draft also doesn't say anything about using PKCE. It probably should?\n\nI think it also needs to be explicitly called out in security considerations that the authorization code is NOT bound to the client instance. I think that's probably a significant change in the security model compared to normal client authentication, and PKCE and/or the above DPoP binding of the authorization code are both potential mitigations.\n",
          "createdAt": "2025-05-27T07:48:51Z",
          "updatedAt": "2025-05-27T07:49:10Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "> However the current draft also doesn't say anything about using PKCE. It probably should?\n\nRefs: https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/113\n\n> I think it also needs to be explicitly called out in security considerations that the authorization code is NOT bound to the client instance. I think that's probably a significant change in the security model compared to normal client authentication, and PKCE and/or the above DPoP binding of the authorization code are both potential mitigations.\n\nRefs: https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/114 there's more that could be bound to the client instance than just the auth code when using PAR.",
          "createdAt": "2025-05-28T08:16:48Z",
          "updatedAt": "2025-05-28T08:16:48Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "I_kwDOJaEkaM50wo51",
      "title": "Refresh token binding after attestation expiration",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/57",
      "state": "CLOSED",
      "author": "cobward",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently section 5.2 states:\r\n> The client MUST also use the same key that was present in the \"cnf\" claim of the client attestation that was used for client authentication when the refresh token was issued.\r\n\r\nIn the case that the original client attestation JWT has expired, what should happen? If it is acceptable for the client to re-use the same key in the \"cnf\" field across attestation JWTs, then the client can easily generate a new attestation JWT with the same \"cnf\" key. But if the client needs to use a fresh \"cnf\" key, then I can think of three options:\r\n\r\n1. Define a flow which endorses the new \"cnf\" key with the old \"cnf\" key.\r\n2. Define a field in the client attestation JWT that contains a unique identifier for the client instance, and use that identifier to bind the refresh token to the client instance.\r\n3. Explicitly don't permit this in the specification, add text to the specification that makes it clear that the \"cnf\" key must stay the same across refreshed client attestations.\r\n\r\nMy preference would be for option 2.",
      "createdAt": "2023-10-24T09:57:44Z",
      "updatedAt": "2024-02-13T17:42:07Z",
      "closedAt": "2024-02-13T17:42:07Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> In the case that the original client attestation JWT has expired, what should happen?\r\n\r\nCurrently the client instance needs to go back to the client backend and request a new client attestation JWT bound to the same key used in the old JWT.\r\n\r\nIn general because we are effectively using the client instance key to identify the instance at the authorization server this makes key rotation of the client instance key difficult with active refresh tokens. \r\n\r\n1 feels too complex, 3 is an option and @bc-pi and I have discussed 2 before. The flip side to consider with option 2 is the privacy implications of formally electing to track client instances, personally i'm not convinced its a bad idea but we should carefully consider the impact.",
          "createdAt": "2023-10-31T02:31:47Z",
          "updatedAt": "2023-10-31T02:31:47Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In general because we are effectively using the client instance key to identify the instance at the authorization server\r\n\r\nDo we? I had assumed the AS identifies the client by the `sub` value. I don't see a need to identify a client instance. ",
          "createdAt": "2023-10-31T10:59:24Z",
          "updatedAt": "2023-10-31T10:59:24Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the forth option is to have long living client attestations, which in my opinion is no problem\r\n\r\nthe client should then use different attestations with different ASs",
          "createdAt": "2023-10-31T11:01:21Z",
          "updatedAt": "2023-10-31T11:01:21Z"
        },
        {
          "author": "cobward",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The flip side to consider with option 2 is the privacy implications of formally electing to track client instances, personally i'm not convinced its a bad idea but we should carefully consider the impact.\r\n\r\nThis just makes explicit the tracking of client instances that already existed through the requirement for the \"cnf\" key to stay the same over attestations.\r\n\r\n> the forth option is to have long living client attestations, which in my opinion is no problem\r\n\r\nThis is really a decision for the use-case in my opinion. In the context of software integrity being established through the client attestation, it is trivial to inject malware after the generation of the attestation, so some in some cases it may be a requirement to have fresh attestations.",
          "createdAt": "2023-10-31T15:13:49Z",
          "updatedAt": "2023-10-31T15:13:49Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Isn't the AS identifying the client also by the refresh token itself?\n\nI dislike option 2 due to the privacy implications. As any optional fields in the client attestation JWT are valid, profiles could still use this option, but it should not be a good requirement in my opinion.\n\nI see two options: \nA: the wallet initially gets one client attestation and uses the cnf key over a longer period to bind a sequence of refresh tokens to it. -> similar to option 4?\n\nB: the Wallet initially gets one client attestation and the AS binds the first refresh token to the cnf key. When it uses the refresh token, it also provides a new client attestation with a new cnf key and the AS binds a new refresh token to this new key. -> similar to option 1?",
          "createdAt": "2023-10-31T18:33:58Z",
          "updatedAt": "2023-10-31T18:33:58Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> Do we? I had assumed the AS identifies the client by the sub value. I don't see a need to identify a client instance.\r\n\r\nWell the current language doesn't actually guarantee that the AS can track the client instance (which is a good thing IMO), as the instance can in many common cases, rotate the keys it uses in between fetching tokens. But in the event a client instance is exchanging a refresh token for a fresh access token and potentially another refresh token, the client instance must authenticate using a client attestation JWT with the same key in the cnf claim that was in the original attestation used when the refresh token was obtained. This ensures one client instance can't use another client instances refresh token. So in this case the AS can track that the client instance who obtained the refresh token is the client instance now requesting to exchange it for a new access token, which is desired from a security perspective.\r\n\r\n> This just makes explicit the tracking of client instances that already existed through the requirement for the \"cnf\" key to stay the same over attestations.\r\n\r\nAs I said above in response to Torsten's point, using the key instead of an explicit claim means a single client instance could actually use multiple keys over time meaning the AS can't track the client instance across all of those interactions. The concern if we make an explicit claim in the client attestation JWT for identifying the client instance, is that implementations won't rotate this identifier over time thus meaning the instance would be tracked.\r\n\r\n> the forth option is to have long living client attestations, which in my opinion is no problem\r\n\r\nIronically if your goal is to reduce the ability of the AS to track the client instance over time, this option will in fact enable that as the attestation itself becomes the tracking vector.\r\n\r\n> Isn't the AS identifying the client also by the refresh token itself?\r\n\r\nAgreed, the additional requirement of requiring the same client authentication method with the same key just means that obtaining the refresh token alone is not enough for another instance to be able to exercise the refresh token, it doesn't materially change the ability for the AS to track the client instance because as you highlight the refresh token itself creates the same possibility for correlation.",
          "createdAt": "2023-10-31T19:22:17Z",
          "updatedAt": "2023-10-31T19:22:17Z"
        },
        {
          "author": "cobward",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> A: the wallet initially gets one client attestation and uses the cnf key over a longer period to bind a sequence of refresh tokens to it. -> similar to option 4?\r\n\r\nI think this is basically my option 3.\r\n\r\n> Well the current language doesn't actually guarantee that the AS can track the client instance (which is a good thing IMO), as the instance can in many common cases, rotate the keys it uses in between fetching tokens.\r\n\r\n> a single client instance could actually use multiple keys over time meaning the AS can't track the client instance across all of those interactions\r\n\r\nUnless there is a mechanism to issue a refresh token that I am not aware of, it is not possible to rotate keys according to the current language. The spec states:\r\n\r\n> Authorization servers issuing a refresh token in response to a token request using the \"urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation\" client authentication method **MUST bind the refresh token to the client instance**, and NOT just the client as specified in section 6 {{RFC6749}}. To prove this binding, **the client instance MUST authenticate itself to the authorization server when refreshing an access token** using the \"urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation\" authentication method. The client **MUST also use the same key** that was present in the \"cnf\" claim of the client attestation that was used for client authentication when the refresh token was issued.\r\n\r\nThis is what I mean by \"_This just makes explicit the tracking of client instances that already existed through the requirement for the \"cnf\" key to stay the same over attestations._\"",
          "createdAt": "2023-11-06T14:52:08Z",
          "updatedAt": "2023-11-06T14:53:14Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think rotation of the key within the lifetime of a refresh token is something that needs to be accounted for. So my preference would be for option 3 (which is how it functionally is now but could be made more explicit in the text).  Adding an explicit claim in the client attestation JWT which identifies the client instance, i.e. option 2, would be okay too. But I think it'd get complicated/confusing to describe it in the spec. \r\n",
          "createdAt": "2023-11-09T21:34:11Z",
          "updatedAt": "2023-11-09T21:34:11Z"
        },
        {
          "author": "cobward",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't think rotation of the key within the lifetime of a refresh token is something that needs to be accounted for.\r\n\r\nBy saying you can't rotate the key within the lifetime of a refresh token, I think this means that you cannot rotate the key without starting from scratch at the authorization endpoint. I just wanted to make sure that is what you meant?",
          "createdAt": "2023-11-10T16:24:23Z",
          "updatedAt": "2023-11-10T16:24:23Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > I don't think rotation of the key within the lifetime of a refresh token is something that needs to be accounted for.\r\n> \r\n> By saying you can't rotate the key within the lifetime of a refresh token, I think this means that you cannot rotate the key without starting from scratch at the authorization endpoint. I just wanted to make sure that is what you meant?\r\n\r\nBasically yeah, I think so. Rotating the the key would mean you'd have to go back to the authorization endpoint. That seems acceptable/reasonable. Maybe it's too narrow of a view but it seems like if there's a reason to rotate that key then reauthorizing is probably needed or at least acceptable anyway. ",
          "createdAt": "2023-11-10T17:15:19Z",
          "updatedAt": "2023-11-10T17:15:19Z"
        },
        {
          "author": "cobward",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> if there's a reason to rotate that key then reauthorizing is probably needed\r\n\r\nI'm not sure that's true. IMO authorization is more of a user-identification concern, the rotation of the key is a client-security concern.\r\n\r\nSaying that, I think I agree that it's probably acceptable to say key-rotation isn't possible without returning to the authorization endpoint.\r\n\r\nGiven this I would suggest we add a sub-section to the Implementation Considerations section, something along the lines of this:\r\n\r\n> ## Rotation of confirmation key\r\n> This specification does not provide a mechanism to rotate the confirmation key identified in the Client Attestation JWT. If the client instance needs to use a new confirmation key for any reason, then it MUST begin the OAuth 2.0 flow from scratch.",
          "createdAt": "2023-11-13T10:45:01Z",
          "updatedAt": "2023-11-13T10:45:01Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "I_kwDOJaEkaM51372F",
      "title": "Extend the draft to define a new grant type",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/58",
      "state": "CLOSED",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Can this draft be extended to define a new grant type `urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation` where a sender-constrained JWT can be used to request an Access Token? for example, i think it would be useful in use-cases like catena-x https://github.com/eclipse-tractusx/identity-trust/issues/34 (cc @c2bo)\r\nInspiration for the suggestion is https://www.rfc-editor.org/rfc/rfc7523, which defined `urn:ietf:params:oauth:grant-type:jwt-bearer` both for client authentication and a new grant type.",
      "createdAt": "2023-11-05T02:21:14Z",
      "updatedAt": "2025-08-12T06:50:36Z",
      "closedAt": "2025-08-12T06:50:36Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "@Sakurann can you please elaborate on the usecase here, the attached issue doesn't provide any context.",
          "createdAt": "2023-11-06T07:59:48Z",
          "updatedAt": "2023-11-06T07:59:48Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Editors Call:\n- we didn't get any further feedback on this and no other people requested it\n- closing it for now\n- please re-open if this gets more tangible",
          "createdAt": "2025-08-12T06:50:36Z",
          "updatedAt": "2025-08-12T06:50:36Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOJaEkaM52OUZK",
      "title": "Using a server provided nonce to limit the lifetime of a Client Attestation PoP JWT",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/59",
      "state": "CLOSED",
      "author": "pmhsfelix",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Following up on the conversations some of us had after IIW (see https://github.com/openid/OpenID4VCI/issues/71#issuecomment-1719631991), this issue proposes the addition of a server provided nonce mechanism to limit the lifetime of a Client Attestation PoP JWT, similar to the [DPoP nonce mechanism](https://www.rfc-editor.org/rfc/rfc9449.html#name-authorization-server-provid).\r\n\r\nThis relates to https://github.com/openid/OpenID4VCI/issues/71, however the required changes need to be addressed on the attestation spec and not on the VCI spec.\r\n\r\nI'm currently working on a PR to add this. ",
      "createdAt": "2023-11-08T12:14:18Z",
      "updatedAt": "2025-03-03T19:07:28Z",
      "closedAt": "2025-03-03T19:07:28Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Please see #67 for a proposal to use DPoP which would provide an alternative solution to this proposal.",
          "createdAt": "2024-01-15T21:28:51Z",
          "updatedAt": "2024-01-15T21:28:51Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Thoughts from today's editor call:\r\n\r\n## Proposal 1: DPoP style\r\nAdvantages:\r\n- established mechanism\r\n- high flexiblity for AS to manages nonce lifetime\r\n\r\nDisadvantage:\r\n- higher chance of failure and repeated DPoP proof signatures, costly with remote or hardware key\r\n  - no nonce expiration communicated to client\r\n- is there a defined way for a client to request a valid nonce from AS? How can he be sure to end up in the use_dpop_nonce and not in other error conditions? -> clarify with @danielfett @bc-pi \r\n\r\n## Proposal 2: new/extended mechanism\r\nextend DPoP with:\r\n- define a HTTP Header to explicitly request a new nonce\r\n- add expiration to the nonce delivery (AS may still send a new nonce, even if the time has not passed yet)\r\n\r\nAdvantages:\r\n- ability to request fresh nonces when needed\r\n  - Wallet doesn't need to store old/fake DPoP Proofs to fetch a new one\r\n  - avoid double DPoP proof, costly with remote or hardware key\r\n- nonces could be delivered as header within other messages\r\n\r\nDisadvantage:\r\n- unauthenticated endpoint to request nonce that may generate state on the AS/may be leveraged for DDoS\r\n- unclear how to extend DPoP / more work\r\n\r\n----\r\nDo we want the Wallet to cache the nonces at all? Doesn't this open tracking by the issuer? This makes it even more obvious that we need explicit nonce requests!\r\n",
          "createdAt": "2024-08-22T09:01:10Z",
          "updatedAt": "2024-08-22T09:01:32Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@paulbastian How do you envision the client to determine whether a nonce is needed? I'm asking since if the client would know this in advance, it would allow a design where the client could obtain the nonce from a dedicated endpoint before calculating the PoP and sending the token request. ",
          "createdAt": "2024-08-22T09:52:29Z",
          "updatedAt": "2024-08-22T09:52:29Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "One idea was to add certain datapoints to the (previous) response - things like expiration time that could be a used as an indicator for the client that a nonce is not valid anymore (but not a guarantee that it will be accepted by the server).\r\nI guess we could also signal the general nonce policies for endpoints somewhere in the metadata?",
          "createdAt": "2024-08-22T11:12:36Z",
          "updatedAt": "2024-08-22T11:12:36Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My question is related to a client that just received an authorization code and now wants to authentication using a client attestation. How is the client supposed to figure our whether a nonce is needed?\r\n\r\nI see the following options: \r\n1. on demand, because the token request with a PoP w/o nonce is rejected\r\n2. some AS metadata tell the client a nonce is needed\r\n3. client and AS belong to a certain domain (e.g. the client is a wallet and the AS represents a credential issuer in the EUDI Wallet space) and nonces are always required in this domain. \r\n ",
          "createdAt": "2024-08-22T12:35:15Z",
          "updatedAt": "2024-08-22T12:35:15Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "I think there are 2 kinds of information we should consider:\r\n1: Something about the general policy of requiring a nonce (with the 3 options you mentioned)\r\n2: Some form of indicators if a client can re-use an existing nonce or should directly request a new nonce (and avoid an unnecessary signature)",
          "createdAt": "2024-08-22T13:48:51Z",
          "updatedAt": "2024-08-22T13:48:51Z"
        }
      ]
    },
    {
      "number": 60,
      "id": "I_kwDOJaEkaM52eD7T",
      "title": "IETF 118: Refer / Explain relation to RATS and the RATS terminology",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/60",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [
        "ready-for-pr"
      ],
      "body": "",
      "createdAt": "2023-11-10T13:05:09Z",
      "updatedAt": "2024-10-21T18:44:40Z",
      "closedAt": "2024-10-21T18:44:39Z",
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Attester = Client\r\nRelying Party = AS,RS\r\nVerifier = Client Backend (possibly Attestation Service)\r\nEndorser, Reference Value Provider = out of scope\r\n\r\nClaim = Claim\r\nEndorsement, Evidenace, Policies nad Reference Values = out of scope\r\nAttestation Result = Client Attestation JWT\r\n",
          "createdAt": "2024-05-20T09:55:47Z",
          "updatedAt": "2024-05-20T09:55:47Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOJaEkaM52eFe7",
      "title": "IETF 118 : Should this mechanism be used in parallel with Client Authentication /with Dynamic Client Registration",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/61",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In particiuar:\r\n- this mechanism should work for other endpoints\r\n- client attestation should not \"take up\" the client authentication slot, but be separate\r\n- How does the AS get the key of the client backend/attestation service? What's the trust mechanism?\r\n\r\nRelated to #62 ",
      "createdAt": "2023-11-10T13:09:37Z",
      "updatedAt": "2024-08-26T14:30:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The way this mechanism is designed allows it to be used with other endpoints then the token endpoint (like any other client authentication method). \r\n\r\nUsing client authentication as a way to also do client attestation is not just convenient it also means any client with attestation capabilities can be treated as a confidential client. \r\n\r\nI would like to understand how people proposing to split client authentication and attestation envision this to work. Would that mean deployments would use public clients + attestations? What would be the benefit?\r\n\r\nHow would dynamic client registration work with attestation? \r\n\r\nI personally have doubts about the utility of dynamic client registration. It requires the client to dynamically keep track of AS specific credentials including its expiration. Attestation based authentication on the other hand allows a client to just use a single attestation with any compatible AS. ",
          "createdAt": "2023-11-13T11:04:56Z",
          "updatedAt": "2023-11-13T11:04:56Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "\"Should this mechanism be used in parallel with Client Authentication /with Dynamic Client Registration\" feels like two different questions that we may want to discuss separately (albeit if the answer to both is \"yes\" the solution may be the same for both cases).\r\n\r\n\r\n@tlodderstedt \r\n\r\n> I personally have doubts about the utility of dynamic client registration. It requires the client to dynamically keep track of AS specific credentials including its expiration. \r\n\r\nDCR requires neither of those things when used with private_key_jwt or MTLS client authentication. (I'd agree that it does probably require the client to keep track of a client_id per AS.)\r\n\r\nDCR with attestations is fairly commonly used by mobile apps, to establish per-install client credentials. It's certainly not the only solution, but many people find it a useful solution today. The advantage of using attestation at DCR is you only do the attestation process once at registration time, which in the lower risks  cases makes things easier to implement on the AS side and simpler for client developers. (For clarify I also agree that there are use cases where presenting attestations every time a client authenticates could make sense.)\r\n",
          "createdAt": "2023-11-15T08:52:53Z",
          "updatedAt": "2023-11-15T08:52:53Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "> Using client authentication as a way to also do client attestation is not just convenient it also means any client with attestation capabilities can be treated as a confidential client.\r\n\r\nI am not convinced this is completely true; it's actually creating something that sits somewhere between a confidential client and a public client. See for example the special handling needing for refresh tokens as per https://vcstuff.github.io/draft-ietf-oauth-attestation-based-client-auth/draft-ietf-oauth-attestation-based-client-auth.html#section-5.2 but I think it has further implications for AS implementations, for example existing authorised consents would need to be tracked on a per \"client instance\" basis instead of a per client basis.",
          "createdAt": "2023-11-15T09:03:20Z",
          "updatedAt": "2023-11-15T09:03:20Z"
        },
        {
          "author": "ju-cu",
          "authorAssociation": "NONE",
          "body": "> I would like to understand how people proposing to split client authentication and attestation envision this to work. Would that mean deployments would use public clients + attestations? What would be the benefit?\r\n\r\nAttestation is just a statement by some entity (\"Attester\") about certain properties of a client (including its public key, in this case). I don't think attestation implies neither a public nor confidential client. Attestation could be used with both types I believe, because it serves a different purpose than authentication. I see attestation as a method to for the authorization server to get greater confidence in the credentials of a client. I picture, like @jogu, a setup where you can use client attestation (e.g. in an HTTP header or additional query parameter?!) together with existing (or future) client authentication methods such as private_key_jwt or mutual TLS.\r\n+1 for separating client attestation and client authentication via PoP mechanisms\r\n+1 for supporting client attestation with DCR.",
          "createdAt": "2023-11-15T09:56:23Z",
          "updatedAt": "2023-11-15T09:56:23Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Let me lay out how I understand the ideas of combining DCR with Client Attestation:\r\n- before a  Wallet/Client interacts with an Issuer/AS, he once sends a request to DCR Endpoint containing:\r\n  - client attestation as authorization\r\n  - some additional data according to RFC 7591\r\n  - some mechanism for client authentication, e.g. client credentials or private_key_jwt\r\n- Issuer/AS checks the client attestation and registers the Wallet/Client in his Client database under a newly generated client_id,e.g. (client_id, private_key_jwt) and sends response to DCR request\r\n- Wallet/Client Token Request containing:\r\n  - client authentication, e.g. private_key_jwt\r\n  - DPoP key\r\n- Issuer/AS responds with Token Response containing the DPoP-bound access token\r\n\r\nMy observations to this:\r\n- the biggest difference to the status quo of this specification is that in DCR the AS chooses the client_id, while in our model the Wallet Provider has a client_id that is the same for all client instances and chosen by the Wallet Provider\r\n- as I understand DCR is usually only called once during registration, in the use cases we have in mind it is very typical to send fresh client attestations to the Issuer/AS\r\n- as of now, we cannot use client attestations with DCR, because the cleint attestation already contains client_id as the `sub` value\r\n- in my opinion it seems a little strange and inefficient that every AS manages client_ids for every wallet instance and all wallets manage separate client_ids for every Issuer\r\n- We want to have attested public keys in the client attestation that an Issuer may use to bind VCs or other credentials to, that doesn't work very well with DCR\r\n\r\nThe initial motivation of this draft is to provide identification and authentication of the client instance towards the AS. I'm new to DCR so I might miss a few things here, right now it seems like an extra steps with no benefit to our usecases.\r\n",
          "createdAt": "2023-11-15T13:30:12Z",
          "updatedAt": "2023-11-15T13:30:12Z"
        },
        {
          "author": "vdzhuvinov",
          "authorAssociation": "NONE",
          "body": "Maybe I don't know the entire story behind this ticket, but switching to a DCR seems kind of heavy and inefficient to me, as seen from an AS, but also generally, when I try to think how this is going to mesh in a greater system / deployment / federation.\r\n\r\nI liked the original concept that relied on the attestation. It is efficient and easier to scale.",
          "createdAt": "2023-11-15T13:47:54Z",
          "updatedAt": "2023-11-15T13:47:54Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > Using client authentication as a way to also do client attestation is not just convenient it also means any client with attestation capabilities can be treated as a confidential client.\r\n> \r\n> I am not convinced this is completely true; it's actually creating something that sits somewhere between a confidential client and a public client. See for example the special handling needing for refresh tokens as per https://vcstuff.github.io/draft-ietf-oauth-attestation-based-client-auth/draft-ietf-oauth-attestation-based-client-auth.html#section-5.2 but I think it has further implications for AS implementations, for example existing authorised consents would need to be tracked on a per \"client instance\" basis instead of a per client basis.\r\n\r\nIs this handling any different from private_key_jwt?",
          "createdAt": "2023-11-15T15:05:52Z",
          "updatedAt": "2023-11-15T15:05:52Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> \"Should this mechanism be used in parallel with Client Authentication /with Dynamic Client Registration\" feels like two different questions that we may want to discuss separately (albeit if the answer to both is \"yes\" the solution may be the same for both cases).\r\n> \r\n> @tlodderstedt\r\n> \r\n> > I personally have doubts about the utility of dynamic client registration. It requires the client to dynamically keep track of AS specific credentials including its expiration.\r\n> \r\n> DCR requires neither of those things when used with private_key_jwt or MTLS client authentication. (I'd agree that it does probably require the client to keep track of a client_id per AS.)\r\n> \r\n> DCR with attestations is fairly commonly used by mobile apps, to establish per-install client credentials. It's certainly not the only solution, but many people find it a useful solution today. The advantage of using attestation at DCR is you only do the attestation process once at registration time, which in the lower risks cases makes things easier to implement on the AS side and simpler for client developers. (For clarify I also agree that there are use cases where presenting attestations every time a client authenticates could make sense.)\r\n\r\nCan you please describe how that works? As far as I understand RFC 7591, the AS creates a client id with every registration. There is no special treatment of neither private_key_jwt nor mTLS. \r\n\r\nI also noticed there is no proof of possession for the key material and there is no key binding for the software statement. That's all built into the client attestation mechanism. ",
          "createdAt": "2023-11-15T15:10:59Z",
          "updatedAt": "2023-11-15T15:10:59Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "> Is this handling any different from private_key_jwt?\r\n\r\nYes. The entire concept that one client_id can now have multiple instances and that the AS needs to treat the different instances of that client_id as distinct entities is a brand new concept created in this draft.",
          "createdAt": "2023-11-15T15:13:41Z",
          "updatedAt": "2023-11-15T15:13:41Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You are right. Since different client instances may use different attestations, the refresh token is no longer just bound to the client id. \r\n\r\nI think a client id previously already could have multiple instances (think of open banking apps), however the AS did not need to know. Why? Because authentication was done through the respective backend so instance management was application internal. Now, the instances themselves can authenticate, which raises privacy as the backend cannot observer this interaction. The way I see it this draft allows implementation of confidential clients with native apps in a more privacy friendly manner. The attestation part helps the AS to determine whether the instance is really an instance of the respective client id. I guess that's why I believe both concepts belong together. ",
          "createdAt": "2023-11-16T11:19:05Z",
          "updatedAt": "2023-11-16T11:19:05Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "> I think a client id previously already could have multiple instances (think of open banking apps), however the AS did not need to know\r\n\r\nI'm not sure that's really counts multiple instances. Or at least it's not just that authentication was in the backend, it's also that the refresh tokens never left the backend so there was no risk of one instance using a difference instances refresh token.\r\n\r\nI agree with the privacy benefits, but it is a significant change to the security posture. It is clear that the new thing defined in this draft is neither a traditional confidential client nor a traditional public client. I'm struggling to figure out which it is closest too. I think in a lot of ways it feels closest to a public client that's using dpop (particularly when you think of how refresh tokens are bound to the dpop key in that case), but essentially with the addition of attestation for the dpop key.\r\n",
          "createdAt": "2023-11-16T11:54:24Z",
          "updatedAt": "2023-11-16T11:54:24Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> feels closest to a public client that's using dpop (particularly when you think of how refresh tokens are bound to the dpop key in that case), but essentially with the addition of attestation for the dpop key.\r\n\r\nI'd concur with that. And there's some discussion over [here and above](https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/64#issuecomment-1815362871) about maybe using the DPoP proof as the PoP mechanism rather than the Client Attestation PoP JWT. Doing that change in conjunction with changing the Client Attestation JWT to be sent via some other parameter (`client_key_attestation` or something) and decoupled from client authentication is appealing. It'd keep public clients public. But give binding of RT to the DPoP key (the key that's been attested to) without the [special handling that's there now](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-attestation-based-client-auth#name-refresh-token-binding) but is a really important security property. And could provide this simple attestation (mostly about a key) independent of client authentication. And also stay orthogonal to DCR. \r\n",
          "createdAt": "2023-11-16T22:16:42Z",
          "updatedAt": "2023-11-16T22:16:42Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> Yes. The entire concept that one client_id can now have multiple instances and that the AS needs to treat the different instances of that client_id as distinct entities is a brand new concept created in this draft.\r\n\r\nIt might not be a broadly enough socialised concept yet but I dont think this draft has invented the notion of a client instance. [OAuth 2.1](https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-09.html), [RFC8705](https://www.rfc-editor.org/rfc/rfc8705.html) and [the latest OAuth browser BCP](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps-05) all speak informally about client instances.\r\n\r\nI also dont think the draft is aiming for an AS to treat different instances of a particular client differently beyond that if they fail to authenticate in a way that is required for that client, then of course their request could be rejected. The exception is perhaps the RT language that @bc-pi raised which I agree is very important to prevent one client instance from being able to use another client instances RT.\r\n\r\n> Doing that change in conjunction with changing the Client Attestation JWT to be sent via some other parameter (client_key_attestation or something) and decoupled from client authentication is appealing. It'd keep public clients public. But give binding of RT to the DPoP key (the key that's been attested to) without the [special handling that's there now](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-attestation-based-client-auth#name-refresh-token-binding) but is a really important security property.\r\n\r\nI like this solution personally, it is much cleaner to explain and feels like it gets the best of both worlds including re-using DPoP more meaning this specification has to invent less.",
          "createdAt": "2023-11-17T03:03:54Z",
          "updatedAt": "2023-11-17T03:06:10Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "> It might not be a broadly enough socialised concept yet but I dont think this draft has invented the notion of a client instance. [OAuth 2.1](https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-09.html), [RFC8705](https://www.rfc-editor.org/rfc/rfc8705.html) and [the latest OAuth browser BCP](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps-05) all speak informally about client instances.\r\n\r\nThis is true, albeit they only speak about instances of public clients. (My original sentence wasn't great; it was the \"that the AS needs to treat the different instances of that same confidential client_id as distinct entities is a brand new concept\" part that I really wanted to emphasise. And we agree that it's this refresh token related behaviour that's the important and necessary difference.)\r\n\r\nI strongly agree this latest direction as per your / Brian's comments.",
          "createdAt": "2023-11-17T09:53:14Z",
          "updatedAt": "2023-11-17T09:53:14Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "client instances: the draft allows to authenticate the caller as being an instance of a certain client (id). The client id should then be used by the AS for other logic (such as storing user consent and so on). There is no need to identify the client instance, I would go as far as to state the instance should not be identifiable simply because a client instance identifier would be kind of a user identifier (in case of a native app). I know the key is a co-relation handle, that's why deployments should use short lived or even emphemeral client attestation to foster privacy.\r\n\r\nattestation vs authentication: In traditional OAuth deployments requiring client authentication (e.g. open banking or commercial/paid schemes), a native app would send requests through its backend, which acts as a confidential client towards the AS. That's the way to ensure the AS talks to a legit client. In emerging use cases (esp. wallets), the way through the backend is seen as not as privacy preserving as it should be. Using the apps backend instead to issue an assertion to its app(s) and use that assertion to authenticate to the AS is the alternative being proposed. The backend uses platform attestation to ensure the caller is a instance of the backend's app. That's the origin of the name attestation based client authentication. Binding the attestation to a key ensures it cannot be replayed by other parties. With such an attestation, the app can directly call the AS (while establishing confidence the AS talks to the legit client).\r\n\r\nConclusion: the attestation is used to establish confidence the AS is talking to an instance of a certain client. This is inline with the purpose of client authentication. That's why the idea to use the existing client authentication mechanics here makes sense to me. \r\n\r\nre public client: I would like to understand how the suggested differentiation between attestation and public client shall work. Can someone please share an example flow with request examples? I would especially like to know what client_id such a public client would use. I'm asking since in the proposed flow, the client_id is determined by the trusted 3rd party issuing the client attestation assertion. ",
          "createdAt": "2023-11-22T11:17:42Z",
          "updatedAt": "2023-11-22T11:20:09Z"
        },
        {
          "author": "embesozzi",
          "authorAssociation": "NONE",
          "body": "Just a minor comment: I'm trying to use this standard in the context of the proposed [OAuth 2.0 for First-Party Applications](https://datatracker.ietf.org/doc/draft-parecki-oauth-first-party-apps/) standard to prevent client impersonation (I'm on the implementation side). To provide more context, OAuth 2.0 for First-Party Applications is an API-based \"authentication\" approach, serving as an alternative to the traditional method, which required redirecting or opening a browser. \r\nIn the context of mobile apps that use public clients, the Authorization Server MUST verify the \"first-partyness\" of the client. Therefore, I'm implementing client attestation at the token endpoint.\r\n\r\nAfter reviewing the standard, it's not clear to me how the AS can trust the attestation issuer and verify the signature of a client attestation.",
          "createdAt": "2024-08-20T19:55:10Z",
          "updatedAt": "2024-08-20T19:55:10Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "@embesozzi you're not missing anything, that currently isn't stated as far as I know. Like base OAuth as defined in RFC6749 doesn't say much about how you get a client_secret or client_id, it's assumed there's some kind of out of band configuration of what attestation issuers an authorization server trusts and where it gets the keys for those issuers from.\r\n\r\n(See also https://github.com/openid/oid4vc-haip-sd-jwt-vc/issues/101 which has more discussion.)",
          "createdAt": "2024-08-25T17:31:33Z",
          "updatedAt": "2024-08-25T17:33:07Z"
        },
        {
          "author": "embesozzi",
          "authorAssociation": "NONE",
          "body": "@jogu, I appreciate the feedback and I'll review the discussion.\r\nI've found others proposed standards to address this issue, but as usual, I'll try follow the [KISS principle](https://simple.wikipedia.org/wiki/KISS_principle).",
          "createdAt": "2024-08-26T14:30:12Z",
          "updatedAt": "2024-08-26T14:30:12Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "I_kwDOJaEkaM52f0LU",
      "title": "IETF 118: Overlap/Synergies with \"Attestation in Dynamic Client Registration Draft\"",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/62",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "What are similarities with the new draft of \"Attestation in Dynamic Client Registration Draft\"?\r\nEvaluate the possiblities to merge this.",
      "createdAt": "2023-11-10T17:27:28Z",
      "updatedAt": "2023-11-17T02:39:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My intuition is that there are actually very few synergies when you get into the specifics and details (which are what is needed for interop) and merging the drafts will be counter productive at best. ",
          "createdAt": "2023-11-16T22:01:02Z",
          "updatedAt": "2023-11-16T22:01:02Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I share this view ^ efforts to use attestations in DCR are quite different to proposing a client authentication mechanism that uses attestations and I'd prefer we keep them distinct.",
          "createdAt": "2023-11-17T02:39:33Z",
          "updatedAt": "2023-11-17T02:39:33Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "I_kwDOJaEkaM53y6Te",
      "title": "Include guidance to use attest_jwt_client_auth",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/66",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-24T14:41:45Z",
      "updatedAt": "2025-08-12T06:45:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "We should add a section that explains how to us \"attest_jwt_client_auth\" to signal support for this mechanism in metadata",
          "createdAt": "2025-08-12T06:44:54Z",
          "updatedAt": "2025-08-12T06:44:54Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "I_kwDOJaEkaM58fVe3",
      "title": "Introducing a general purpose assertion-based client authentication with holder-of-key JWT",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/68",
      "state": "OPEN",
      "author": "ju-cu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "pending-close"
      ],
      "body": "What about introducing a general purpose client authentication using a holder-of-key JWT assertion instead of Client Attestation JWT?\r\n\r\nThe draft introduces the Client Attestation JWT that is bound to the public key of a Client Instance Key. What about having a spec that replaces the Client Attestation JWT with an assertion that is a holder-of-key JWT, meaning a JWT bound to a key that the client proofs to be able to control (e.g. using DPoP as suggested in #67 ). The draft would not make any assumptions on whether the holder-of-key JWT is an attestation or not; it technically would support any JWT with a `cnf` claim and require a proof-of-possession for client authentication.\r\nAttestation-based client authentication could profile such a spec if necessary. In the ecosystem, there would be RFC7521, upon it RFC7523 for the bearer JWT assertion and next to it some spec for holder-of-key JWT assertion, and upon that the attestation-based client authentication. What do you think? \r\n\r\nThis idea was first proposed by @pmhsfelix in #64 (https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/64#issuecomment-1838969799). ",
      "createdAt": "2024-01-18T15:58:38Z",
      "updatedAt": "2025-08-12T06:46:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @ju-cu thanks for surfacing this into a seperate issue. I'm wondering how much of this is a terminology issue as the Client attestation JWT is really just a JWT with minimal normative requirements to ensure it is appropriate as an attestation or in your terminology a holder-of-key JWT. Can you explain what other usecases you would like to use this holder-of-key JWT outside of this specs usage? As it would appear that is the key to understanding whether this additional layer of abstraction would be useful.",
          "createdAt": "2024-01-18T20:34:28Z",
          "updatedAt": "2024-01-18T20:35:09Z"
        },
        {
          "author": "ju-cu",
          "authorAssociation": "NONE",
          "body": "I agree, it is mainly a terminology issue and I'm not sure there is a need for an additional layer or updating the current one is actually good enough. As you say, the draft includes only minimal normative requirements for the Client Attestation JWT. But this fact made me wonder how the proposed authentication method is actually related to attestation and what it distinguishes it from an authentication method for any holder-of-key JWT. So, I started to think that there could be likewise an authentication method that uses a holder-of-key JWT and any attestation specifics (if there are any) would be on top of that.",
          "createdAt": "2024-01-19T08:05:54Z",
          "updatedAt": "2024-01-19T08:05:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Understood, perhaps the question more lies with what usecases do you see outside of client authentication where this mechanism would be useful? Keeping in mind this draft is inherently bound to applications of the OAuth 2.0 protocol.",
          "createdAt": "2024-01-22T00:11:49Z",
          "updatedAt": "2024-01-22T00:11:49Z"
        },
        {
          "author": "pmhsfelix",
          "authorAssociation": "NONE",
          "body": "Currently, we have:\r\n- [RFC 7521 - Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants](https://www.rfc-editor.org/rfc/rfc7521.html) as a very general and format independent framework for both client authentication and authorization grants.\r\n    - This framework defines \"two general types of assertions\": \"Bearer Assertions\" and \"Holder-of-Key Assertions\" (https://www.rfc-editor.org/rfc/rfc7521.html#section-3).\r\n\r\n- [RFC 7523 - JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants](https://www.rfc-editor.org/rfc/rfc7523.html) profiles RFC 7521 for JWT *bearer* tokens.\r\n- AFAIK, there isn't any spec profiling RFC 7521 for JWT *holder-of-key* assertions.\r\n  \r\nMy idea, which I believe is similar to @ju-cu, would be to create such a *holder-of-key* profile spec, using DPoP-based proof-of-possession. This spec would be useful in both client authentication and authorization grant scenarios that require additional security (i.e. bearer is not adequate).\r\n*Attestation*-based client authentication would be based in this last profile spec, by defining a set of attestation-related claims to be contained in the JWT\r\n\r\nThis seems more modular and useful.\r\n\r\n```\r\nRFC 7521 - The framework\r\n|\r\n+---> RFC 7523 - profiles the framework for Bearer JWT\r\n|\r\n+---> NewSpec1 - profiles the framework for holder-of-key JWT, based on DPoP, independent of attestation\r\n          |\r\n          +---> NewSpec2 - Tiny spec profiling NewSpec1 for *attestation*-based client authentication, \r\n                    just by defining extra JWT claims.\r\n```\r\nThe main advantage would be the broader applicability of NewSpec1 as a version of RFC 7523 with holder-of-key\r\n       ",
          "createdAt": "2024-02-01T13:36:44Z",
          "updatedAt": "2024-02-01T13:36:44Z"
        },
        {
          "author": "ju-cu",
          "authorAssociation": "NONE",
          "body": "I do not have any (additional) use cases for a general purpose client authentication using a holder-of-key JWT, other than the general one that @pmhsfelix described: a JWT-assertion-based authentication for scenarios where bearer is not enough. \r\n\r\nThis draft does not specify any attestation specific claims for the client attestation JWT (it does not even define attestation and how it differs from an assertion). The only thing, that defines the client attestation JWT is the fact that it is bound to a public key and that the draft expects a client backend to generate it, which imo is not enough for an attestation. For example, the client attestation JWT does not provide any information about how the client protects the key as pointed out in this comment: https://github.com/openid/OpenID4VCI/issues/150#issuecomment-1918865432\r\n\r\nIn best cases, this draft provides some confidence that the request comes from a genuine client (or what the \"client backend\" thinks is genuine). I believe that you do not need a client backend to get this confidence. Technically, I don't think, it makes a difference if the client attestation JWT was issued by a client backend or any other third party because it all boils down to how the client authenticates to the client backend (step 2) which is out of scope of the draft anyways. \r\nI believe, to make this draft applicable, you will need a profile that defines the  attestation-specific claims in the client attestation JWT as well as the client authentication to who-ever-issues-the-key-bound-jwt. Imo, the current draft is more suited as a general-purpose holder-of-key-based client authentication method.\r\n\r\nMaybe you can help me to understand the difference between an attestation and a key-bound JWT?",
          "createdAt": "2024-02-05T08:24:09Z",
          "updatedAt": "2024-02-05T08:24:09Z"
        },
        {
          "author": "davux",
          "authorAssociation": "NONE",
          "body": "It does seem way cleaner to build this spec on top of RFC 7521 (and to explain the differences with RFC 7523), rather than recreating a new concept from scratch.\n\nAs a corollary, an assertion type around the lines of `urn:ietf:params:oauth:client-assertion-type:jwt-dpop` would be consistent with common practice.",
          "createdAt": "2025-06-17T17:37:21Z",
          "updatedAt": "2025-06-17T17:37:21Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "> It does seem way cleaner to build this spec on top of RFC 7521 (and to explain the differences with RFC 7523), rather than recreating a new concept from scratch.\n> \n> As a corollary, an assertion type around the lines of `urn:ietf:params:oauth:client-assertion-type:jwt-dpop` would be consistent with common practice.\n\nWe started there, but it felt weird, when we moved to HTTP headers, because the RFC7521 used the body. @bc-pi recommended that RFC7521 is not required and we followed this advice",
          "createdAt": "2025-06-17T19:09:21Z",
          "updatedAt": "2025-06-17T19:09:21Z"
        },
        {
          "author": "davux",
          "authorAssociation": "NONE",
          "body": "Thanks @paulbastian for the context -- I'm not a spec veteran, but moving attributes from body to header does indeed sound incompatible enough to justify breaking the link from a spec.\n\nReversely, I wonder what justified introducing that incompatibility in the first place. Relevant design and back-compatibility is sometimes a delicate balance -- you probably gathered advice at the time from people experienced in writing IETF specs. If you could share links to that discussion, it would make for very informative context in this issue.",
          "createdAt": "2025-06-17T19:44:54Z",
          "updatedAt": "2025-06-17T19:44:54Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Editors Call:\n- mark this as pending close\n- we have SD-JWT now almost finished, which is a generic holder-of-key JWT mechanism\n- we added HTTP headers in the meantime, which makes the (anyway optional) RFC 7521 less charming",
          "createdAt": "2025-08-12T06:45:40Z",
          "updatedAt": "2025-08-12T06:45:47Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDOJaEkaM59PQkf",
      "title": "Usecase: authenticating the key used for DPoP bound access tokens back to the client",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/69",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "c2bo",
        "tplooker"
      ],
      "labels": [],
      "body": "In the event this client authentication method is used with DPoP bound access tokens. An AS may want the assurance that the key they bind an issued access token, is in fact authenticated to the client. Without this assurance a MITM attack is possible where an intermediary could substitute the DPoP proof in the token request for a key they control, thus then being able to use the returned access token.\r\n\r\nBelow is a simple diagram depicting this attack\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant C as Client\r\n    participant A as Attacker\r\n    participant AS as Authorisation Server\r\n    participant RS as Resource Server\r\n\r\n    C->>C: Prepare Token Request (including DPoP proof)\r\n    C->>A: Send token request (intercepted by attacker)\r\n    A->>A: Generate new DPoP key and DPoP proof\r\n    A->>A: Generate new token request using the clients original request but with the new DPoP proof substituted\r\n    A->>AS: Send token request\r\n    AS->>AS: Validate and generate access token bound to attackers DPoP key\r\n    AS->>A: Send token response (with access token bound to attackers DPoP key)\r\n    A->>RS: Protected resource request using obtained access token\r\n```\r\n\r\nDPoP as stated in the RFC [is not designed as a client authentication method, but is instead designed to work with client authentication](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop-16#section-3). The client authentication method as defined by this draft could be such a suitable method that would provide a way to prevent the above attack from occurring.\r\n\r\nRelated to this issue, is PR #67, which explores using the DPoP proof syntax instead of defining a new JWT PoP syntax as is the case with the current draft. Consequently if #67 were adopted, the usage of this client authentication method with DPoP bound access tokens becomes much simpler and the above attack scenario would be prevented implicitly through the design. However, there is concern that #67 risks coupling together the DPoP key and client attestation key where there maybe usecases where these keys should be seperate (cc @tlodderstedt). Personally I'm not convinced that the DPoP key and client attestation key need to be different and I believe the complexity it creates is not worth it. However, if #67 is not adopted, then a different solution to solving the above problem needs to be devised which may require putting the DPoP key in the client attestation PoP so it can be authenticated back to the client. \r\n",
      "createdAt": "2024-01-25T20:54:18Z",
      "updatedAt": "2025-09-02T06:57:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "Discussed at IETF 123: No objections to introducing this if it stays optional and a warning to be careful in regards to nonce requirements if used in combination with dpop",
          "createdAt": "2025-08-12T06:41:52Z",
          "updatedAt": "2025-08-12T06:41:52Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Editors Call:\n- we need the AS to signal support for this, with AS metadata entry\n- either use DPoP nonce or Attestation challenge\n  - challenge may be a better fit, as we have proper endpoint and metadata for it\n  - dpop nonce may be a better fit if it allows existing implementations to reuse it",
          "createdAt": "2025-09-02T06:57:06Z",
          "updatedAt": "2025-09-02T06:57:06Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDOJaEkaM6DW1c7",
      "title": "Register AS and client metadata for algorithm negotiation of attestations and pops",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/70",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "We need to consider registering appropriate metadata for an AS and client to respectively indicate what signing algorithms they support for \r\n\r\n- A client attestation\r\n- A client attestation pop",
      "createdAt": "2024-03-23T09:56:57Z",
      "updatedAt": "2025-09-03T13:21:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "For AS metadata we will register the following\n- `client_attestation_algs_supported`\n- `client_attestation_pop_algs_supported`",
          "createdAt": "2025-09-02T06:48:53Z",
          "updatedAt": "2025-09-02T06:48:53Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "@tplooker the usual pattern is `_alg_values_supported`, so that's what I would use in the PR",
          "createdAt": "2025-09-03T13:16:31Z",
          "updatedAt": "2025-09-03T13:16:31Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "@paulbastian `_signing_alg_values_supported` for JWS alg metadata",
          "createdAt": "2025-09-03T13:21:38Z",
          "updatedAt": "2025-09-03T13:21:38Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "I_kwDOJaEkaM6Dq8a3",
      "title": "Propose to change the draft name",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/71",
      "state": "CLOSED",
      "author": "tlodderstedt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "pending-close"
      ],
      "body": "I think the \"attestation\" term in the draft name causes confusing and a wrong perception what this draft is about. \r\n\r\nIn my opinion, this draft evolves the concept RFC 7523 to allow use of JWTs bound to a key for client authentication. \r\n\r\nConsequently,  I suggest to rename the draft to \"Key-bound JWT Client Authentication\".",
      "createdAt": "2024-03-26T18:55:21Z",
      "updatedAt": "2025-07-04T06:42:43Z",
      "closedAt": "2025-07-04T06:42:43Z",
      "comments": [
        {
          "author": "adeinega",
          "authorAssociation": "NONE",
          "body": "@tlodderstedt, along with this renaming, the spec could also simplify a few other things. Say it can remove all references / interaction with Client Backend, so an OAuth client could simply reuse [OAuth 2.0 Dynamic Client Registration Protocol (RFC 7591)](https://datatracker.ietf.org/doc/html/rfc7591).",
          "createdAt": "2024-07-15T17:42:25Z",
          "updatedAt": "2024-07-15T17:42:25Z"
        },
        {
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Would be good to know what \"a wrong perception what this draft is about\" was about, but I suspect we clarified those confusions in the oauth wg.\r\n\r\nterms wallet attestation/key attestation have already been widely used in the community that is the target audience for this draft. are we sure renaming this draft to client authentication would not cause more confusion?",
          "createdAt": "2024-07-26T20:47:47Z",
          "updatedAt": "2024-07-26T20:47:47Z"
        },
        {
          "author": "ju-cu",
          "authorAssociation": "NONE",
          "body": "Also related to #68 where I argue (or try to) that this draft is all about \"Key-bound JWT Client Authentication\" and not attestation per se.",
          "createdAt": "2024-11-27T08:43:02Z",
          "updatedAt": "2024-11-27T08:43:02Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "As editors we believe the draft name fits the scope of this work, hence we don't believe it needs to be changed. Marking pending close.",
          "createdAt": "2025-06-24T07:04:25Z",
          "updatedAt": "2025-06-24T07:04:25Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "I_kwDOJaEkaM6D1qnJ",
      "title": "Add required typ values for the client-attestation and client-attestation-pop in line with JWT BCP",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/72",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [
        "ready-for-pr"
      ],
      "body": "",
      "createdAt": "2024-03-27T20:50:04Z",
      "updatedAt": "2024-10-21T19:03:24Z",
      "closedAt": "2024-10-21T19:03:24Z",
      "comments": [
        {
          "author": "adeinega",
          "authorAssociation": "NONE",
          "body": "\ud83d\udc4d ",
          "createdAt": "2024-07-15T17:44:13Z",
          "updatedAt": "2024-07-15T17:44:13Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "I just stumbled over this -> Right now the typ is only shown in Appendix A - we should definitely introduce specific typ values in section 4.2 and 4.3",
          "createdAt": "2024-09-10T10:23:06Z",
          "updatedAt": "2024-09-10T10:23:06Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "I_kwDOJaEkaM6D2Ixt",
      "title": "Add relevant oauth error responses to token requests when the client attestation is invalid",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/73",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "has-pr"
      ],
      "body": "",
      "createdAt": "2024-03-27T22:27:44Z",
      "updatedAt": "2025-07-07T06:42:10Z",
      "closedAt": "2025-07-07T06:42:09Z",
      "comments": []
    },
    {
      "number": 75,
      "id": "I_kwDOJaEkaM6FQ1vP",
      "title": "Make PoP optional",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/75",
      "state": "CLOSED",
      "author": "nikosft",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I believe there are many existing systems that generate \"client attestations\" and can benefit from this draft, examples of such client attestations are:\r\n\r\n- Github's [oidc token for actions](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect)\r\n- SPRIFFE [JWT Verifiable Document](https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/#spiffe-verifiable-identity-document-svid)\r\n- Azure [AD Pod identity](https://azure.github.io/aad-pod-identity/)\r\n\r\nHowever in all these solutions, attestations are not bound to any key. ",
      "createdAt": "2024-04-10T14:45:46Z",
      "updatedAt": "2024-05-24T06:20:23Z",
      "closedAt": "2024-05-24T06:20:23Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "OpenID and OAuth already have mechanisms for ordinarily signed JWTs as a means of client authentication toward an AS, such as private key jwt and token exchange so I'm unsure how supporting this would be any different to those existing mechanisms?",
          "createdAt": "2024-05-19T09:35:33Z",
          "updatedAt": "2024-05-19T09:35:33Z"
        },
        {
          "author": "nikosft",
          "authorAssociation": "NONE",
          "body": "Yes you are right",
          "createdAt": "2024-05-24T06:20:23Z",
          "updatedAt": "2024-05-24T06:20:23Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDOJaEkaM6JXDu1",
      "title": "Explicitly state the client attestation mechanism can be used at other endpoints such as PAR",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/76",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tplooker"
      ],
      "labels": [
        "ready-for-pr"
      ],
      "body": "Should we explcitly say that this may be used at the PAR endpoint?\r\n\r\n_Originally posted by @paulbastian in https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/74#discussion_r1605361442_\r\n            ",
      "createdAt": "2024-05-19T09:38:43Z",
      "updatedAt": "2024-10-21T18:41:40Z",
      "closedAt": "2024-10-21T18:41:40Z",
      "comments": []
    },
    {
      "number": 77,
      "id": "I_kwDOJaEkaM6JXD5y",
      "title": "Update client attestation pop to include JTI and nonce",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/77",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [
        "ready-for-pr"
      ],
      "body": "              The example neither include nonce nor jti, so it does not have replay protection?\r\n\r\n_Originally posted by @paulbastian in https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/74#discussion_r1605339102_\r\n            ",
      "createdAt": "2024-05-19T09:40:32Z",
      "updatedAt": "2024-10-16T06:35:11Z",
      "closedAt": "2024-10-16T06:35:11Z",
      "comments": []
    },
    {
      "number": 78,
      "id": "I_kwDOJaEkaM6JnBw2",
      "title": "new HTTP headers are supposed to request their registration",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/78",
      "state": "CLOSED",
      "author": "bc-pi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "> It just (re)occurred to me that specs defining new HTTP headers (which the cool kids call fields nowadays) are supposed to request their registration in the [Hypertext Transfer Protocol (HTTP) Field Name Registry](https://www.iana.org/assignments/http-fields/http-fields.xhtml). I don't want to hold up this PR for this but will create an issue from this comment so as not to lose track of it.\r\n\r\n_Originally posted by @bc-pi in https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/issues/74#issuecomment-2123037858_\r\n            ",
      "createdAt": "2024-05-21T16:47:50Z",
      "updatedAt": "2024-08-29T07:40:00Z",
      "closedAt": "2024-08-29T07:40:00Z",
      "comments": []
    },
    {
      "number": 79,
      "id": "I_kwDOJaEkaM6Jqf8l",
      "title": "Usage of \"public clients\" / \"deployments traditionally viewed as a public client\"",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/79",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "              \"public clients\" ... \"to authenticate\" is a contradiction. The text further up speaks about \"deployments traditionally viewed as a public client\", that's a better description. I would even argue either this spec is for confidential clients of a new kind or it is a new type of client. But it is not for public clients.\r\n\r\n_Originally posted by @tlodderstedt in https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/74#discussion_r1606620990_\r\n            ",
      "createdAt": "2024-05-22T05:43:06Z",
      "updatedAt": "2025-08-12T06:34:35Z",
      "closedAt": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "What would be the downside of defining a new type of client, e.g. attested client?",
          "createdAt": "2024-09-11T06:54:30Z",
          "updatedAt": "2024-09-11T06:54:30Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "It sounds similar to 'credentialed client', a concept that OAuth 2.1 toyed with and ultimately decided didn't help: https://github.com/oauth-wg/oauth-v2-1/issues/107",
          "createdAt": "2024-09-11T07:53:32Z",
          "updatedAt": "2024-09-11T07:53:32Z"
        },
        {
          "author": "babisRoutis",
          "authorAssociation": "NONE",
          "body": "> What would be the downside of defining a new type of client, e.g. attested client?\r\n\r\nI am not sure about the spec, yet [Attested Client](https://github.com/eu-digital-identity-wallet/eudi-lib-jvm-openid4vci-kt/blob/1e85b1b2867f6bd47bdcddc1f5a54048e24a172e/src/main/kotlin/eu/europa/ec/eudi/openid4vci/Config.kt#L39) was the term to use in our VCI library.\r\n",
          "createdAt": "2024-09-14T07:58:16Z",
          "updatedAt": "2024-09-14T07:58:16Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "To be clear, the term \"credentialed client\" in the earlier OAuth 2.1 draft had nothing to do with app attestations. ",
          "createdAt": "2025-05-29T20:54:44Z",
          "updatedAt": "2025-05-29T20:54:44Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "I_kwDOJaEkaM6RA5VD",
      "title": "client_id optional in the request body",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/81",
      "state": "CLOSED",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tplooker"
      ],
      "labels": [
        "has-pr"
      ],
      "body": "OAuth2 chapter 4.1.3 Access Token Request says:\r\n\r\n>  client_id\r\n>         REQUIRED, if the client is not authenticating with the\r\n>         authorization server as described in [Section 3.2.1](https://datatracker.ietf.org/doc/html/rfc6749#section-3.2.1).\r\n\r\nbut then client assertion drafts make client_id optional https://datatracker.ietf.org/doc/html/rfc7521\r\n\r\nWould you agree that client_id should be optional in this draft, too?",
      "createdAt": "2024-07-26T20:24:32Z",
      "updatedAt": "2025-07-07T06:53:14Z",
      "closedAt": "2025-07-07T06:53:14Z",
      "comments": [
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "This draft doesn't directly use the assertion framework anymore, but I think the idea (to not require client_id) makes sense here as well. This would basically mean this?\r\n- if client_id exists, then\r\n  - Attestation `sub` MUST be equal to `client_id`\r\n  - Attestation PoP `iss` MUST be equal to `client_id`\r\n- otherwise client_id is implicit and \r\n  - Attestation `sub` MUST be equal to Attestation PoP `iss` \r\n ",
          "createdAt": "2024-08-21T12:50:06Z",
          "updatedAt": "2024-08-21T12:50:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I think just re-reading the context of this issue we do need to make sure that the client ID is present in the request somewhere for interactions with the AS otherwise the AS wont be able to authenticate the client as it wont know what key to use to identify the client and or decide whether that client should even be trying to authenticate with a client attestation. The current spec text makes its required and I think thats the right direction.",
          "createdAt": "2025-06-04T00:41:48Z",
          "updatedAt": "2025-06-04T00:41:48Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "@Sakurann do you still think this should be optional if so can you explain how we could accomodate the above?",
          "createdAt": "2025-06-04T00:53:31Z",
          "updatedAt": "2025-06-04T00:53:31Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "I don't think we always need a client_id for all cases, but let's discuss",
          "createdAt": "2025-06-06T11:25:41Z",
          "updatedAt": "2025-06-06T11:25:41Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "> I think just re-reading the context of this issue we do need to make sure that the client ID is present in the request somewhere for interactions with the AS otherwise the AS wont be able to authenticate the client as it wont know what key to use to identify the client and or decide whether that client should even be trying to authenticate with a client attestation. The current spec text makes its required and I think thats the right direction.\n\nBut in all cases with this draft the AS is already receiving client_id in both the iss & sub? Passing it in client_id as well definitely seems unnecessary, in the same way as it's unnecessary (and not required) when using private_key_jwt.",
          "createdAt": "2025-06-10T21:30:02Z",
          "updatedAt": "2025-06-10T21:30:19Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I also had trouble explaining why we have the client_id in the request, if it's already present inside the client attestation JWT.",
          "createdAt": "2025-06-11T06:19:55Z",
          "updatedAt": "2025-06-11T06:20:18Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposing to add text to section 6.3. Usage of Cleint Attestation at Token Endpoint, informative statement saying:\n- it's not required to send `client_id` in the Token Request body\n- if it's present in the Token Request body, then it MUST match with `sub` of Client Attestation JWT",
          "createdAt": "2025-06-24T07:12:23Z",
          "updatedAt": "2025-06-24T07:12:23Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I've opened #129 which clarifies that the client_id must be consistent in the client attestation and pop with the client_id value reported in the token request. I don't think it is worthwhile saying its not required to send the client_id in the token request as RFC 6749 is already clear that this is optional.\n\nOne minor further question I had for discussion @c2bo @paulbastian is that we don't currently have any validation rules that requires us to check the client id in the client attestation and pop are consistent regardless of whether the client id is present in the token request, we may need to add this.",
          "createdAt": "2025-07-06T22:19:50Z",
          "updatedAt": "2025-07-06T22:19:50Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I've updated #129 to include a clarification for the second case in my above comment.",
          "createdAt": "2025-07-06T22:23:43Z",
          "updatedAt": "2025-07-06T22:23:43Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDOJaEkaM6ZepgU",
      "title": "Rewrite introduction that the main purpose is not about key attestation",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/84",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [
        "ready-for-pr"
      ],
      "body": "",
      "createdAt": "2024-10-09T06:49:23Z",
      "updatedAt": "2025-03-03T07:14:37Z",
      "closedAt": "2025-03-03T07:14:35Z",
      "comments": [
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "Closed with #100",
          "createdAt": "2025-03-03T07:14:35Z",
          "updatedAt": "2025-03-03T07:14:35Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDOJaEkaM6Zes1k",
      "title": "Take lessons learned from nonce endpoint in OpenID4VCI and apply to this draft",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/85",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tplooker"
      ],
      "labels": [
        "discuss"
      ],
      "body": "",
      "createdAt": "2024-10-09T06:53:36Z",
      "updatedAt": "2025-03-03T19:07:29Z",
      "closedAt": "2025-03-03T19:07:28Z",
      "comments": []
    },
    {
      "number": 86,
      "id": "I_kwDOJaEkaM6ZewRX",
      "title": "Restructure sections for presentation of attestation",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/86",
      "state": "CLOSED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [
        "c2bo"
      ],
      "labels": [
        "ready-for-pr"
      ],
      "body": "My proposal would be:\r\n\r\n- Section 5: HTTP header based syntax as currently defined but make clear that is not only for the token endpoint (merge 4.1 and 4.4 into this)\r\n- Section 6: Alternative representation as SDJWT if header based syntax is not available (e.g., Wallet to RP case in openid4vp)",
      "createdAt": "2024-10-09T06:57:23Z",
      "updatedAt": "2024-10-21T18:41:40Z",
      "closedAt": "2024-10-21T18:41:39Z",
      "comments": [
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "Should also include #76",
          "createdAt": "2024-10-15T06:33:11Z",
          "updatedAt": "2024-10-15T06:33:11Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "I_kwDOJaEkaM6abIFu",
      "title": "Delete key attestation example from the Annex",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/88",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-16T06:37:08Z",
      "updatedAt": "2024-10-21T19:09:17Z",
      "closedAt": "2024-10-21T19:09:16Z",
      "comments": []
    },
    {
      "number": 89,
      "id": "I_kwDOJaEkaM6a_oSx",
      "title": "Remove backslash for line wrapping from examples",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/89",
      "state": "CLOSED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "Most of the specs I've seen do not use an extra backslash to signal newline in their examples. I've checked PAR (https://datatracker.ietf.org/doc/html/rfc9126), JWT(https://datatracker.ietf.org/doc/html/rfc7519), OpenID specs and most of the current OAuth WG drafts and none of them have a backslash. I am aware of https://datatracker.ietf.org/doc/html/rfc8792, but I would to like to keep things somewhat consistent with other work.\r\n\r\n --> I would prefer to remove the backslash from the examples",
      "createdAt": "2024-10-20T11:42:34Z",
      "updatedAt": "2025-02-28T09:10:57Z",
      "closedAt": "2025-02-28T09:10:57Z",
      "comments": []
    },
    {
      "number": 94,
      "id": "I_kwDOJaEkaM6f1u6M",
      "title": "JWT examples are missing the `typ` header parameter",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/94",
      "state": "CLOSED",
      "author": "TakahikoKawasaki",
      "authorAssociation": "NONE",
      "assignees": [
        "c2bo"
      ],
      "labels": [
        "bug",
        "ready-for-pr"
      ],
      "body": "JWT examples in the following sections are missing the `typ` header parameter. These examples should be corrected.\r\n\r\n- 6.1. Client Attestation HTTP Headers\r\n- 6.3. Client Attestation at the Token Endpoint\r\n- 6.4. Client Attestation at the PAR Endpoint\r\n- 7.1. Concatenated Serialization Format\r\n\r\n",
      "createdAt": "2024-11-22T03:35:52Z",
      "updatedAt": "2025-02-28T09:10:16Z",
      "closedAt": "2025-02-28T09:10:16Z",
      "comments": [
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "Sorry for the late response, but you are absolutely correct and the examples should be fixed.",
          "createdAt": "2025-01-09T10:20:20Z",
          "updatedAt": "2025-01-09T10:20:20Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "I_kwDOJaEkaM6jNI8Z",
      "title": "Add section to consider usage at RS",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/95",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "add section 6.5 to use this mechniams at the resource Server",
      "createdAt": "2024-12-13T11:02:53Z",
      "updatedAt": "2025-08-12T06:33:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Im not sure we should define any usage of this outside of the AS, generally client authentication schemes in OAuth have always been about authenticating the client to the AS, the AS then issues a token that can be used to authenticate the client to the RS.",
          "createdAt": "2025-06-04T00:43:38Z",
          "updatedAt": "2025-06-04T00:43:38Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "I see value in allowing this - there are imho 2 cases where attestation based client auth might be interesting:\n- as a mechanism to authenticate the client at AS\n- additional information (security) about the state of a client (via its attestation) at possibly other endpoints like RS\n\nLet's discuss",
          "createdAt": "2025-06-06T08:25:27Z",
          "updatedAt": "2025-06-06T08:25:27Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "This was also brought up at IETF 123 and the ask was to expand the text on possible usage at RS if I recall correctly",
          "createdAt": "2025-07-30T12:08:32Z",
          "updatedAt": "2025-07-30T12:08:32Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "I_kwDOJaEkaM6uMQVQ",
      "title": "Support returning nonce in any responses, similar to DPoP",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/101",
      "state": "CLOSED",
      "author": "TimoGlastra",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "has-pr"
      ],
      "body": "DPoP allows returning the DPoP nonce in any response using the DPoP-Nonce header.\n\nWould it be possible to also enable support for this in this specification.\n\nFor integration with OID4VCI we now have three nonces:\n- DPoP nonce\n- Client Attestation Nonce\n- Credential request/proof nonce \n\nIt would be great if we can bundle these in one request to the nonce endpoint. For DPoP I see no problems, but it seems incompatible with the method described in this specification",
      "createdAt": "2025-03-15T18:54:12Z",
      "updatedAt": "2025-07-07T06:42:11Z",
      "closedAt": "2025-07-07T06:42:11Z",
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Editors Call\n- agree that this is useful\n- solution could be to state that `attestation-nonce` headers could be returned in any previous responses (e.g. other endpoints)\n- be aware that the text on DPoP standard is not as clear as you may think, see also https://github.com/openid/OpenID4VCI/pull/478",
          "createdAt": "2025-04-03T06:42:06Z",
          "updatedAt": "2025-04-03T06:42:06Z"
        },
        {
          "author": "TimoGlastra",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Section 8.2 of DPoP spec reads to me that you can include a DPoP nonce in any response\n\nhttps://datatracker.ietf.org/doc/html/rfc9449#name-providing-a-new-nonce-value\n\n(Ah i see the PR now, I interpreted it the same as @jogu, but I also don't see a lot of ambiguity in the text, it seems pretty clear to me)",
          "createdAt": "2025-04-03T07:21:42Z",
          "updatedAt": "2025-04-03T07:24:18Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "I_kwDOJaEkaM6ufMFT",
      "title": "Potential problems with HTTP OPTIONS?",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/102",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "has-pr"
      ],
      "body": "Filip Skokan at IETF 122:\n\nA good web application framework will discern between a preflight and a non-Preflight request and give the dev an option to handle the non-preflight.\n\nWhat this dance will do in a browser, since both the nonce-fetching and actual request is\n\n1) OPTIONS Preflight for the nonce-fetch\n\n2) nonce-fetch\n\n3) OPTIONS Preflight for the actual request\n\n4) actual request\n\nThe js client has no access to the preflight response so there's no option to make the preflight the nonce-value vessel. Of course at the point the actual request's preflight the nonce must be incorporated in the request.\n\n(meetecho messed up the list formatting)\n\nfix: since both the nonce-fetching and actual request * are not \"simple\" requests\n\nsee \"simple requests\" https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CORS#simple_requests",
      "createdAt": "2025-03-18T07:10:19Z",
      "updatedAt": "2025-07-07T06:42:11Z",
      "closedAt": "2025-07-07T06:42:10Z",
      "comments": [
        {
          "author": "francis-pouatcha",
          "authorAssociation": "NONE",
          "body": "An alternative could be a dedicated `GET /nonce` endpoint. This endpoint would return a periodically updated, server-generated nonce (non-client-specific, protected by a server secret).\n\nIf this `GET` request qualifies as a CORS simple request (i.e., requires no custom headers for the fetch), it could avoid the preflight *for the nonce fetch itself*.\n\nWhile the subsequent authenticated request (using the nonce and custom attestation headers) would still require its own preflight, this `GET` approach could potentially reduce the total number of requests, resulting to:\n\n1. GET /nonce-fetch\n2. OPTIONS Preflight for the actual request\n3. actual request",
          "createdAt": "2025-04-17T15:20:56Z",
          "updatedAt": "2025-04-17T15:20:56Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "@panva I may be missing something here, but I'm not sure how using HTTP OPTIONS is any less efficient then using another HTTP verb in the nonce request like GET. Practically speaking if we boil this down to a simple sequence diagram, the proposal to use a HTTP OPTIONS based request would net the following.\n\n```mermaid\nsequenceDiagram\n    participant WA as Web Application\n    participant WP as Web Platform\n    participant CI as Credential Issuer\n\n    WA->>WP: Nonce request using fetch() with HTTP Options\n    WP->>CI: Preflight HTTP OPTIONS request for CORS\n    CI->>WP: HTTP Response to Preflight request\n    WP->>WP: Evaluate CORS policy\n    WP->>CI: Send nonce request using HTTP Options\n    CI->>WP: HTTP Response to nonce request\n    WP->>WA: Return HTTP response from nonce request \n```\n\nWhich yes does mean two HTTP requests are sent to get the nonce, but I dont think this can be avoided in any solution because of how the web platform works. Unless as pointed out we can get the nonce request to qualify as a simple request? \n\nFor example if the nonce fetching were instead based on an endpoint that is interfaced with using the GET HTTP Verb, wouldn't the following sequence diagram be what ensues?\n\n```mermaid\nsequenceDiagram\n    participant WA as Web Application\n    participant WP as Web Platform\n    participant CI as Credential Issuer\n\n    WA->>WP: Nonce request using fetch() with HTTP Get\n    WP->>CI: Preflight HTTP OPTIONS request for CORS\n    CI->>WP: HTTP Response to Preflight request\n    WP->>WP: Evaluate CORS policy\n    WP->>CI: Send nonce request using HTTP Get\n    CI->>WP: HTTP Response to nonce request\n    WP->>WA: Return HTTP response from nonce request \n```\n",
          "createdAt": "2025-05-07T23:27:35Z",
          "updatedAt": "2025-05-07T23:27:35Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "@tplooker https://mailarchive.ietf.org/arch/msg/oauth/nKdi0aeGymSMxkL51CmNgzbh8_g/\n\n> Summarizing, we should look for a different solution than OPTIONS on\n> existing endpoints because it conflicts with existing unrelated behaviours\n> (CORS). Any solution we consider that doesn't extend existing OAuth 2.0\n> responses should also likely stay within the confines of being a Simple\n> Request\n> <https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CORS#simple_requests>\n> but\n> preferably we'll consider extending our existing protocol messages and\n> using their existing semantics before resorting to adding new endpoints.\n",
          "createdAt": "2025-05-08T09:49:44Z",
          "updatedAt": "2025-05-08T09:49:44Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "@panva, could you take a look at #110? That was the outcome of paul, justin and me discussing for another hour at EIC",
          "createdAt": "2025-05-08T12:04:52Z",
          "updatedAt": "2025-05-08T12:04:52Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "I_kwDOJaEkaM6ufObi",
      "title": "Client MUST support nonce fetching",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/103",
      "state": "CLOSED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "has-pr"
      ],
      "body": "Feedback from IETF 122: We should be more explicit and state that the client MUST support the nonce fetching mechanism.",
      "createdAt": "2025-03-18T07:13:54Z",
      "updatedAt": "2025-07-07T06:42:11Z",
      "closedAt": "2025-07-07T06:42:11Z",
      "comments": []
    },
    {
      "number": 104,
      "id": "I_kwDOJaEkaM6uyc-l",
      "title": "Nonce is meant for freshness, not to guarantee one-time use",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/104",
      "state": "CLOSED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "has-pr"
      ],
      "body": "Feedback from IETF 122: We should be more clear in the draft that the intention of the nonce is to guarantee freshness, not one-time use (which can be really hard to guarantee depending on deployment etc).",
      "createdAt": "2025-03-19T16:36:19Z",
      "updatedAt": "2025-07-07T06:42:10Z",
      "closedAt": "2025-07-07T06:42:10Z",
      "comments": [
        {
          "author": "Denisthemalice",
          "authorAssociation": "NONE",
          "body": "Step (5) is described as:\n\n>   ` (5) The Client Instance generates a Proof of Possession (PoP) with the Client Instance Key.`\n\n\nBefore generating a Proof of Possession (PoP) with the Client Instance Key, the client needs to select a mechanism \nthat can allow the authorization server to detect replays.\n\nIn a client - server paradigm, there exit two mechanisms that are able to detect replay attacks that were orinally defined \nin ISO/IEC 10181-2:1996. 3.18 (Security frameworks for open systems: Authentication framework \u2014 Part 2):\n- using a challenge generated and sent by the server to the client, or\n- using a unique number generated and sent by the client to the server.\n\nThe ISO definitions are as follows: \n\n> challenge\n> A time variant parameter generated by a verifier.\n> ISO/IEC 10181-2:1996. 3.8 (Security frameworks for open systems: Authentication framework \u2014 Part 2)\n\n> challenge\n> data item chosen at random and sent BY THE VERIFIER to the claimant, which is used by the claimant, \n> in conjunction with secret information held by the claimant, to generate a RESPONSE WHICH IS SENT TO THE VERIFIER\n> ISO/IEC 9798-1:2010, 3.5 (Security techniques \u2014 Entity authentication \u2014 Part 1: General)\n\n> unique number\n> A time variant parameter generated by a claimant\n> ISO/IEC 10181-2:1996. 3.18 (Security frameworks for open systems: Authentication framework \u2014 Part 2)\n\nRFC 9449 defines the nonce claim in 12.7.1. \"nonce\" Registration Update\n\n> The Internet Security Glossary [[RFC4949](https://www.rfc-editor.org/rfc/rfc9449.html#RFC4949)] \n> provides a useful definition of nonce as a random or non-repeating value that is included in data exchanged \n> by a protocol, usually for the purpose of guaranteeing liveness and thus detecting and protecting against replay attacks.\n> \n> Claim Name:\n> nonce\n> Claim Description:\n> Value used to associate a Client session with an ID Token (MAY also be used for nonce values in other applications of JWTs)\n\nThis is rather general and this does not allow to distinguish between a value generated by a client or by a server.\n\nThe current draft is using the word \"nonce\" in a way that is different from the way it has been used for years \nwithin the ISO community. \n\nThe definition of a nonce in the current draft is:\n\n>    *  nonce: OPTIONAL.  The nonce (nonce) claim MUST specify a String\n>       value that is provided BY THE AUTHORIZATION SERVER to associate\n>       the Client Attestation PoP JWT with a particular transaction and\n>       PREVENT replay attacks.\n\nNote that this claim cannot *PREVENT* replay attacks but can be used to *DETECT* replay attacks.\n\nFor this concept, where the String value is provided BY THE SERVER, the term \"challenge\" is being used within the ISO community.  \n\nFor the term \"nonce\", the ISO community is using the following definitions:\n\n> nonce\n> number used once\n> ISO/IEC 9797-3:2011, 3.3\n> \n> nonce\n> value that is used one and only one time to provide uniqueness to a value (e.g., a secure cryptographic key) \n> in whose derivation it participates or to uniquely identify a single instance of something (e.g., a timestamp) \n> exchanged between an application client and a device server\n> ISO/IEC 14776-454:2018, 3.1.95\n\nIt is confusing to use the term \"nonce\" when the term \"challenge\" is used by the ISO community.\n\nAt this time, let us focus on section 11.1 (Replay Attack Detection).\n\n>    The following mechanisms exist within this client authentication\n>    method in order to allow an authorization server to detect replay\n>    attacks for presented client attestation PoPs:\n> \n>    *  The client uses \"jti\" (JWT ID) claims for the Client Attestation\n>       PoP JWT and the authorization server maintains a list of used\n>       (seen) \"jti\" values for the time of which the JWT would be\n>       considered valid based on the applicable \"exp\" claim.  If any\n>       Client Attestation PoP JWT would be replayed, the authorization\n>       server would recognize the \"jti\" and respond with an\n>       authentication error.\n> \n>    *  The authorization server provides a nonce for the particular\n>       transaction and the client uses it for the \"nonce\" claim in the\n>       Client Attestation PoP JWT.  The authorization server validates\n>       that the nonce matches for the transaction.  This approach may\n>       require an additional roundtrip in the protocol.  The\n>       authorization server MUST ensure that the nonce provides\n>       sufficient entropy.\n> \n>    *  The authorization server may expect the usage of a nonce in the\n>       Client Attestation PoP JWT, but instead of providing the nonce\n>       explicitly, the client may implicitly reuse an existing artefact,\n>       e.g. the authorization code.  The authorization server MUST ensure\n>       that the nonce provides sufficient entropy.\n> \n>    The approach using a nonce explicitly provided by the authorization\n>    server gives stronger replay attack detection guarantees, however\n>    support by the authorization server is OPTIONAL to simplify mandatory\n>    implementation requirements.  The \"jti\" method is mandatory and hence\n>    acts as a default fallback.\n> \n> \n\nThe \"jti\" claim is defined as in [RFC7519, Section [4.1.7](https://www.rfc-editor.org/rfc/rfc7519.html#section-4.1.7)] (see https://www.iana.org/assignments/jwt/jwt.xhtml#claims)\n\n> 4.1.7.  \"jti\" (JWT ID) Claim\n>    The \"jti\" (JWT ID) claim provides a unique identifier for the JWT.\n>    The identifier value MUST be assigned in a manner that ensures that\n>    there is a negligible probability that the same value will be\n>    accidentally assigned to a different data object; if the application\n>    uses multiple issuers, collisions MUST be prevented among values\n>    produced by different issuers as well.  The \"jti\" claim can be used\n>    to prevent the JWT from being replayed.  The \"jti\" value is a case-\n>    sensitive string.  Use of this claim is OPTIONAL.\n\nThis \"jti\"  claim, while it would be capable to support the nonce approach (in the ISO sense), would place a hard burden on the client. It would need to be truly unique during the life time of the client so that it cannot be non-repeating.\n\nUnique numbers can be repeating numbers if the probability of repetition is kept very low. If the same unique number is chosen by two clients and presented to the same server, the one which sucessfully presents it first will succeed while the other one will fail, but it can make another attempt using another unique number. This particular case creates a denial of service, but not in a security breach.\n\nIn practice, unique numbers can be supported using two parameters: \n- the time at which the Client Attestation PoP (\"iat\" claim) has been generated, and \n- a random number (\"rnd\" claim) that needs to be unique which a high level of probability \n  when associated with the previous value of the time .\n\nThe text from section 11.1 (Replay Attack Detection) should be modified to support :\n-    EITHER a unique number generated by the client\n-    OR a challenge generated by the authorization server.\n\nIn order to avoid confusion, a different name should be used for :\n\n(1) the \"value\" generated and sent by a client and \n(2) the \"value\" generated and sent by the server \n\nthat can be used to detect replays. As an example, they can't both be called a nonce.\n\nThis leads to consider the following three claims: \"iat\", \"rdn\" (for random number\") and \"chal\" (for challenge).\n\nEITHER, both the \"iat\" and the \"rdn\" claims MUST be present OR the \"chal\" claim MUST be present.\n\nBoth mechanisms provide the same replay attack detection guarantees.\n\nThe text below is a proposal for revising the text from 11.1 (Replay Attack Detection).\n\n> In order to allow an authorization server to detect replay attacks for presented client attestation PoPs, \n> one out of the two following mechanisms MUST be used:\n> \n> 1.  For every Client Attestation PoP JWT, the client generates a unique number (i.e., a number that will unique with a high level \n> of probability)  that is composed of two claims : a \"iat\" claim and a \"rdn\" claim. \n\n> For every value of the \"iat\" claim, the value of the \"rdn\" claim generated by the client MUST be different. The \"rdn\" claim \n> MUST be a pseudo random number that SHOULD be sufficiently large to allow a large number of clients to sucessfully use \n> the mechanism when they select the same value for the \"iat\" claim. The \"rdn\" claim contains a String which SHOULD contain \n> at least 32 characters.\n\n> The authorization server chooses a time window around its current time. \n> \n> When the authorization server receives a Client Attestation PoP JWT:\n> \n> a) If a received \"iat\" claim is outside of this time window, the authorization server would respond with an authentication error.\n> \n> b) If a received \"iat\" claim is inside this time window and the associated \"rdn\" claim can be successfully used to validate \n> a Client Attestation PoP JWT, then the authorization server adds the values both of the \"iat\" claim and the associated \"rdn\" claim \n> into a list of validated pairs of \"iat\" and \"rdn\" claims. \n> \n> c) If a received \"iat\" claim is inside this time window and the values both of \"iat\" claim and of the associated \"rdn\" claim \n> are present in the list of validated pairs of \"iat\" and a \"rdn\" claims, the authorization server would respond \n> with an authentication error.\n\n> When the value of a \"iat\" claim from an entry falls outside of the time window, the authorization server SHOULD remove \n> the entry from the list.\n> \n> 2. Before generating a Client Attestation PoP JWT, the client requests a challenge to the authorization server. \n> The authorization server generates a challenge that MUST be unique during a chosen time window. \n> The \"chal\" claim contains a String which SHOULD contain at least 32 characters.\n>\n> During that time window, the authorization server maintains a list of the challenges which are sent associated \n> with the time when they are sent.\n \n> The client places the received challenge into the \"chal\" claim in the Client Attestation PoP JWT. \n\n> When the authorization server receives a Client Attestation PoP JWT:\n> \n> a) If this value of the \"chal\" claim is not present in the list, the authorization server would respond with an authentication error.\n> \n> b) If this value of the \"chal\" claim is present in the list and can be successfully used to validate a Client Attestation PoP JWT,\n> the authorization server removes this value from the list of challenges. \n>\n> When the value of a current time from an entry falls outside of the time window, the authorization server SHOULD remove \n> the entry from the list.\n\n> The authorization server can recognize which mechanism has been chosen by the client:\n> If both the \"rdn\" claim and the \"chal\" claim are present or if either only the \"iat\" claim or the \"rdn\" claim is present, \n> then the authorization server would respond with an authentication error.\n> If both the \"iat\" claim and a \"rdn\" claim are present, then the first mechanism has been selected by the client. \n> If the \"chal\" claim is present, then the second mechanism has been selected by the client. \n\nThe mechanisms are independent from the other claims of the Client Attestation PoP JWT, e.g., independent from the applicable \"exp\" claim or from the \"jti\" claim. The memory requirements on the client side and on the server side are much lower than in the previous description. The same principles can be used in the context of replay detection betwen a client and a server by using only claims that are necessary to detect replays.\n\nMany other changes would be required, in particular in the text from section 8 and in the definitions of the claims.",
          "createdAt": "2025-04-01T08:26:38Z",
          "updatedAt": "2025-04-01T08:26:38Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "I_kwDOJaEkaM6wl9zh",
      "title": "Steps (1) to (4) should be moved into an informative annex",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/105",
      "state": "CLOSED",
      "author": "Denisthemalice",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "pending-close"
      ],
      "body": "Steps (1) to (4) are described as follows:\n\n>    (1) The Client Instance generates a key (Client Instance Key) and\n>    optional further attestations (that are out of scope) to prove its\n>    authenticity to the Client Attester.\n> \n>    (2) The Client Instance sends this data to the Client Attester in\n>    request for a Client Attestation JWT.\n> \n>    (3) The Client Attester validates the Client Instance Key and\n>    optional further data.  It generates a signed Client Attestation JWT\n>    that is cryptographically bound to the Client Instance Key generated\n>    by the Client.  Therefore, the attestation is bound to this\n>    particular Client Instance.\n> \n>    (4) The Client Attester responds to the Client Instance by sending\n>    the Client Attestation JWT.\n\n\nSteps (1) to (4) are OPTIONAL while steps (2) and (4) are not described and hence cannot be implemented. \n\nThe current draft is only addressing a small part of the whole picture.\n\nAlternatively, the Client instance can be installed (downloaded) with one Client Attestation JWT that is already present.  \nLater on, the client will need to renew its original Client Attestation JWT before it expires.\n\nThe draft should either assume that the Client Attestation JWT is already present or should describe in details how it can be obtained.\n\nIf only a rough description is provided (as it is the case for the moment for steps (1) to (4) ), steps (1) to (4) should be taken out of the figure placed on page 3 and moved into an informative annex. The same approach should be made for the other alternative when the Client Attestation JWT is already present when installing/downloading the client from a trusted source.",
      "createdAt": "2025-04-01T08:46:43Z",
      "updatedAt": "2025-06-24T06:56:52Z",
      "closedAt": "2025-06-24T06:56:52Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> The draft should either assume that the Client Attestation JWT is already present or should describe in details how it can be obtained.\n\nI'm not sure I agree here and there is lots of precedent with in OAuth related specifications to frame as we have in this draft. For example RFC 6749 does not stipulate how the authorisation process occurs after the client has initiated an authorisation request. We are focusing on what drives interoperability while leaving implementations the freedom to differentiate.\n\n> If only a rough description is provided (as it is the case for the moment for steps (1) to (4) ), steps (1) to (4) should be taken out of the figure placed on page 3 and moved into an informative annex. The same approach should be made for the other alternative when the Client Attestation JWT is already present when installing/downloading the client from a trusted source.\n\nI believe the text at this point in the draft is important framing.",
          "createdAt": "2025-05-08T03:49:24Z",
          "updatedAt": "2025-05-08T03:49:24Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with Tobias, the draft orientates at what other OAuth drafts did for introduction and I believe this is good practice.",
          "createdAt": "2025-06-06T08:20:47Z",
          "updatedAt": "2025-06-06T08:20:47Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue has been marked as pending-close for 3 weeks and an explanation for the current text has been provided, closing.",
          "createdAt": "2025-06-24T06:56:52Z",
          "updatedAt": "2025-06-24T06:56:52Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "I_kwDOJaEkaM61NEnw",
      "title": "Further implementer guidance on Client Instance Attestations",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/107",
      "state": "OPEN",
      "author": "Macke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I suggest that it would be useful to implementers if non-normative examples of \"client instance attestations\" were provided.  Attestations about the status of a device, key pair, or application instance may be useful pointers for implementers.  Additionally being clear that it is possible to have several attestations in a single request to the Client Attester would be very helpful to potential implementers.\n\nLine 110 of current editors .md",
      "createdAt": "2025-05-05T15:54:59Z",
      "updatedAt": "2025-05-05T15:56:36Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 108,
      "id": "I_kwDOJaEkaM61NJTE",
      "title": "What is \"unreasonably far in the past\"?",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/108",
      "state": "CLOSED",
      "author": "Macke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "pending-close"
      ],
      "body": "Suggest a re-word of this sentence to say something clearer... perhaps...\n\"The `iat` (issued at) claim MUST specify the time at which the Client Attestation PoP was issued. Note that the authorization server may reject JWTs with an \"iat\" claim value that is deemed to increase risk of mis-use to a level they choose.\"\n\nLine 225 of current editors .md",
      "createdAt": "2025-05-05T16:02:28Z",
      "updatedAt": "2025-07-04T06:41:45Z",
      "closedAt": "2025-07-04T06:41:45Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "This language was inspired by [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523#section-3) which is somewhat related to this draft.\n\n> The JWT MAY contain an \"iat\" (issued at) claim that identifies\n        the time at which the JWT was issued.  Note that the\n        authorization server may reject JWTs with an \"iat\" claim value\n        that is unreasonably far in the past.\n\nYour suggested text is more general but it doesn't really indicate the driver for deciding the risk which is the time represented by the `iat` value relative to the time of validation, which is what the current text focuses more on.",
          "createdAt": "2025-05-08T03:45:16Z",
          "updatedAt": "2025-05-08T03:45:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Adding pending close to this issue based on the above comment.",
          "createdAt": "2025-06-24T06:55:58Z",
          "updatedAt": "2025-06-24T06:55:58Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "I_kwDOJaEkaM61NVxq",
      "title": "Add Authorization Server policy section about \"Reuse of a Client Attestation JWT\"",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/109",
      "state": "CLOSED",
      "author": "Macke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "has-pr"
      ],
      "body": "It would be beneficial to describe that the Authorization Server can also decide whether to accept or reject a Client Attestation JWT.  It might also be beneficial to describe the AZ error response if a request is rejected based on Authorization Server policy.",
      "createdAt": "2025-05-05T16:24:14Z",
      "updatedAt": "2025-07-07T06:42:12Z",
      "closedAt": "2025-07-07T06:42:12Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "IMO this is probably worthwhile documenting in section 6 along side the validation rule OR we could opt for a seperate implementation consideration. Given this isn't the first form of client authentication in OAuth im reluctant to define a specific error type for this method of client authentication failing. Typically client configuration and authorisation server metadata makes it clear what is supported and required.",
          "createdAt": "2025-05-08T03:41:17Z",
          "updatedAt": "2025-05-08T03:41:17Z"
        },
        {
          "author": "Macke",
          "authorAssociation": "NONE",
          "body": "Just for context I am thinking about a scenario where the Authorization Server has additional contextual information that means they wish to force the client to get a fresh Client Attestatiuon JWT before the expiry time is reached.  It is certainly possible to do that by using one of the existing OAuth error responses in RFC6749 but none of them really reflect that scenario and I don't think that client configuration or server metadata is granular enough.  If this scenario is to be supported it might be better to be explicit that the client should request a new attestation. Note OAuth 2.0 does allow for new error codes to be defined in https://www.rfc-editor.org/rfc/rfc6749.html#section-8.5.\n",
          "createdAt": "2025-05-28T11:11:27Z",
          "updatedAt": "2025-05-28T11:11:27Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "@Macke with regard to defining an interoperable error type would you mind reviewing #112 for this too as we have introduced the `invalid_client_attestation` error type? ",
          "createdAt": "2025-06-04T00:36:10Z",
          "updatedAt": "2025-06-04T00:36:10Z"
        },
        {
          "author": "Macke",
          "authorAssociation": "NONE",
          "body": "I like it",
          "createdAt": "2025-06-04T11:07:02Z",
          "updatedAt": "2025-06-04T11:07:02Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "I_kwDOJaEkaM61j3rO",
      "title": "Evolution of the nonce fetching",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/110",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "has-pr"
      ],
      "body": "After many discussions over the last months and especially OSW 2025, in -05 we introduced explicit nonce fetching using HTTP OPTIONS. On the mailing list and IETF 122 we got feedback that this may not be the best approach (#102), so here is another proposal how to advance the mechanisms for explicit nonce fetching in this draft:\n\n- remove the HTTP OPTIONS  mechanism\n- introduce a new, dedicated nonce/challenge endpoint, that enables explicit nonce/challenge fetching\n  - usage of the endpoint is optional, alternative being jti\n- we would add implementation and security consideration to compare three approaches\n  - 1. jti approach (client chosen random), AS needs to cache seen jti values in a sliding time window for replay protection -> this provides freshness and replay protection\n  - 2. challenge/nonce endpoint with self-contained nonces containing server-chosen timestamp -> this provides freshness but no replay protection within the accepted time window\n  - 3. challenge/nonce endpoint with some kind of binding to the session between AS and client -> this provides freshness and replay protection\n\nThe motivation behind this is that other approaches seem complicated and did not lead us to success, while OpenID4VCI already defines a nonce endpoint for the Credential Issuer. Therefore AS nonce endpoint may fit nicely to this concept with little overhead.\n\nMoreover, this would enable us to optionally provide DPoP nonces over this new nonce/challenge endpoint, which seem to present significant challenges for some architectures.\n\nWDYT?",
      "createdAt": "2025-05-07T14:00:09Z",
      "updatedAt": "2025-07-07T06:42:10Z",
      "closedAt": "2025-07-07T06:42:10Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Generally supportive of this proposal, I have some seperate questions about the issue with the HTTP OPTIONS mechanism we have currently which I've documented in #102 but all other aspects of the proposal im aligned with.",
          "createdAt": "2025-05-08T02:41:48Z",
          "updatedAt": "2025-05-08T02:41:48Z"
        },
        {
          "author": "mcguinness",
          "authorAssociation": "NONE",
          "body": "Sharing more as FYI as most folks probably have not seen but there is example in production today of new challenge endpoint with [Apple SSO Platform extension](https://developer.apple.com/documentation/authenticationservices/obtaining-a-server-nonce).\n\nIdPs need to implement this endpoint so Apple devices can sign an assertion with the nonce and registered device key (https://developer.apple.com/documentation/authenticationservices/authentication-process) for login to the Apple Device\n\n",
          "createdAt": "2025-05-08T15:40:21Z",
          "updatedAt": "2025-05-08T15:40:21Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the link @mcguinness! From a quick google search, it seems that the approach is also in use by Microsoft/Entra (so not only Apple)?\n\nThey overload the token endpoint with a new grant_type called \"srv_challenge\" to request a challenge which would be an alternative to the http method currently proposed and very similar to our first proposal (which was header based instead of a grant type) from what I understand. \nedit: I guess overload is not the fully correct description - it would also allow for a dedicated endpoint, so both options are covered by that (overload existing endpoint and provide in different endpoint)\n\nThat would leave us with these general options seen/discussed so far:\n\n- no server provided challenge - use JTI\n- server provided challenge by overloading existing endpoints\n  - grant_type=srv_challenge \n  - ~~header (but people didn't like this one, so maybe let's ignore it?)~~\n  - ~~http method (there was also pushback, so maybe also ignore?)~~\n- server provided challenge by different endpoint \n\nIMHO, we should support at least 2 of those: JTI and some kind of server provided challenge. My current feeling would be that it might be reasonable to allow for all 3 models (since they also have differences in terms of deployment)?",
          "createdAt": "2025-05-09T11:38:40Z",
          "updatedAt": "2025-05-09T11:41:29Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "I am not sure  if I really like overloading the grant_type, but I guess that is a different discussion (and it also seems better than a header)",
          "createdAt": "2025-05-09T12:00:28Z",
          "updatedAt": "2025-05-09T12:00:28Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "I_kwDOJaEkaM6150qT",
      "title": "Add option without PoP but with ad-hoc client attetation and nonce",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/111",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "c2bo"
      ],
      "labels": [
        "ready-for-pr"
      ],
      "body": "In discussions with European Commission, an alternative mechanism for proofing the Client Attestation emerged. Instead of having a Client Attestation containing a key and adding a PoP, we could have the AS provide a nonce and this nonce would be included in the Client Attestation within an ad-hoc issuance, thus requireing no PoP. The discussion was inspired by the mechanism of key attestation in OpenID4VCI that also includes these both options (in the form of two proof_types `jwt` and `attestation`).\n\nThe EU document suggests:\n> The WAA SHALL either be sent along with a Proof-of-Possession (PoP) OR it SHALL contain the nonce value obtained from the nonce endpoint of the Credential Issuer. The former will be referred to as a key bound WAA and the latter as an ephemeral WAA.\n\n",
      "createdAt": "2025-05-09T11:14:02Z",
      "updatedAt": "2025-09-02T06:40:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Conceptually this seems quite similar to private_key_jwt as defined in section 9 of OpenID Connect Core.",
          "createdAt": "2025-06-04T00:30:41Z",
          "updatedAt": "2025-06-04T00:30:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "To be clear im not recommending that gets used here as that re-muddies the water we are trying to clarify around public vs confidential clients.",
          "createdAt": "2025-06-04T00:31:25Z",
          "updatedAt": "2025-06-04T00:31:37Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Editors Call:\n- the mechanism seems rather complex and is likely an edge case, especially as its so close to private_key_jwt\n- the same mechanism could be achieved by letting the backend generate the client instance key and the PoP on its own, without making any changes to the current spec\n- we could benefit from either\n  - error code use_fresh_attestation\n  - AS metadata parameter describing the confidence interval for attestation freshness",
          "createdAt": "2025-09-02T06:34:44Z",
          "updatedAt": "2025-09-02T06:34:44Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "I_kwDOJaEkaM64fGiD",
      "title": "Public clients and their interaction with existing OAuth 2.0 extensions vs attest_jwt_client_auth clients",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/113",
      "state": "OPEN",
      "author": "panva",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "Today we generally equate public client to those which have their auth method set to \"none\", i.e. it they only provide a client_id in the request body to client-authenticated endpoints. All other clients are considered \"confidential\", i.e. they have credentials they prove the access to with the authenticated requests.\n\nThe following are measures that we apply to public clients wrt to a number of OAuth 2.0 extensions off the top of my head (i.e. this may not be a comprehensive list) that may or not be questionable when attest_jwt_client_auth is used.\n\n> TL;DR\n> is a client using attest_jwt_client_auth considered a confidential client with all the bells and whistles?\n\nRefs: https://github.com/oauth-wg/oauth-v2-1/issues/107\nRefs: https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/79\nRefs: https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-12.html#section-2.1\n\n> \"confidential\":\n> Clients that have credentials with the AS are designated as \"confidential clients\"\n>\n> \"public\":\n> Clients without credentials are called \"public clients\"\n\nhttps://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/79 (unresolved at this time) puts the client type to which attest_jwt_client_auth clients fall to into question, so here's a couple more points for that discussion.\n\n---\n\n**RFC 7662 - OAuth 2.0 Token Introspection, Security Considerations**\n\nhttps://www.rfc-editor.org/rfc/rfc7662.html#section-4\n\n> If left unprotected and un-throttled, the introspection endpoint\n   could present a means for an attacker to poll a series of possible\n   token values, fishing for a valid token.  To prevent this, the\n   authorization server MUST require authentication of protected\n   resources that need to access the introspection endpoint and SHOULD\n   require protected resources to be specifically authorized to call the\n   introspection endpoint.  The specifics of such authentication\n   credentials are out of scope of this specification, but commonly\n   these credentials could take the form of any valid client\n   authentication mechanism used with the token endpoint, an OAuth 2.0\n   access token, or other HTTP authorization or authentication\n   mechanism.\n\nAssuming the chosen form authentication is one of the client authentication mechanisms, a public client (possibly a client made for the sole purpose of the RS retrieving token introspection responses) should not be able to get introspection responses for tokens that are not intended for it. In that same spirit, an actual public client should not be able to get introspection responses for tokens, e.g. refresh tokens, for tokens not issued for that client.\n\nThe first case (an RS registration) is most likely not going to be a public client and it would be using a method other than attest_jwt_client_auth, so no real problem there, I think.\n\nThe latter case tho, when a client is using attest_jwt_client_auth, should the AS keep track of the client instance a token was issued to and only provide introspection responses for the client instance a token was issued to? For refresh tokens this is already done, for other types of issued tokens it isn't.\n\n---\n\n**BCP 240 / RFC 9700 Best Current Practice for OAuth 2.0 Security, specifically on use of PKCE**\n**BCP 212 / RFC 8252 OAuth 2.0 for Native Apps, specifically on use of PKCE**\n\nBoth BCPs require the use of PKCE for public clients.\n\n\nhttps://www.rfc-editor.org/rfc/rfc9700.html#section-2.1.1-2.1\n\n> Public clients MUST use PKCE\n\nhttps://www.rfc-editor.org/rfc/rfc8252.html#section-6\n\n> Public native app clients MUST implement the Proof Key for Code Exchange (PKCE)\n\nBased on how these are written and how \"public\" is defined it would appear clients using attest_jwt_client_auth are technically no longer required to use PKCE. Should they still be required to?\n\n---\n\n**BCP 240 / RFC 9700 Best Current Practice for OAuth 2.0 Security, specifically on Refresh Token Rotation**\n\nhttps://www.rfc-editor.org/rfc/rfc9700.html#section-2.2.2\n\n> Refresh tokens for public clients MUST be sender-constrained or use refresh token rotation as described in [Section 4.14](https://www.rfc-editor.org/rfc/rfc9700.html#refresh_token_protection). [[RFC6749](https://www.rfc-editor.org/rfc/rfc9700.html#RFC6749)] already mandates that refresh tokens for confidential clients can only be used by the client for which they were issued.\n\nattest_jwt_client_auth (through https://www.ietf.org/archive/id/draft-ietf-oauth-attestation-based-client-auth-05.html#section-9.2) already handles this well.\n\n---\n\n**No reference, on Refresh Token Sliding Expiration**\n\nExisting Authorization Servers may offer a scheme where dormant/unused refresh tokens are pruned but when an RT is used its expiration timestamp is pushed back, this can usually be done infinitely for non-public clients but maybe only to a certain total duration for public clients.\n\nDoes use of attest_jwt_client_auth make a difference here?\n\n---\n\n**RFC 9126 - OAuth 2.0 Pushed Authorization Requests (PAR), specifically on use of unregistered redirect URIs**\n\nhttps://www.rfc-editor.org/rfc/rfc9126.html#section-2.4\n\n> The exact matching requirement MAY be relaxed when using PAR for clients that have established authentication credentials with the authorization server. This is possible since, in contrast to a conventional authorization request, the authorization server authenticates the client before the authorization process starts and thus ensures it is interacting with the legitimate client. The authorization server MAY allow such clients to specify redirect_uri values that were not previously registered with the authorization server.\n\nDoes use of attest_jwt_client_auth apply as \"clients that have established authentication credentials with the authorization server\" such that an AS may fall into this \"MAY\" clause?",
      "createdAt": "2025-05-27T20:41:58Z",
      "updatedAt": "2025-08-12T06:28:44Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 114,
      "id": "I_kwDOJaEkaM64fgIK",
      "title": "Further attest_jwt_client_auth client instance bindings",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/114",
      "state": "OPEN",
      "author": "panva",
      "authorAssociation": "MEMBER",
      "assignees": [
        "tplooker"
      ],
      "labels": [],
      "body": "When attest_jwt_client_auth is used the following OAuth 2.0 extension artefacts may also be made to be bound to the individual client instance (much like Refresh Tokens are in draft 05)\n\n- PAR endpoint -> request_uri -> authorization code -> token endpoint authorization_code grant type exchange\n- CIBA Backchannel Authentication Endpoint -> auth_req_id -> token endpoint urn:openid:params:grant-type:ciba grant type exchange\n- Device Authorization Endpoint -> device_code -> token endpoint urn:ietf:params:oauth:grant-type:device_code grant type exchange",
      "createdAt": "2025-05-27T21:23:24Z",
      "updatedAt": "2025-09-02T06:24:54Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 116,
      "id": "I_kwDOJaEkaM64nDXM",
      "title": "\"transaction\" is easily misunderstood",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/116",
      "state": "CLOSED",
      "author": "Macke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "has-pr"
      ],
      "body": "In the section about replay attack detection it states that \"The authorization server provides a nonce for the particular transaction and the client uses it for the \"nonce\" claim in the Client Attestation PoP JWT. The authorization server validates that the nonce matches for the transaction.\"  It is pretty unclear what is meant by \"transaction\" in this context.  It might be helpful to clarify the meaning of \"transaction\" in this context.  Would \"the particular OAuth2 Authorization flow\" cover it more precisely?\n\n\n\n",
      "createdAt": "2025-05-28T12:46:03Z",
      "updatedAt": "2025-07-07T06:42:12Z",
      "closedAt": "2025-07-07T06:42:12Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is addressed by #112 @Macke please review that PR and let us know if it does not.",
          "createdAt": "2025-06-04T00:21:18Z",
          "updatedAt": "2025-06-04T00:21:18Z"
        },
        {
          "author": "Macke",
          "authorAssociation": "NONE",
          "body": "That is a lot better because it is more clear about soem of the stages but I'm afraid that the \"transaction\" itself is pretty undefined.  Perhaps we could make it more specific by changing \"transaction\" to \"client authentication transaction\"?",
          "createdAt": "2025-06-04T11:20:12Z",
          "updatedAt": "2025-06-04T11:20:12Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "I_kwDOJaEkaM64nGEr",
      "title": "Editorial - what is a \"traditional OAuth2 ecosystem\"",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/117",
      "state": "CLOSED",
      "author": "Macke",
      "authorAssociation": "NONE",
      "assignees": [
        "tplooker"
      ],
      "labels": [
        "has-pr"
      ],
      "body": "Suggest more specific wording as \"traditional\" is not terribly clear.",
      "createdAt": "2025-05-28T12:49:54Z",
      "updatedAt": "2025-07-07T06:47:53Z",
      "closedAt": "2025-07-07T06:47:53Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I understand the point of view but I'm struggling to find an alternative phrase or term that describes the pre-existing security practises and mechanisms around OAuth 2.0 that pre-date this draft. Personally I feel the word \"tradition\" captures this intent well.",
          "createdAt": "2025-06-04T00:18:16Z",
          "updatedAt": "2025-06-04T00:18:16Z"
        },
        {
          "author": "Macke",
          "authorAssociation": "NONE",
          "body": "Current wording is: \"to enable usage outside of the traditional OAuth2 ecosystem.\"\n\nHaving looked at section 7 maybe we could reword to something like: \"to enable usage outside of the HTTP Based OAuth2 interactions.\"",
          "createdAt": "2025-06-04T11:16:23Z",
          "updatedAt": "2025-06-04T11:16:23Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "I_kwDOJaEkaM64nMXT",
      "title": "Client Attestation HTTP Headers",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/118",
      "state": "OPEN",
      "author": "Macke",
      "authorAssociation": "NONE",
      "assignees": [
        "c2bo"
      ],
      "labels": [
        "discuss"
      ],
      "body": "\"6.1. Client Attestation HTTP Headers \nA Client Attestation JWT and Client Attestation PoP JWT can be included in an HTTP request using the following request header fields.\"\n\nSuggest re-drafting this such that it is a normative requirement to have those headers if the two attestations are being transferred by header.\n\nperhaps:\n\n\"6.1. Client Attestation HTTP Headers \nWhen using headers to transfer the Client Attestation JWT and Client Attestation PoP JWT to an Authorization Server they MUST be provided in an HTTP request using the following HTTP headers.\"",
      "createdAt": "2025-05-28T12:58:18Z",
      "updatedAt": "2025-08-28T11:12:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Editors Call:\n- agree that a MUST for this text makes sense\n- we will iterate a little on the given text proposal",
          "createdAt": "2025-06-03T06:41:15Z",
          "updatedAt": "2025-06-03T06:41:15Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd be comfortable with us making the HTTP header syntax more clearly normative. However the suggested text is too strong as it would prevent other extension specifications which may want to convey the attestation to the AS in otherways including not as an HTTP header.",
          "createdAt": "2025-06-04T00:13:52Z",
          "updatedAt": "2025-06-04T00:13:52Z"
        },
        {
          "author": "Macke",
          "authorAssociation": "NONE",
          "body": "That sentence is only about the case in question because it starts with \"When using headers to transfer the Client Attestation JWT and Client Attestation PoP JWT...\"\n\nThis is intended to allow other cases without this normative requirement.",
          "createdAt": "2025-06-04T11:10:18Z",
          "updatedAt": "2025-06-04T11:10:18Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "I_kwDOJaEkaM64nPgq",
      "title": "Editorial - \"## Rotation of Client Instance Key\"",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/119",
      "state": "CLOSED",
      "author": "Macke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "has-pr"
      ],
      "body": "The MD does not seem to be rendering correctly for the intended heading: \"## Rotation of Client Instance Key\" ",
      "createdAt": "2025-05-28T13:01:05Z",
      "updatedAt": "2025-06-05T20:52:01Z",
      "closedAt": "2025-06-05T20:52:01Z",
      "comments": []
    },
    {
      "number": 122,
      "id": "I_kwDOJaEkaM66NJfb",
      "title": "Create section on Processing and Verification",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/122",
      "state": "CLOSED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [
        "c2bo"
      ],
      "labels": [
        "has-pr"
      ],
      "body": "We should create a small section describing the verification rules for the JWT/PoP.",
      "createdAt": "2025-06-06T08:16:16Z",
      "updatedAt": "2025-07-07T07:11:38Z",
      "closedAt": "2025-07-07T07:11:38Z",
      "comments": []
    },
    {
      "number": 123,
      "id": "I_kwDOJaEkaM66arcs",
      "title": "Similar proposal in AT Protocol: DPoP-bound private_key_jwt client authentication",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/123",
      "state": "OPEN",
      "author": "devinivy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In [AT Protocol](https://atproto.com/) we've recently published a proposal that takes a similar shape and fills similar use cases to attestation-based client authentication as described in the draft being worked on here.  It can be found here: [0010-client-assertion-backend](https://github.com/bluesky-social/proposals/tree/main/0010-client-assertion-backend).  Once the proposal is finalized, it could end up being widely adopted in the AT Protocol ecosystem, as we have many folks who want to author browser-based clients that are given the security and UX affordances of a confidential client.\n\nWe wanted to share our use case and our thinking with the hopes that we may be able to converge on something compatible with the work being done here.\n\nRather than proposing a new client authentication method, we opted to layer a small mechanism on top of the private_key_jwt method from [RFC 7523](https://datatracker.ietf.org/doc/rfc7523/).  It's quite limited:\n> [If] the `client_assertion` JWT contains a `cnf` claim using the `jkt` method (JWK Thumbprint Confirmation Method) then it MUST be validated by the AS against the public key of the request\u2019s DPoP proof.\n\nThe result is DPoP-bound client assertions, which fits neatly with existing DPoP-bound authorization flows, i.e. both authorization code and access token binding as described in [RFC 9449](https://datatracker.ietf.org/doc/rfc9449/).  We considered the need for separate client keys in the client attestation vs. the authorization flow in our proposal, as has been raised in #67 and more recently #74. We do not anticipate any practical issues with using a single PoP key and mechanism, but would be interested to continue getting to the bottom of that question.\n\nOn the flip side, we certainly see many benefits to using a single PoP mechanism across these OAuth flows.  We found the following benefits aligning on DPoP and private_key_jwt client authentication:\n - overall the specification becomes much smaller:\n   - answers questions around the nonce mechanism, as actively discussed in #101 and #110.\n   - supports authorization code binding, as discussed in #56.\n   - supports binding the PoP to the attestation used to authenticate, as discussed in #47.\n   - answers to the attack surface area when used in conjunction with DPoP-bound access tokens, as discussed in #69.\n - as a result it's more straightforward for client implementers, particularly those who already implement DPoP-bound access tokens, which we believe will continue to rise in popularity. Fewer novel PoP implementations on the client side has its security benefits too.\n\nThat's where we're currently at\u2014appreciate the consideration from this group, and the work being done on this draft.",
      "createdAt": "2025-06-07T21:29:12Z",
      "updatedAt": "2025-08-12T06:22:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "We had a long discussion about DPoP and in general what mechanism to use for nonce/challenge retrieval. The problem with only relying on DPoP is that for a part of the use-cases interested in this mechanism, the current mode of getting a fresh DPoP nonce is problematic:\n- DPoP nonces can be retrieved from an error or from any previous response\n- Triggering an error is somewhat ambiguous, the usual way is to create a valid request with an invalid/no nonce and then retrieve a fresh nonce\n- This requires a valid request which might be expensive (requires user interaction or a call to a remote system)\n\nEspecially in the context of smartphone interactions (e.g., digital wallets), interactions would often happen for the first time with a specific AS (e.g., credential issuance). In those cases, it is highly beneficial to be able to explicitly request a fresh nonce/challenge to avoid additional roundtrips or even worse user confirmation. It also feels a lot cleaner than somehow trying to create an error case.\nFrom my perspective, those are the main motivations to deviate from the DPoP model here. ",
          "createdAt": "2025-06-12T08:34:30Z",
          "updatedAt": "2025-06-12T08:34:30Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "If this is the main motivation, wouldn't it be simpler to add a small spec for a `dpop_nonce_endpoint` that returns the nonce, rather than re-inventing something essentially identical to DPoP?\n\nThis would benefit any DPoP only implementation in addition to this one.\n\nFWIW we [did feel the pain](https://github.com/bluesky-social/atproto/issues/3859) of not knowing the DPoP nonce in advance and still think this mechanism is worth pursuing.",
          "createdAt": "2025-06-14T12:02:14Z",
          "updatedAt": "2025-06-14T12:12:56Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "That is the main motivation for the nonce/challenge fetching mechanism.\n\nCompared to private_key_jwt, we have the problem that that mechanism is usually used for confidential clients. The mechanism of attestation based client authentication aims towards client that would be traditionally viewed as public clients, where the attestation contains additional information useful to the server to establish some level of trust into that client. We should imho not use private_key_jwt for such a scenario -> it makes sense to have a dedicated mechanism imho.\n\nRegarding the nonce issue when using DPoP: For OpenID4VCI, we added the possibility to retrieve a DPoP nonce via a nonce endpoint (in addition to the challenge/nonce that the endpoint is usually used for): https://openid.github.io/OpenID4VCI/openid-4-verifiable-credential-issuance-wg-draft.html#section-7.2 Would such a mode also work for you?",
          "createdAt": "2025-06-16T08:24:36Z",
          "updatedAt": "2025-06-16T08:24:36Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Even though our solutions are somewhat different, it seems that our motivations are very much aligned!\n\nThe reason we want an \"attestation\" protocol is also because we have \"public\" clients (native & single page web applications) to which we want to grant an elevated level of trust, without requiring them to implement a complex backend (BFF / TMB).\n\nFor context, the use case of ATProto is a little particular in the sense that it is essentially supporting a decentralized form of OAuth (clients and authorization providers have no pre-established relationships). This works thanks to @aaronpk's [OAuth Client ID Metadata Document](https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document). That flavor of OAuth supports both \"public\" and \"confidential\" clients. Because of the distributed & dynamic nature of the protocol, `private_key_jwt` is the authentication mechanism that makes most sense. Similarly, the ATProto spec tried to adopt the most secure recommendations from the various OAuth related BCP (such as the use of DPoP).\n\nWe are trying to keep our spec as simple as can be (e.g. we don't want to introduce another PoP mechanism), while also trying to stay as compliant as possible with existing RFCs. So we would love to be able to get behind this draft. But in its current form, that seems hard to achieve.\n\nA possible option would be to make this draft less specific, and leave more options to the implementer:\n\n- The proof of possession mechanism to use could be left out entirely (DPoP being referenced as one of the viable option). This draft would only specify that some form of PoP mechanism MUST be used. The PoP mechanism described in this draft could become its own, seperate, draft.\n\n- It's understandable that it might be desirable to keep the method to convey the attestation distinct from the client authentication mechanism. An example of reason for that is that there already exists assumptions around `\"application_type\": \"native\"` being \"public\" (like in [this section](https://datatracker.ietf.org/doc/html/rfc8252#section-8.4) of RFC 8252). That being said, an attestation **is** a form of authentication, and it feels, again, that when `private_key_jwt` *is* used, any other mechanism would feel quite redundant with it (unnecessarily increasing the complexity). Here too, it'd be nice if this draft could leave some leeway to implementations. In particular, it'd be nice if `private_key_jwt` was one of the available ways to convey the PoP key's thumbprint. Alternatively, since it seems that both our motivations for client attestation are to provide better support for \"public\" apps, this draft could introduce a dedicated [client property](https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#table-client-metadata) for this case (or maybe a new value for `application_type`), as a way to decrease the trust level that an AS would otherwise grant to a client authenticated though `private_key_jwt`.\n\n\nThe nonce retrieval method defined in https://openid.github.io/OpenID4VCI/openid-4-verifiable-credential-issuance-wg-draft.html#section-7.2 would indeed work for us, though we would not be able to adopt that full spec. Too bad there isn't an RFC *just* for the retrieval of nonces (that I know of).",
          "createdAt": "2025-06-16T12:42:36Z",
          "updatedAt": "2025-06-16T13:33:07Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "> The nonce retrieval method defined in https://openid.github.io/OpenID4VCI/openid-4-verifiable-credential-issuance-wg-draft.html#section-7.2 would indeed work for us, though we would not be able to adopt that full spec. Too bad there isn't an RFC _just_ for the retrieval of nonces (that I know of).\n\nThere was https://datatracker.ietf.org/doc/draft-demarco-nonce-endpoint/ proposed a year ago and people didn't like that since it was too generic if I recall correctly. That is part of the reason why we tried to scope the whole mechanism within this draft clearly around the intended use-case.",
          "createdAt": "2025-06-23T08:17:30Z",
          "updatedAt": "2025-06-23T08:17:30Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @c2bo , extending `private_key_jwt` spec like this looks quite far-stretched and maybe dangerous, as this becomes basically a fundamental new client authentication mechanism, it deserves it's own identifier, as it wouldn't be possible to distinguish them otherwise in the metadata. We have been thinking about how to optionally leverage DPoP for this spec, see https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/69\nIn general, I think it makes sense to discuss on a call?",
          "createdAt": "2025-06-24T06:58:46Z",
          "updatedAt": "2025-06-24T06:58:46Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "bump @matthieusieben @devinivy are you still interested in discussing this?",
          "createdAt": "2025-08-12T06:22:16Z",
          "updatedAt": "2025-08-12T06:22:16Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "I_kwDOJaEkaM68_BkT",
      "title": "Remove `exp` from the PoP",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/124",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [
        "has-pr"
      ],
      "body": "It became clear from the PR on challenge endpoint, that a mandatory `exp` in the Client-Attestation-PoP doesn't make sense any longer ",
      "createdAt": "2025-06-24T07:01:46Z",
      "updatedAt": "2025-07-07T06:44:30Z",
      "closedAt": "2025-07-07T06:44:29Z",
      "comments": []
    },
    {
      "number": 130,
      "id": "I_kwDOJaEkaM6_MsfD",
      "title": "Allow MAC as signature algorithms?",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/130",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "paulbastian"
      ],
      "labels": [],
      "body": "Currently, MACs are not allowed. There is work on asymmetric-derived MACs, e.g. ECDH-KDF-MAC which would be disallowed by this constraint.",
      "createdAt": "2025-07-07T06:56:13Z",
      "updatedAt": "2025-08-28T11:11:34Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 131,
      "id": "I_kwDOJaEkaM6_p6sA",
      "title": "Dedicated error code for missing client attestation",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/131",
      "state": "CLOSED",
      "author": "mickrau",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "has-pr"
      ],
      "body": "In the current version of the spec, a server should use error code `use_attestation_challenge`, when client attestation is absent, even when no challenge is expected. This is misleading..\n\n> An error parameter according to Section 3 of [[RFC6750](https://www.ietf.org/archive/id/draft-ietf-oauth-attestation-based-client-auth-06.html#RFC6750)] SHOULD be included to indicate why a request was declined. If the Client Attestation is absent or not using an expected server-provided challenge, the value use_attestation_challenge can be used to indicate that an attestation with a server-provided challenge was expected. If the attestation and proof of possession was present but could not be successfully verified, the value invalid_client_attestation is used.\n\nI suggest defining a third error code:\n\n`missing_client_attestation` (new), when expected client atttestation is absent\n`use_attestation_challenge` (already defined), when attestation is present but without challenge\n`invalid_client_attestation` (already defined), when attestation is present but invalid (other than missing challenge)",
      "createdAt": "2025-07-09T10:34:05Z",
      "updatedAt": "2025-08-12T06:14:03Z",
      "closedAt": "2025-08-12T06:14:03Z",
      "comments": [
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "> missing_client_attestation (new), when expected client atttestation is absent\n\nThat would be akin to just `invalid_client`. I don't agree we want a `missing_client_attestation` error defined just to tell the client it forgot to use its assigned client auth method.",
          "createdAt": "2025-07-09T13:02:26Z",
          "updatedAt": "2025-07-09T13:02:26Z"
        },
        {
          "author": "mickrau",
          "authorAssociation": "NONE",
          "body": "I had this option also in mind. After your words, i agree that this would be the better solution especially when supporting multiple client auth methods.",
          "createdAt": "2025-07-09T16:35:43Z",
          "updatedAt": "2025-07-09T16:35:43Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "Then I don't believe there's anything to do here as all the scaffolding is already present in RFC6749",
          "createdAt": "2025-07-09T18:09:20Z",
          "updatedAt": "2025-07-09T18:09:20Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "The text currently suggests that if current attestation is absent, that 'use_attestation_nonce' should be used, which seems not correct?",
          "createdAt": "2025-07-09T18:16:09Z",
          "updatedAt": "2025-07-09T18:16:09Z"
        },
        {
          "author": "mickrau",
          "authorAssociation": "NONE",
          "body": "Yes, I think \"absent or\" should be deleted in the following part\n\n> An error parameter according to Section 3 of [[RFC6750](https://www.ietf.org/archive/id/draft-ietf-oauth-attestation-based-client-auth-06.html#RFC6750)] SHOULD be included to indicate why a request was declined. If the Client Attestation is ~~absent or~~ not using an expected server-provided challenge, the value use_attestation_challenge can be used to indicate that an attestation with a server-provided challenge was expected. If the attestation and proof of possession was present but could not be successfully verified, the value invalid_client_attestation is used.",
          "createdAt": "2025-07-09T18:17:44Z",
          "updatedAt": "2025-07-09T18:17:44Z"
        }
      ]
    },
    {
      "number": 133,
      "id": "I_kwDOJaEkaM7AQj-j",
      "title": "pop iat should now be required",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/133",
      "state": "CLOSED",
      "author": "panva",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "has-pr"
      ],
      "body": "With exp removed from the pop and challenge being optional it would be prudent to require iat to allow the AS to enforce one time use within a certain window whilst having a timestamp reference in the pop token. ",
      "createdAt": "2025-07-12T16:42:57Z",
      "updatedAt": "2025-07-16T06:27:12Z",
      "closedAt": "2025-07-16T06:27:12Z",
      "comments": []
    },
    {
      "number": 137,
      "id": "I_kwDOJaEkaM7EROI6",
      "title": "Merge PAR & token endpoint sections?",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/137",
      "state": "OPEN",
      "author": "jogu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The way the current spec has two sections:\n\n> Client Attestation at the Token Endpoint\n\nand:\n\n> Client Attestation at the PAR Endpoint\n\nis a bit weird.\n\nThe text from the token endpoint section:\n\n> If the token request contains a client_id parameter as per [[RFC6749](https://drafts.oauth.net/draft-ietf-oauth-attestation-based-client-auth/draft-ietf-oauth-attestation-based-client-auth.html#RFC6749)] the Authorization Server MUST verify that the value of this parameter is the same as the client_id value in the sub claim of the Client Attestation and iss claim of the Client Attestation PoP.[\u00b6](https://drafts.oauth.net/draft-ietf-oauth-attestation-based-client-auth/draft-ietf-oauth-attestation-based-client-auth.html#section-6.3-3)\n\nseems equally applicable to the PAR endpoint, but that text isn't in the PAR endpoint section nor referenced from it. That text also seems applicable to any endpoint that's using OAuth Client Authentication (e.g. revocation endpoint).\n\nI'd suggest merging the two section, titling them \"Client Attestation as OAuth Client Authentication\" (or something like that), and having the above text plus token endpoint & PAR endpoint examples in that section.\n",
      "createdAt": "2025-08-05T12:04:24Z",
      "updatedAt": "2025-08-12T06:21:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "We may use PAR as a subsection of Token Endpoint section.",
          "createdAt": "2025-08-12T06:21:23Z",
          "updatedAt": "2025-08-12T06:21:23Z"
        }
      ]
    },
    {
      "number": 139,
      "id": "I_kwDOJaEkaM7FdKMy",
      "title": "Clarify IANA Registration for headers",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/139",
      "state": "OPEN",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> How should the Structured Types field be filled in for the new HTTP Field Names registrations (or should it be left empty)?",
      "createdAt": "2025-08-12T06:37:35Z",
      "updatedAt": "2025-08-12T06:37:35Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 140,
      "id": "I_kwDOJaEkaM7IDQ1-",
      "title": "Feedback from mailing list",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/140",
      "state": "OPEN",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "\nFrom https://mailarchive.ietf.org/arch/msg/oauth/ug41q9ykI3we5HKWsvlA6euvMWc/\n \n> - General: why is the document marked Informational? Looks very much like a Proposed Standard to me!\n>   1. Introduction (and even the Abstract): I think it is problematic to refer to this method as \"client authentication\". Even if a specific key is asserted, and even if the client can assert a \"sub\" value, this is not \"authentication\" unless these values are shown to correspond to a managed client identity - where each client instance has a unique identity and where some other management system can enumerate the identities of all valid clients. With the current solution each client instance may have identity X today and identity Y tomorrow.\n> - This (IMHO) misconception is repeated in text such as \"the Client instance generates a key... to prove its authenticity\".\n> - To use a term from the Privacy space: what we have here is a pseudonymous client Instance: it is NOT fully authenticated, but:\n> - If the same Instance Key is used multiple times, we know that it belongs to the same client instance (assuming no colluding client instances).\n> - One client instance may be associated with multiple instance keys.\n> - There is no mapping of an Instance Key to any predefined (\"managed\") entity.\n> - General: the document is targeted at a public deployment, where we want to minimize the information conveyed to the AS. It's not a great fit to other use cases (closed environments, Confidential Computing etc.) where we might want the AS to know what kind of attestation took place and use it in its policy. To support such use cases we might have to extend the Client Attestation JWT to include additional information. I propose it more as food for thought rather than an actionable change.\n> - 5.1: Typo: iss (subject) claim.\n> - sub and client_id: there is nothing here to require uniqueness of client_id or that it is known by the AS - going back to my comments about authentication above.\n> - And shouldn't we define a MTI signing algorithm (e.g. ES256 used here)? I know it's not a very popular thing around here, but it's required for interoperability.\n> - The examples in Sec. 5 both use https://client.example.com/ for the client ID, which is not very typical of a mobile client that usually doesn't have its own DNS address.\n> - The following rule makes the processing of the Attestation PoP non-deterministic: \"Note that the authorization server may reject JWTs with an \"iat\" claim value that is unreasonably far in the past.\" Since we don't want PoPs to be reused, why not say that they MUST be fresh?\n> - 6.1: why define the syntax as \"token68\" which is a strict superset of the real syntax (base64url plus \".\")?\n> - 6.2: in the section title, did you mean \"featuring\" instead of \"feature\"?\n> - 6.4: shouldn't we correlate the client_id value, just as in sec. 6.3?\n> - 8.1: there are two challenge mechanisms defined, but not how they interplay. The most extreme example is a \"OAuth-Client-Attestation-Challenge\" included in the response to \"POST /as/challenge\". A more sane example is a client that doesn't want to cache challenges indefinitely and prefers to use the challenge endpoint even though it had received (maybe days ago) a challenge in a header.\n> - 10.2: \"MUST bind the refresh token to the Client Instance, and NOT just the client\" - the text is not terribly clear. Maybe say \"to the Client Instance and its associated public key\".\n> - 10.4: and upon key rotation, the client must invalidate its refresh token?\n> - Both sec. 12.1 and 10.5 cover the same ground, and I suspect that sec. 10.5 can be removed.\n> - 13: remove \"Appendix A\" from the section title.\n> - 13.3: the document does not define anywhere how this works in DCR.\n",
      "createdAt": "2025-08-26T16:12:14Z",
      "updatedAt": "2025-09-03T14:40:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": ">         General: why is the document marked Informational? Looks very much like a Proposed Standard to me!\nagree, opened #143\n\n>             Introduction (and even the Abstract): I think it is problematic to refer to this method as \"client authentication\". Even if a specific key is asserted, and even if the client can assert a \"sub\" value, this is not \"authentication\" unless these values are shown to correspond to a managed client identity - where each client instance has a unique identity and where some other management system can enumerate the identities of all valid clients. With the current solution each client instance may have identity X today and identity Y tomorrow.\n>         This (IMHO) misconception is repeated in text such as \"the Client instance generates a key... to prove its authenticity\".\n>         To use a term from the Privacy space: what we have here is a pseudonymous client Instance: it is NOT fully authenticated, but:\n>         If the same Instance Key is used multiple times, we know that it belongs to the same client instance (assuming no colluding client instances).\n>         One client instance may be associated with multiple instance keys.\n>         There is no mapping of an Instance Key to any predefined (\"managed\") entity.\n>         General: the document is targeted at a public deployment, where we want to minimize the information conveyed to the AS. It's not a great fit to other use cases (closed environments, Confidential Computing etc.) where we might want the AS to know what kind of attestation took place and use it in its policy. To support such use cases we might have to extend the Client Attestation JWT to include additional information. I propose it more as food for thought rather than an actionable change.\nall of this relates to discussions of #113 and #79 \n\n>         5.1: Typo: iss (subject) claim.\nfixed\n\n>         sub and client_id: there is nothing here to require uniqueness of client_id or that it is known by the AS - going back to my comments about authentication above.\nall of this relates to discussions of #113 and #79 \n\n>         And shouldn't we define a MTI signing algorithm (e.g. ES256 used here)? I know it's not a very popular thing around here, but it's required for interoperability.\nI guess its not popular in OAuth community, tendency to define this in a profile using this draft\n\n>         The examples in Sec. 5 both use https://client.example.com/ for the client ID, which is not very typical of a mobile client that usually doesn't have its own DNS address.\nwe expect most mobile apps to bring a backend that would do this\n\n>         The following rule makes the processing of the Attestation PoP non-deterministic: \"Note that the authorization server may reject JWTs with an \"iat\" claim value that is unreasonably far in the past.\" Since we don't want PoPs to be reused, why not say that they MUST be fresh?\ngood intention, we should discuss this\n\n>         6.1: why define the syntax as \"token68\" which is a strict superset of the real syntax (base64url plus \".\")?\nAgreed, as both are JWTs and the concatenated form of Section 7 does not apply, we could be sufficient with JWT ABNF\n\n>         6.2: in the section title, did you mean \"featuring\" instead of \"feature\"?\nfixed\n\n>         6.4: shouldn't we correlate the client_id value, just as in sec. 6.3?\nagree, opened #144\n\n>         8.1: there are two challenge mechanisms defined, but not how they interplay. The most extreme example is a \"OAuth-Client-Attestation-Challenge\" included in the response to \"POST /as/challenge\". A more sane example is a client that doesn't want to cache challenges indefinitely and prefers to use the challenge endpoint even though it had received (maybe days ago) a challenge in a header.\nAgreed, we should add a sentence like \"The client MUST use the most recent challenge received.\"?\nAlso, could we simplify the challenge endpoint by returning it as the HTTP OAuth-Client-Attestation-Challenge header? Then is may ease implementation?\n\n>         10.2: \"MUST bind the refresh token to the Client Instance, and NOT just the client\" - the text is not terribly clear. Maybe say \"to the Client Instance and its associated public key\".\nagreed, opened #145\n\n>         10.4: and upon key rotation, the client must invalidate its refresh token?\nThat's clear enough for me. Section 10.4 also does not say that the previous Client Instance Key is invalidated, the client may maintain two keys.\n\n>         Both sec. 12.1 and 10.5 cover the same ground, and I suspect that sec. 10.5 can be removed.\nThat was on purpose, as the security consideration explains the security impact and its motivation, while the implementation consideration captures the possible options how to implement this. Is this separation very uncommon?\n\n>         13: remove \"Appendix A\" from the section title.\nagreed, fixed in #145\n\n>         13.3: the document does not define anywhere how this works in DCR.\nwe have #61 on this already\n",
          "createdAt": "2025-09-03T14:40:36Z",
          "updatedAt": "2025-09-03T14:40:36Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOJaEkaM5P0e5x",
      "title": "Various editorial updates",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/1",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The following changes are encapsulated in this PR:\r\n\r\n- Update references from RFC7523 to RFC7521.\r\n- Added a recommendation around order of validation for the two JWTs in the client_assertion parameter.\r\n- Removed the note from the exp and iat claims for the client key Attestation JWT that imply this cannot be re-used across multiple requests.\r\n- Removed the ability to use MAC based algorithms when producing the client key Attestation JWT.\r\n- Updated the requirements around the presence of the JTI claim for the client key attestation PoP to be a MUST inline with DPoP PoPs for reliable basic replay attack detection mechanism.\r\n- Added references to the JWT RFC.\r\n- Added an implementation consideration that highlights a client instance can re-use a client key attestation JWT in multiple AS interactions/requests.\r\n- Added aud as a required claim in the client attestation pop JWT.\r\n- Add IANA registration request for the new client assertion type and token endpoint authentication method.",
      "createdAt": "2023-05-04T22:52:22Z",
      "updatedAt": "2023-05-07T20:13:02Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "f84b4b49034eca55f9546d11bbbe0a8657b00b86",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/editorial-updates",
      "headRefOid": "5e5a37dd4f2f5acbc11cb543a517d35a35ce49e0",
      "closedAt": "2023-05-07T20:13:02Z",
      "mergedAt": "2023-05-07T20:13:02Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "fcfa55cd1a986edd8c6438b6eee72aeeeea1e91e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOJaEkaM5QCK17",
      "title": "Add refresh token binding implementation consideration and update broken links",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/2",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed over email, this PR drafts some text to capture the requirement around refresh token binding to the client instance not just the client. The PR also addresses some broken links.\r\n\r\nPersonally I'm still not convinced that the best way to do this binding is through the client attestation key, instead I think we could add a claim that identifies the client instance in the client key attestation",
      "createdAt": "2023-05-08T20:25:40Z",
      "updatedAt": "2023-05-11T19:18:01Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "fcfa55cd1a986edd8c6438b6eee72aeeeea1e91e",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/editorial-updates",
      "headRefOid": "525896663b6a46b83e5bba8a3902076add25569c",
      "closedAt": "2023-05-11T19:17:49Z",
      "mergedAt": "2023-05-11T19:17:49Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "a9c23810d7ebbe6131fc9dd944aecae0d0d9267d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5UqJWv",
          "commit": {
            "abbreviatedOid": "e9cb956"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "few suggestions",
          "createdAt": "2023-05-10T10:39:22Z",
          "updatedAt": "2023-05-10T10:40:33Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "```suggestion\r\n# The OAuth 2.0 Attested Key Based Client Authentication\r\n```",
              "createdAt": "2023-05-10T10:39:22Z",
              "updatedAt": "2023-05-10T10:40:33Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThis is the working area for the individual Internet-Draft, \"The OAuth 2.0 Attested Key Based Client Authentication\".\r\n```",
              "createdAt": "2023-05-10T10:39:34Z",
              "updatedAt": "2023-05-10T10:40:33Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nAuthorization servers issuing a refresh token in response to a token request using the \"urn:ietf:params:oauth:client-assertion-type:jwt-key-attestation\" client authentication method MUST bind the refresh token to the client instance, and NOT just the client as specified in section 6 [@!RFC6749]. To prove this binding, the client instance MUST authenticate itself to the authorization server when refreshing an access token using the \"urn:ietf:params:oauth:client-assertion-type:jwt-key-attestation\" authentication method. The client MUST also use the same client attestation key that was used for authentication when the refresh token was issued.\r\n```",
              "createdAt": "2023-05-10T10:40:25Z",
              "updatedAt": "2023-05-10T10:40:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5UtDqu",
          "commit": {
            "abbreviatedOid": "e9cb956"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-10T17:26:36Z",
          "updatedAt": "2023-05-10T17:26:36Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Don't think we want an article here \"The\" as a start of the title. Also 2.0 is problematic in a world where 2.1 will soon be a thing.",
              "createdAt": "2023-05-10T17:26:36Z",
              "updatedAt": "2023-05-10T17:26:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5UtDtb",
          "commit": {
            "abbreviatedOid": "e9cb956"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-10T17:26:43Z",
          "updatedAt": "2023-05-10T17:26:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "As above",
              "createdAt": "2023-05-10T17:26:43Z",
              "updatedAt": "2023-05-10T17:26:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOJaEkaM5Ql_Wl",
      "title": "Add privacy consideration around client instance tracking",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/5",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As highlighted in the title this PR adds a privacy consideration around potential client instance tracking along with a recommendation for client deployments to mitigate such risk.",
      "createdAt": "2023-05-16T09:17:09Z",
      "updatedAt": "2023-05-17T06:46:06Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "a9c23810d7ebbe6131fc9dd944aecae0d0d9267d",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/client-instance-tracking",
      "headRefOid": "1d0783734cbc31749dbe529159351dddefa679e7",
      "closedAt": "2023-05-17T06:38:14Z",
      "mergedAt": "2023-05-17T06:38:14Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "071f2a30565a4428394ab157325fffd212a47277"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5VJsLR",
          "commit": {
            "abbreviatedOid": "2390ceb"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T13:35:52Z",
          "updatedAt": "2023-05-16T13:35:52Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nImplementers should be aware that using the same client attestation across multiple authorization servers could result in correlation of the end user using the client instance through claim values (including the public key in the `cnf` claim). Client deployments are therefore RECOMMENDED to use different client attestations across different authorization servers.\r\n```",
              "createdAt": "2023-05-16T13:35:52Z",
              "updatedAt": "2023-05-16T13:35:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5VOrvQ",
          "commit": {
            "abbreviatedOid": "1d07837"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-17T06:33:55Z",
          "updatedAt": "2023-05-17T06:33:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "PR_kwDOJaEkaM5RCLU9",
      "title": "Introduction Text + Renaming Client Key Attestation to Client Attestation",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/11",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-22T16:08:04Z",
      "updatedAt": "2023-06-13T19:46:10Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "071f2a30565a4428394ab157325fffd212a47277",
      "headRepository": "paulbastian/draft-looker-oauth-attested-key-based-client-authentication",
      "headRefName": "main",
      "headRefOid": "8825f3f2ea5483d053892c8da6b23e5c3ad8acec",
      "closedAt": "2023-06-13T19:46:10Z",
      "mergedAt": "2023-06-13T19:46:10Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "0d942cf0688ed99afccfb16c850bb5ff7b62bfc3"
      },
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please change file/draft name and title, too. ",
          "createdAt": "2023-05-23T07:33:18Z",
          "updatedAt": "2023-05-23T07:43:03Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "> \r\n> I also perceive this draft as a PoP version of urn:ietf:params:oauth:grant-type:jwt-bearer, would it make sense to make that more intuitive and explicit - like urn:ietf:params:oauth:grant-type:jwt-pop? - this can be another issue\r\n\r\nOpened as a separate issue.",
          "createdAt": "2023-06-05T09:04:28Z",
          "updatedAt": "2023-06-05T09:04:28Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "> a new paragraph in intro sectionis great but hard to follow, suggest to break it down into steps and put under the diagram.\r\n\r\n@Sakurann please check my latest suggestion\r\n",
          "createdAt": "2023-06-05T09:32:55Z",
          "updatedAt": "2023-06-05T09:32:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5VwwSj",
          "commit": {
            "abbreviatedOid": "2208c9a"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-05-23T07:25:58Z",
          "updatedAt": "2023-05-23T07:32:48Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n{{RFC7521}} defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification extends this mechanism to provide a way for a client instance to authenticate itself with the authorization server through an assertion that is sender-constrained with a public key, i.e. the client must present the assertion along with a proof of possession for that public key. \r\n```",
              "createdAt": "2023-05-23T07:25:58Z",
              "updatedAt": "2023-05-23T07:32:48Z"
            },
            {
              "originalPosition": 14,
              "body": "what is an \"attestation scheme\"?",
              "createdAt": "2023-05-23T07:26:18Z",
              "updatedAt": "2023-05-23T07:32:48Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThe Authorization Server will communicate its requirements for the attestation scheme through its metadata. A Client instance that wants to request an access token from this Authorization Server will need to obtain a Client Attestation JWT from its client backend first. Therefore the client will generate an ephemeral key (Client Instance Key) and (platform specific) attestations to proof its genuinity and security to the client backend. The Client instance sends this data to the client backend in request for a Client Attestation JWT. If the Client Backend successfully validates the Client Instance Key and further data, it will generate a signed Client Attestation JWT. As the Client Attestation JWT is cryptographically bound to the Client Instance Key generated by the client, the attestation is bound to this particular client instance. The client backend will respond to the client's request by sending the Client Attestation JWT. The client can proceed and generate a Client Attestation Proof of Possession (PoP) for the Client Instance Key. Lastly, the client sends both the Client Attestation JWT and the Client Attestation PoP with the Token Request to the Authorization Server. The Authorization Server will validate the client attestation and thus authenticates the client. The Authorization Server may continue to issue sender-constrained access tokens using DPoP.\r\n```",
              "createdAt": "2023-05-23T07:29:18Z",
              "updatedAt": "2023-05-23T07:32:48Z"
            },
            {
              "originalPosition": 71,
              "body": "```suggestion\r\n   A JSON Web Token (JWT) generated by the client backend that authenticates the client instance.\r\n```",
              "createdAt": "2023-05-23T07:30:10Z",
              "updatedAt": "2023-05-23T07:32:49Z"
            },
            {
              "originalPosition": 141,
              "body": "Why not just use the same client attestation JWT? That would not require any client instance identification and is also not a privacy issue. \r\n\r\nurn:ietf:params:oauth:client-assertion-type:jwt-key-attestation -> urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation",
              "createdAt": "2023-05-23T07:32:42Z",
              "updatedAt": "2023-05-23T07:32:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WH6z9",
          "commit": {
            "abbreviatedOid": "2208c9a"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T03:05:32Z",
          "updatedAt": "2023-05-26T03:05:33Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "This text feels a bit more complex to me? I think the previous text was a bit clearer in this explanation?",
              "createdAt": "2023-05-26T03:05:32Z",
              "updatedAt": "2023-05-26T03:05:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WH69M",
          "commit": {
            "abbreviatedOid": "2208c9a"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T03:06:41Z",
          "updatedAt": "2023-05-26T03:06:42Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "schema is a bit of a loaded word here I think the JWT processing section already makes it clear AS and clients are permitted to add what ever else they wish to the JWTs\r\n```suggestion\r\nThis specification only defines the format of the Client Assertion JWT that a client instance uses to authenticate in its interactions with an authorization server (indicated in step 6), which is comprised of two key parts:\r\n```",
              "createdAt": "2023-05-26T03:06:41Z",
              "updatedAt": "2023-05-26T03:06:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WH7AZ",
          "commit": {
            "abbreviatedOid": "2208c9a"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T03:07:07Z",
          "updatedAt": "2023-05-26T03:07:07Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\n1. A client attestation JSON Web Token (JWT)- produced by the client backend.\r\n```",
              "createdAt": "2023-05-26T03:07:07Z",
              "updatedAt": "2023-05-26T03:07:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WNC7X",
          "commit": {
            "abbreviatedOid": "2208c9a"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T13:40:30Z",
          "updatedAt": "2023-05-26T13:40:30Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "A well know data structure that defines the data an attestation should, shall or may, contain\r\n\r\nShould It be a defined term?\r\n",
              "createdAt": "2023-05-26T13:40:30Z",
              "updatedAt": "2023-05-26T13:40:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Wf73e",
          "commit": {
            "abbreviatedOid": "346ebf2"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-05-30T15:14:03Z",
          "updatedAt": "2023-05-30T15:28:17Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "yes",
              "createdAt": "2023-05-30T15:14:03Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nNote: the protocols for obtaining Client Attestation JWTs (steps 2 and 4) is out of scope of this specification.\r\n```",
              "createdAt": "2023-05-30T15:17:05Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\n1. A client attestation JWT - produced by the client backend.\r\n```",
              "createdAt": "2023-05-30T15:17:43Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 141,
              "body": "```suggestion\r\nAuthorization servers issuing a refresh token in response to a token request using the \"urn:ietf:params:oauth:client-assertion-type:jwt-key-attestation\" client authentication method MUST bind the refresh token to the client instance, and NOT just the client as specified in section 6 [@!RFC6749]. To prove this binding, the client instance MUST authenticate itself to the authorization server when refreshing an access token using the \"urn:ietf:params:oauth:client-assertion-type:jwt-key-attestation\" authentication method. The client MUST also use the same Client Attestation that was used for authentication when the refresh token was issued.\r\n```",
              "createdAt": "2023-05-30T15:18:35Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThis specification defines a new method of client authentication for OAuth 2.0 {{RFC6749}} by extending the approach defined in {{RFC7521}}. This new method enables client deployments that are traditionally viewed as public clients to be able to authenticate with the authorization server through an attestation based authentication scheme.\r\n```",
              "createdAt": "2023-05-30T15:19:28Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n{{RFC7521}} defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification extends this mechanism to provide a way for a client instance to authenticate itself with the authorization server through an assertion that is bound to a public key (for proof of possession). This assertion is designated as Client Attestation.\r\n```",
              "createdAt": "2023-05-30T15:19:47Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThe Authorization Server will communicate its requirements for the client attestation through its metadata. A Client instance that wants to request an access token from this Authorization Server will need to obtain a Client Attestation JWT from its client backend first. Therefore the client will provide attestations to proof its genuineness and security (typically obtained from the platform) along with a fresh Client Instance Key to its backend. If the Client Backend successfully validates the attestation data and the proof of possession of the Client Instance Key, it will generate a signed Client Attestation JWT that is bound to the client instance key. As the Client Attestation JWT is cryptographically bound to the Client Instance Key generated by the client, the attestation is bound to this specific client instance. The client backend will respond to the client's request with this Client Attestation JWT. The client can proceed and generate a Client Attestation Proof of Possession (PoP) for the Client Instance Key. Lastly, the client sends both the Client Attestation JWT and the Client Attestation PoP with the Token Request to the Authorization Server. The Authorization Server will validate the client attestation and thus authenticates the client instance. The Authorization Server may continue to issue sender-constrained access tokens using DPoP.\r\n```",
              "createdAt": "2023-05-30T15:25:54Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WdJUe",
          "commit": {
            "abbreviatedOid": "4c0617b"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T09:10:44Z",
          "updatedAt": "2023-05-30T16:17:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Why is the Client Instance Key ephemeral? Is there an agreement that this key shall not be reused?",
              "createdAt": "2023-05-30T09:10:44Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            },
            {
              "originalPosition": 141,
              "body": "opened as separate issue",
              "createdAt": "2023-05-30T09:15:30Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            },
            {
              "originalPosition": 54,
              "body": "just wanted to clarify that its about protocols and data formats",
              "createdAt": "2023-05-30T15:01:41Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            },
            {
              "originalPosition": 14,
              "body": "@tlodderstedt Do you prefer schema?",
              "createdAt": "2023-05-30T15:03:43Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            },
            {
              "originalPosition": 54,
              "body": "outdated change",
              "createdAt": "2023-05-30T15:59:10Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            },
            {
              "originalPosition": 12,
              "body": "outdated, but approved the change in my commit",
              "createdAt": "2023-05-30T16:01:00Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Wgpyx",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-30T16:51:23Z",
          "updatedAt": "2023-05-30T16:51:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5Whmik",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T19:11:37Z",
          "updatedAt": "2023-05-30T19:11:38Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n{{RFC7521}} defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification extends this assertion to be bound to a public key for proof of possession. This assertion is designated as Client Attestation.\r\n```",
              "createdAt": "2023-05-30T19:11:37Z",
              "updatedAt": "2023-05-30T19:11:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Who6-",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T19:18:46Z",
          "updatedAt": "2023-05-30T19:18:47Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThe Authorization Server will communicate its requirements for the attestation scheme through its metadata. A Client instance that wants to request an access token from this Authorization Server will need to obtain a Client Attestation JWT, for example, from its client backend first. Therefore, the client will generate a key (Client Instance Key) and (platform specific) attestations to prove its authenticity and security to the client backend. The Client instance sends this data to the client backend in request for a Client Attestation JWT. If the Client Backend successfully validates the Client Instance Key and further data, it will generate a signed Client Attestation JWT. As the Client Attestation JWT is cryptographically bound to the Client Instance Key generated by the client, the attestation is bound to this particular client instance. The client backend will respond to the client's request by sending the Client Attestation JWT. The client can proceed and generate a Client Attestation Proof of Possession (PoP) for the Client Instance Key. Lastly, the client sends both the Client Attestation JWT and the Client Attestation PoP with the Token Request to the Authorization Server. The Authorization Server will validate the client attestation and thus authenticates the client. The Authorization Server may continue to issue sender-constrained access tokens using {{oauth-dpop-16}}.\r\n```\r\n\r\nwhat is `(platform specific) attestation` ?\r\nplease be consistent, capitalize `Client` everywhere or not capitalize it.\r\nthe explanation is pretty long. I would suggest to put a short summary before the diagram but break down this paragraph into the steps and put them under the diagram.",
              "createdAt": "2023-05-30T19:18:46Z",
              "updatedAt": "2023-05-30T19:18:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Whpcu",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T19:20:07Z",
          "updatedAt": "2023-05-30T19:20:07Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "```suggestion\r\n   A cryptographic, asymmetric key generated by the client instance and proven to the client backend. The public key is contained in the Client Attestation JWT and is used to sign the Client Attestation Proof of Possession.\r\n```",
              "createdAt": "2023-05-30T19:20:07Z",
              "updatedAt": "2023-05-30T19:20:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WhrvT",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T19:24:48Z",
          "updatedAt": "2023-05-30T19:24:49Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "I perceive this draft as a PoP version of `urn:ietf:params:oauth:grant-type:jwt-bearer`, would it make sense to make that more intuitive and explicit - like `urn:ietf:params:oauth:grant-type:jwt-pop`?",
              "createdAt": "2023-05-30T19:24:48Z",
              "updatedAt": "2023-05-30T19:24:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Whr_p",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T19:25:31Z",
          "updatedAt": "2023-05-30T19:25:31Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "```suggestion\r\nThe following rules apply to validating the Client Attestation JWT. Application of additional restrictions and policy are at the discretion of the Authorization Server.\r\n```\r\nClient Attestation JWT or Client Attestation PoP JWT?\r\nalso capitalization - please be consistent...",
              "createdAt": "2023-05-30T19:25:31Z",
              "updatedAt": "2023-05-30T19:25:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WhuCq",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "a new paragraph in intro sectionis great but hard to follow, suggest to break it down into steps and put under the diagram.\r\n\r\nI also perceive this draft as a PoP version of urn:ietf:params:oauth:grant-type:jwt-bearer, would it make sense to make that more intuitive and explicit - like urn:ietf:params:oauth:grant-type:jwt-pop? - this can be another issue",
          "createdAt": "2023-05-30T19:30:39Z",
          "updatedAt": "2023-05-30T19:30:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5WiY_v",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:35:53Z",
          "updatedAt": "2023-05-30T21:35:53Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Just noting that given we now have OAuth 2.1 saying this is for OAuth 2.0 might give the wrong compatibility impression?",
              "createdAt": "2023-05-30T21:35:53Z",
              "updatedAt": "2023-05-30T21:35:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WiZdE",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:37:44Z",
          "updatedAt": "2023-05-30T21:37:45Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n{{RFC7521}} defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification uses this framework to define a new assertion type that provides a way for a client instance to authenticate itself with the authorization server through an assertion that is bound to a public key (for proof of possession). This assertion is designated with the name of Client Attestation in this draft.\r\n```",
              "createdAt": "2023-05-30T21:37:45Z",
              "updatedAt": "2023-05-30T21:37:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WiZhJ",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:37:56Z",
          "updatedAt": "2023-05-30T21:37:57Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@tlodderstedt originally made this change",
              "createdAt": "2023-05-30T21:37:56Z",
              "updatedAt": "2023-05-30T21:37:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WiZxZ",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:38:57Z",
          "updatedAt": "2023-05-30T21:38:58Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Kind of conflicts with @Sakurann review, we don't extend the assertion we extend the framework or mechanism defined by RFC 7521.",
              "createdAt": "2023-05-30T21:38:57Z",
              "updatedAt": "2023-05-30T21:38:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WiaUS",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:41:08Z",
          "updatedAt": "2023-05-30T21:41:08Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Communication of this requirement may be communicated via metadata I dont think that is the only way though and would prefer we dont imply this. I'd also prefer we dont talk much about how the attestation is obtained by the client instance, much of this paragraph to me is informational and might set the wrong tone for the draft in terms of prescribing a solution.",
              "createdAt": "2023-05-30T21:41:08Z",
              "updatedAt": "2023-05-30T21:41:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Wiaxg",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:42:58Z",
          "updatedAt": "2023-05-30T21:42:58Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Client Attestation JWT is from the terminology, so I capitalize it, other occurences are not in the Terminology (yet), so therefore not capitalized, that should be consistent for now",
              "createdAt": "2023-05-30T21:42:58Z",
              "updatedAt": "2023-05-30T21:42:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WibEh",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:44:12Z",
          "updatedAt": "2023-05-30T21:44:13Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Still prefer the previous language to be honest, data exchanged is a part of the protocol IMO and its one protocol not multiple hence protocol instead of protocols. The diagram also already describes what is happening so the \"request and sending a client attestation JWT\" feels redundant.  ",
              "createdAt": "2023-05-30T21:44:13Z",
              "updatedAt": "2023-05-30T21:44:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Wibc-",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:45:41Z",
          "updatedAt": "2023-05-30T21:45:42Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Im not against this but I think it makes it less clear how it relates to the terminology we have established in the draft e.g this means the type would be ^ but the name of is client attestation?",
              "createdAt": "2023-05-30T21:45:41Z",
              "updatedAt": "2023-05-30T21:45:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WjLPB",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-31T01:19:24Z",
          "updatedAt": "2023-05-31T01:19:25Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "we don't have OAuth 2.1 yet, it's a draft. But I would be fine with just \"OAuth\" (with the existing reference to RFC 6749",
              "createdAt": "2023-05-31T01:19:25Z",
              "updatedAt": "2023-05-31T01:19:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WvdSt",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-01T11:53:46Z",
          "updatedAt": "2023-06-01T11:53:46Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I agree with @tplooker and like the emphasis on client instance",
              "createdAt": "2023-06-01T11:53:46Z",
              "updatedAt": "2023-06-01T11:53:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XJS5l",
          "commit": {
            "abbreviatedOid": "1d893d1"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T08:55:36Z",
          "updatedAt": "2023-06-05T08:55:37Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "I agree with @tplooker , as that could lead to confusion. But no hard feelings here",
              "createdAt": "2023-06-05T08:55:36Z",
              "updatedAt": "2023-06-05T08:55:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XKsZi",
          "commit": {
            "abbreviatedOid": "6ac2b5c"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-06-05T12:28:16Z",
          "updatedAt": "2023-06-05T12:35:57Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "does the status of \"public clients\" be applied also in this case?\r\n\r\nI've the perception that in our use cases whatever are the statuses of the clients is not relevant to this draft",
              "createdAt": "2023-06-05T12:28:16Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            },
            {
              "originalPosition": 53,
              "body": "I'd write using present, removing \"will\"\r\n\r\nWDYT about\r\n\r\n`The flow starts with the AS communicating its requirements for the client authentication to the client, made available in its metadata.`\r\n\r\nHaving said \"the AS\" that would be the same for the Client as well, thus\r\n\r\n`The Client instance makes available its Client Attestation JWS to the AS where an access token is requested`",
              "createdAt": "2023-06-05T12:33:18Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            },
            {
              "originalPosition": 56,
              "body": "I'd not use the future, I think that would be better talking in the present",
              "createdAt": "2023-06-05T12:34:03Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            },
            {
              "originalPosition": 56,
              "body": "`client instance` -> `Client instance`",
              "createdAt": "2023-06-05T12:34:32Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            },
            {
              "originalPosition": 56,
              "body": "is client backend a defined term? If yes, we should uppercase it accordingly",
              "createdAt": "2023-06-05T12:35:10Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            },
            {
              "originalPosition": 60,
              "body": "will validate -> valitades",
              "createdAt": "2023-06-05T12:35:32Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XK2G8",
          "commit": {
            "abbreviatedOid": "6ac2b5c"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T12:48:39Z",
          "updatedAt": "2023-06-05T12:48:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "the clients being authenticated by the approach of this RFC, are to be considered public clients in OAuth speak. Doesn't it make sense to say so?",
              "createdAt": "2023-06-05T12:48:39Z",
              "updatedAt": "2023-06-05T12:48:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XK68l",
          "commit": {
            "abbreviatedOid": "6ac2b5c"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T12:56:53Z",
          "updatedAt": "2023-06-05T12:56:54Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "I will capitalize things later once they have an entry in the terminology",
              "createdAt": "2023-06-05T12:56:53Z",
              "updatedAt": "2023-06-05T12:56:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XK8Ea",
          "commit": {
            "abbreviatedOid": "6ac2b5c"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T12:59:19Z",
          "updatedAt": "2023-06-05T12:59:19Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I'm ok with public client since wallet instances are mobile devices, I was just asking since I read in the specs also the role of client backend without knowing which would be their client registration mechanisms",
              "createdAt": "2023-06-05T12:59:19Z",
              "updatedAt": "2023-06-05T12:59:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XLDS9",
          "commit": {
            "abbreviatedOid": "6ac2b5c"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T13:14:55Z",
          "updatedAt": "2023-06-05T13:14:56Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "changed all introduction text to present",
              "createdAt": "2023-06-05T13:14:55Z",
              "updatedAt": "2023-06-05T13:14:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XLjSU",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T14:11:19Z",
          "updatedAt": "2023-06-05T14:11:19Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I approve this PR with this in mind\r\n\r\nClient Instance, as represented in the Figure 1, should be a defined term as well",
              "createdAt": "2023-06-05T14:11:19Z",
              "updatedAt": "2023-06-05T14:11:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XLjUZ",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-05T14:11:23Z",
          "updatedAt": "2023-06-05T14:11:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5XYPNF",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-06T19:56:39Z",
          "updatedAt": "2023-06-06T19:56:40Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "This paragraph reads like there is a dependency on an AS providing a metadata document for a client to discover when in reality a client could know through an out of band mechanism that its what the AS requires for client authentication",
              "createdAt": "2023-06-06T19:56:39Z",
              "updatedAt": "2023-06-06T19:56:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XYPyC",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-06T19:58:20Z",
          "updatedAt": "2023-06-06T19:58:21Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Again I'm wary of describing the usage of platform attestations in this draft even in a non-normative manner as this mechanism of client authentication is agnostic to these sorts of things, perhaps we should put this in an appendix?",
              "createdAt": "2023-06-06T19:58:20Z",
              "updatedAt": "2023-06-06T19:58:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XYS8R",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-06T20:03:25Z",
          "updatedAt": "2023-06-06T20:03:26Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "```suggestion\r\n   A JSON Web Token (JWT) generated by the client backend which is bound to a key managed by a client instance which can then be used by the instance for client authentication.\r\n```",
              "createdAt": "2023-06-06T20:03:25Z",
              "updatedAt": "2023-06-06T20:03:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XYo5Q",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-06T20:45:21Z",
          "updatedAt": "2023-06-06T20:45:22Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "```suggestion\r\nClient Attestation Proof of Possession (PoP) JWT\r\n```",
              "createdAt": "2023-06-06T20:45:21Z",
              "updatedAt": "2023-06-06T20:45:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XYpF0",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-06T20:45:53Z",
          "updatedAt": "2023-06-06T20:45:53Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "```suggestion\r\n   A Proof of Possession generated by the client instance using the key that the Client Attestation JWT is bound to.\r\n```",
              "createdAt": "2023-06-06T20:45:53Z",
              "updatedAt": "2023-06-06T20:45:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5YF6J7",
          "commit": {
            "abbreviatedOid": "8825f3f"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I would like to see the description under the sequence diagram improved, but if you want to address that in another PR, that is fine too.",
          "createdAt": "2023-06-13T19:45:05Z",
          "updatedAt": "2023-06-13T19:45:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOJaEkaM5RtQi2",
      "title": "adding myself as author",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/16",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-30T17:12:40Z",
      "updatedAt": "2023-05-30T19:07:33Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "071f2a30565a4428394ab157325fffd212a47277",
      "headRepository": "paulbastian/draft-looker-oauth-attested-key-based-client-authentication",
      "headRefName": "editor",
      "headRefOid": "6461cabfe5388ffb6f8de6c9d8ae956ce6c8cc5b",
      "closedAt": "2023-05-30T19:07:33Z",
      "mergedAt": "2023-05-30T19:07:33Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "3006a80ffa8a5375a1d0fc277a93432b29c3409d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5Whktc",
          "commit": {
            "abbreviatedOid": "6461cab"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-30T19:07:27Z",
          "updatedAt": "2023-05-30T19:07:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 19,
      "id": "PR_kwDOJaEkaM5S7FXz",
      "title": "Simplifies introduction",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/19",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Re-simplifies the introduction ",
      "createdAt": "2023-06-13T19:52:21Z",
      "updatedAt": "2023-10-23T20:07:30Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "0d942cf0688ed99afccfb16c850bb5ff7b62bfc3",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/simplify-intro",
      "headRefOid": "2ff3c8cd02361c4d7471a873635da3c78419d4bd",
      "closedAt": "2023-10-23T20:07:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed in favour of changes made in #52 ",
          "createdAt": "2023-10-23T20:07:30Z",
          "updatedAt": "2023-10-23T20:07:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5Zg2lf",
          "commit": {
            "abbreviatedOid": "2ff3c8c"
          },
          "author": "selfissued",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I agree with this direction.  I would try to eliminate places where the spec appears to be make normative statements about having a backend.  (It's fine to say things like \"1. A Client Attestation JWT - typically produced by the client backend.\")",
          "createdAt": "2023-06-27T20:21:36Z",
          "updatedAt": "2023-06-27T20:21:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5Zg-Ej",
          "commit": {
            "abbreviatedOid": "2ff3c8c"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-27T20:45:25Z",
          "updatedAt": "2023-06-27T20:45:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5jJzxf",
          "commit": {
            "abbreviatedOid": "2ff3c8c"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "informally approved, formally requested two small editorial things",
          "createdAt": "2023-10-08T18:42:39Z",
          "updatedAt": "2023-10-08T18:43:28Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n1. A Client Attestation JWT produced by the client backend.\r\n2. A Client Attestation Proof of Possession (PoP) produced by the client instance.\r\n```",
              "createdAt": "2023-10-08T18:42:39Z",
              "updatedAt": "2023-10-08T18:43:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOJaEkaM5TggJG",
      "title": "Renames the draft",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/21",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Renames the draft as per the previous conversation in #11 ",
      "createdAt": "2023-06-21T06:32:21Z",
      "updatedAt": "2023-06-21T06:34:30Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "0d942cf0688ed99afccfb16c850bb5ff7b62bfc3",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/rename-draft",
      "headRefOid": "e353a6a5f1e289d2a11df5448c3081b6576c5811",
      "closedAt": "2023-06-21T06:34:30Z",
      "mergedAt": "2023-06-21T06:34:30Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "c41f00ee49ceaf65aac6d2b1ab85dc5cb8ba41a3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5YzYDI",
          "commit": {
            "abbreviatedOid": "e353a6a"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-21T06:34:20Z",
          "updatedAt": "2023-06-21T06:34:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOJaEkaM5TscnY",
      "title": "fix: small typos in the diagram",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/22",
      "state": "MERGED",
      "author": "peppelinux",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses # <!-- Issue # here -->\r\n\r\n## \ud83d\udcd1 Description\r\n<!-- Add a brief description of the pr -->\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-06-22T21:06:40Z",
      "updatedAt": "2023-06-26T20:21:30Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "4e37428fbe7d51eca28fb8f78b0670460281b321",
      "headRepository": "peppelinux/draft-looker-oauth-attestation-based-client-authentication",
      "headRefName": "patch-1",
      "headRefOid": "e7d8b3dc2cc3a791280f2e84792dff07a6868a7a",
      "closedAt": "2023-06-26T20:21:30Z",
      "mergedAt": "2023-06-26T20:21:30Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "8d559493b23cbfbb31dc36f055d021727a39ae8b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5ZPXzv",
          "commit": {
            "abbreviatedOid": "e7d8b3d"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-25T21:59:52Z",
          "updatedAt": "2023-06-25T21:59:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5ZXmvU",
          "commit": {
            "abbreviatedOid": "e7d8b3d"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-26T20:21:18Z",
          "updatedAt": "2023-06-26T20:21:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOJaEkaM5UEiST",
      "title": "add 2.0 to be consistent with other oauth drafts",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/23",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "## \ud83d\udcd1 Description\r\n\r\nFixes some minor typos",
      "createdAt": "2023-06-27T19:20:08Z",
      "updatedAt": "2023-06-27T19:20:56Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "c797daf4f099359bcc04229d9e92e3fa1f224f35",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/rename-draft",
      "headRefOid": "c4c448cb447c9f393b44ac00e5031d8445588085",
      "closedAt": "2023-06-27T19:20:16Z",
      "mergedAt": "2023-06-27T19:20:16Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "bfc14dddcc864efe25d201159abfedddc08a7496"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 25,
      "id": "PR_kwDOJaEkaM5UFpJH",
      "title": "Mike's pre-publication suggestions",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/25",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #24",
      "createdAt": "2023-06-28T00:13:26Z",
      "updatedAt": "2023-07-05T20:43:16Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "a09c6e079f6fae416a8ac451fdea7ce987884fad",
      "headRepository": "selfissued/draft-looker-oauth-attestation-based-client-authentication",
      "headRefName": "mbj-pre-publication-suggestions",
      "headRefOid": "c6d649d285643da868cae9984655345db9c05a11",
      "closedAt": "2023-07-05T20:43:16Z",
      "mergedAt": "2023-07-05T20:43:16Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "4eb06888fbe89c8129babc26f501a0693a600510"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5aUiqT",
          "commit": {
            "abbreviatedOid": "c6d649d"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-05T20:42:57Z",
          "updatedAt": "2023-07-05T20:42:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 26,
      "id": "PR_kwDOJaEkaM5U1poR",
      "title": "add example",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/26",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses # <!-- Issue # here -->\r\n\r\n## \ud83d\udcd1 Description\r\n<!-- Add a brief description of the pr -->\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-07-06T18:59:16Z",
      "updatedAt": "2023-07-10T06:59:26Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "4eb06888fbe89c8129babc26f501a0693a600510",
      "headRepository": "paulbastian/draft-looker-oauth-attested-key-based-client-authentication",
      "headRefName": "example",
      "headRefOid": "8816f3015746c0974862cfa0e96f7e4c44e0dc27",
      "closedAt": "2023-07-10T06:59:25Z",
      "mergedAt": "2023-07-10T06:59:25Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "ddfbf0d8a096db7362ab478f60f3381eb1c8a8c8"
      },
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "@tlodderstedt please review",
          "createdAt": "2023-07-10T06:53:46Z",
          "updatedAt": "2023-07-10T06:53:46Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5abgTJ",
          "commit": {
            "abbreviatedOid": "a5e3fa1"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-06T19:14:50Z",
          "updatedAt": "2023-07-06T19:14:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n# Appendix A IANA Considerations\r\n```",
              "createdAt": "2023-07-06T19:14:50Z",
              "updatedAt": "2023-07-06T19:14:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5abkQ9",
          "commit": {
            "abbreviatedOid": "f7f835c"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-06T19:27:55Z",
          "updatedAt": "2023-07-06T19:27:56Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n\t\"typ\": \"vc+sd-jwt\",\r\n```",
              "createdAt": "2023-07-06T19:27:55Z",
              "updatedAt": "2023-07-06T19:27:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5abpZy",
          "commit": {
            "abbreviatedOid": "27016e1"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-06T19:42:55Z",
          "updatedAt": "2023-07-06T19:42:55Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\n\t\"typ\": \"wallet-attestation+jwt\",\r\n\t\"alg\": \"ES256\",\r\n\t\"kid\": \"1\"\r\n}\r\n.\r\n{\r\n\t\"iss\": \"https://attestation-service.ssi.tir.budru.de\",\r\n\t\"sub\" : \"https://lissi.org\",\r\n\t\"iat\": 1541493724,\r\n\t\"exp\": 1516247022,\r\n\t\"wallet_name\": \"Lissi Dev\",\r\n```",
              "createdAt": "2023-07-06T19:42:55Z",
              "updatedAt": "2023-07-06T19:42:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5afHlN",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-07-07T07:10:57Z",
          "updatedAt": "2023-07-07T07:12:28Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\n\t\"iss\": \"https://wallet.example.com\",\r\n```",
              "createdAt": "2023-07-07T07:10:57Z",
              "updatedAt": "2023-07-07T07:12:28Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\n\t\"sub\" : \"https://wallet.example.com\"\",\r\n```",
              "createdAt": "2023-07-07T07:11:14Z",
              "updatedAt": "2023-07-07T07:12:28Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\r\n```",
              "createdAt": "2023-07-07T07:11:28Z",
              "updatedAt": "2023-07-07T07:12:28Z"
            },
            {
              "originalPosition": 17,
              "body": "If you mention eIDAS terms, like \"Type-1 configuration\", you also need to add a reference to the ARF.",
              "createdAt": "2023-07-07T07:12:17Z",
              "updatedAt": "2023-07-07T07:12:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5afWY8",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T07:34:11Z",
          "updatedAt": "2023-07-07T07:34:12Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n\t\"key_type\" : \"STRONGBOX\",\r\n```",
              "createdAt": "2023-07-07T07:34:12Z",
              "updatedAt": "2023-07-07T07:34:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5afXGc",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-07-07T07:35:24Z",
          "updatedAt": "2023-07-07T07:35:58Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\n```\r\n\r\nWhy the attestation should disclose information like these?\r\nProbably the User doesn't want to disclose the device name and the wallet version",
              "createdAt": "2023-07-07T07:35:24Z",
              "updatedAt": "2023-07-07T07:35:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ag2bI",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T10:54:41Z",
          "updatedAt": "2023-07-07T10:54:41Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I would rename this to attestation-service.com to signalize that these could be different?",
              "createdAt": "2023-07-07T10:54:41Z",
              "updatedAt": "2023-07-07T10:54:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ag4pN",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T11:00:43Z",
          "updatedAt": "2023-07-07T11:00:43Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "\"wallet_name\" is meant as a human readable name of the wallet solution, the technical identifier for a wallet solution would be registered as \"sub\"\r\n\"wallet_version\" is the version of the wallet instance of the wallet solution. The certification and validity status of a wallet solution probably depends on the version, thus for lookup in a trust registry the version is useful",
              "createdAt": "2023-07-07T11:00:43Z",
              "updatedAt": "2023-07-07T11:00:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ahYBN",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T12:13:01Z",
          "updatedAt": "2023-07-07T12:13:01Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I see some value in the wallet name. wrt the version, as we discussed yesterday, I would assume whatever is needed to lookup data about the authorization of the wallet should be encoded in the iss or sub value. ",
              "createdAt": "2023-07-07T12:13:01Z",
              "updatedAt": "2023-07-07T12:13:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ahZD-",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T12:14:48Z",
          "updatedAt": "2023-07-07T12:14:48Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I think this is a special case, which requires explanation. If you provide text, I could incorporate into https://github.com/vcstuff/oid4vc-haip-sd-jwt-vc/pull/52\r\n\r\nI would like to keep the example as simple as possible.  \r\n\r\n",
              "createdAt": "2023-07-07T12:14:48Z",
              "updatedAt": "2023-07-07T12:15:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ajtJm",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T17:00:01Z",
          "updatedAt": "2023-07-07T17:00:02Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "added attested security context instead",
              "createdAt": "2023-07-07T17:00:02Z",
              "updatedAt": "2023-07-07T17:00:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ajtRO",
          "commit": {
            "abbreviatedOid": "33af8c0"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T17:00:24Z",
          "updatedAt": "2023-07-07T17:00:25Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "added version to sub",
              "createdAt": "2023-07-07T17:00:24Z",
              "updatedAt": "2023-07-07T17:00:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5arj1h",
          "commit": {
            "abbreviatedOid": "8816f30"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-10T06:52:58Z",
          "updatedAt": "2023-07-10T06:52:59Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\n\t\"key_type\" : \"Strongbox\",\r\n```",
              "createdAt": "2023-07-10T06:52:59Z",
              "updatedAt": "2023-07-10T06:52:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5armix",
          "commit": {
            "abbreviatedOid": "8816f30"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T06:58:55Z",
          "updatedAt": "2023-07-10T06:58:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 40,
      "id": "PR_kwDOJaEkaM5Zu2j5",
      "title": "fix: jti usage language",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/40",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses issues with language about the jti claim in the client attestation and pop jwt.\r\n\r\nCloses #34 \r\nCloses #33 \r\nCloses #37 ",
      "createdAt": "2023-09-07T00:55:00Z",
      "updatedAt": "2023-09-10T20:21:07Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "cb0ef588b56e55d29485b7e7a5e3982f5cd21197",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/jti-fixes",
      "headRefOid": "c4b13bda0033411e98f86928dbd1eb42f5a3c3e1",
      "closedAt": "2023-09-07T21:03:30Z",
      "mergedAt": "2023-09-07T21:03:30Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "69ab12820785d6d9c7eb63c09fc5d0c2ce88b0ea"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5gUIb7",
          "commit": {
            "abbreviatedOid": "c4b13bd"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-07T17:03:37Z",
          "updatedAt": "2023-09-07T17:03:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5gVaqV",
          "commit": {
            "abbreviatedOid": "c4b13bd"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-07T20:53:08Z",
          "updatedAt": "2023-09-07T20:53:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "PR_kwDOJaEkaM5Zu5iZ",
      "title": "fix: cnf claim definition in client attestation",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/41",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Clarifies the purpose of the cnf claim in the client attestation.\r\n\r\nPartially addresses #36",
      "createdAt": "2023-09-07T01:16:34Z",
      "updatedAt": "2023-09-10T20:21:06Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "cb0ef588b56e55d29485b7e7a5e3982f5cd21197",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/cnf-claim",
      "headRefOid": "8cf674e77485a08f1556a176dad155dfb9387982",
      "closedAt": "2023-09-08T21:44:03Z",
      "mergedAt": "2023-09-08T21:44:03Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "5bdd508375492f6d571f4b47b2e8502f81a33457"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5gUKZt",
          "commit": {
            "abbreviatedOid": "8cf674e"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-07T17:07:12Z",
          "updatedAt": "2023-09-07T17:07:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5gdgP9",
          "commit": {
            "abbreviatedOid": "8cf674e"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-08T21:43:58Z",
          "updatedAt": "2023-09-08T21:43:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 42,
      "id": "PR_kwDOJaEkaM5Zu69c",
      "title": "fix refresh token binding issue",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/42",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #31 \r\nCloses #12 ",
      "createdAt": "2023-09-07T01:21:27Z",
      "updatedAt": "2023-09-10T20:21:05Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "cb0ef588b56e55d29485b7e7a5e3982f5cd21197",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/rt-binding",
      "headRefOid": "ae04ddcee9e1797e3977c7ba3b30c24ae8a41f4d",
      "closedAt": "2023-09-08T21:43:04Z",
      "mergedAt": "2023-09-08T21:43:04Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "97c241f3b9baab01e4537750dbed0c29e6544eb1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5gUIoM",
          "commit": {
            "abbreviatedOid": "ae04ddc"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-07T17:04:10Z",
          "updatedAt": "2023-09-07T17:04:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5gdfy2",
          "commit": {
            "abbreviatedOid": "ae04ddc"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-08T21:43:00Z",
          "updatedAt": "2023-09-08T21:43:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOJaEkaM5Zu9AZ",
      "title": "fix: generalise the client authentication section",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/43",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Minor language tweaks aligning more to RFC 7521 in how the client authentication mechanism is defined as to not limit its application to only being used at the token endpoint.\r\n\r\nCloses #27",
      "createdAt": "2023-09-07T01:36:28Z",
      "updatedAt": "2023-09-10T20:21:04Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "cb0ef588b56e55d29485b7e7a5e3982f5cd21197",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/client-auth-generalization",
      "headRefOid": "7dcc424a319113ec6e325869b99161dfb67200fb",
      "closedAt": "2023-09-08T21:45:59Z",
      "mergedAt": "2023-09-08T21:45:59Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "2afbd665e8cbd9e9c2c82fabf918da05ed573037"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5gdhJ1",
          "commit": {
            "abbreviatedOid": "7dcc424"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-08T21:45:54Z",
          "updatedAt": "2023-09-08T21:45:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "PR_kwDOJaEkaM5ZznZW",
      "title": "add to acknowledgments",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/44",
      "state": "MERGED",
      "author": "bc-pi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Asking to add myself to the acknowledgments, which I think is reasonable based on conversations, emails, etc. that I've had with the authors on the topic. \r\n\r\nThere are probably other names that should be added too...\r\n",
      "createdAt": "2023-09-07T17:50:12Z",
      "updatedAt": "2023-09-07T19:00:41Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "cb0ef588b56e55d29485b7e7a5e3982f5cd21197",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "bc-pi-add-to-acks",
      "headRefOid": "236d12dd45d91bd41c05973b9d74b96d4f1319b0",
      "closedAt": "2023-09-07T18:52:02Z",
      "mergedAt": "2023-09-07T18:52:02Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "6dcd84c85bfa441b336b2a1bc8cfc9a230999afb"
      },
      "comments": [
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you :)",
          "createdAt": "2023-09-07T19:00:34Z",
          "updatedAt": "2023-09-07T19:00:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5gUwHl",
          "commit": {
            "abbreviatedOid": "236d12d"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "A PR I should have already raised myself :)",
          "createdAt": "2023-09-07T18:51:50Z",
          "updatedAt": "2023-09-07T18:51:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 48,
      "id": "PR_kwDOJaEkaM5cMdH5",
      "title": "add text on aal",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/48",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses # <!-- Issue # here -->\r\n\r\n## \ud83d\udcd1 Description\r\nOn text on optional aal parameter\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-08T15:01:59Z",
      "updatedAt": "2023-10-09T14:22:41Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "2afbd665e8cbd9e9c2c82fabf918da05ed573037",
      "headRepository": "paulbastian/draft-looker-oauth-attested-key-based-client-authentication",
      "headRefName": "aal",
      "headRefOid": "b843a2a60fa49577b58d083b483823a6e4fc3dd3",
      "closedAt": "2023-10-09T14:22:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry @peppelinux . This PR got somehow messed up in git merge. I will raise a new one, as this was only intended for aal",
          "createdAt": "2023-10-09T14:22:41Z",
          "updatedAt": "2023-10-09T14:22:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5jJzi9",
          "commit": {
            "abbreviatedOid": "b843a2a"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "@paulbastian it seems that this PR doesn't contain nothing about AAL, is this a mistake?\r\n\r\n--- updates ---\r\n\r\nfound it at line 195, my bad",
          "createdAt": "2023-10-08T18:34:06Z",
          "updatedAt": "2023-10-09T09:22:51Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "git merge conflict here, I'm in favor of the first sentence :-)\r\nthen we should put a ref to RFC7519, related to the section where the jti claim is defined",
              "createdAt": "2023-10-08T18:34:07Z",
              "updatedAt": "2023-10-08T18:41:51Z"
            },
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n3. The JWT MUST contain an \"aud\" (audience) claim containing a value that identifies the authorization server as an intended audience. The {{RFC8414}} issuer identifier URL of the authorization server MUST be used as a value for an \"aud\" element to identify the authorization server as the intended audience of the JWT.\r\n```\r\n```suggestion\r\n3. The JWT MUST contain the \"aud\" (audience) claim containing a value that identifies the authorization server as an intended audience. The {{RFC8414}} issuer identifier URL of the authorization server MUST be used as a value for an \"aud\" element to identify the authorization server as the intended audience of the JWT.\r\n```\r\n\r\nI suggest to have in the aud the url of the endpoint where the JWT is intended to be used, then the authz endpoint, the token endpoint ... it could/should be an array as well. When we say `containing a value that identifies the authorization server` we should mention the issuer (entity id) as well and a ref to rfc8414 (issuer claim, that MUST be present within the AS metadata)",
              "createdAt": "2023-10-08T18:35:23Z",
              "updatedAt": "2023-10-08T18:41:51Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n34 The JWT MAY contain the \"jti\" (JWT ID) claim that provides a unique identifier for the token.  The authorization server MAY ensure that JWTs are not replayed by maintaining the set of used \"jti\" values for the length of time for which the JWT would be considered valid based on the applicable \"exp\" instant.\r\n```",
              "createdAt": "2023-10-08T18:37:06Z",
              "updatedAt": "2023-10-08T18:41:51Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n5. The JWT MAY contain the \"nonce\" claim containing the value provided by the authorization server to associate the Client Attestation PoP JWT with a particular transaction and prevent replay attacks.\r\n```",
              "createdAt": "2023-10-08T18:38:24Z",
              "updatedAt": "2023-10-08T18:41:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5jKXCP",
          "commit": {
            "abbreviatedOid": "b843a2a"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T02:05:57Z",
          "updatedAt": "2023-10-09T02:05:58Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n7. The JWT MAY contain a \"jti\" (JWT ID) claim that provides a unique identifier for the token. The authorization server MAY ensure that JWTs are not replayed by maintaining the set of used \"jti\" values for the length of time for which the JWT would be considered valid based on the applicable \"exp\" instant.\r\n```",
              "createdAt": "2023-10-09T02:05:57Z",
              "updatedAt": "2023-10-09T02:05:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5jK8Zi",
          "commit": {
            "abbreviatedOid": "b843a2a"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T06:54:33Z",
          "updatedAt": "2023-10-09T06:54:33Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "`The authorization server MAY ensure that JWTs are not replayed by maintaining the set of used \"jti\" values for the length of time for which the JWT would be considered valid based on the applicable \"exp\" instant.`\r\n\r\nthis is possibile only if `jti` is REQUIRED, that's why I suggest to move that MAY to a MUST, otherwise the text above would not make any sense",
              "createdAt": "2023-10-09T06:54:33Z",
              "updatedAt": "2023-10-09T06:54:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 49,
      "id": "PR_kwDOJaEkaM5cMdpW",
      "title": "Replay prevention",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/49",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses # <!-- Issue # here -->\r\n\r\n## \ud83d\udcd1 Description\r\n<!-- Add a brief description of the pr -->\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-08T15:09:52Z",
      "updatedAt": "2023-10-23T09:14:33Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "2afbd665e8cbd9e9c2c82fabf918da05ed573037",
      "headRepository": "paulbastian/draft-looker-oauth-attested-key-based-client-authentication",
      "headRefName": "replay-prevention",
      "headRefOid": "d5d5ffeb73f28d0a77b5955b78fa7008478823be",
      "closedAt": "2023-10-23T09:14:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed in favor for #54 ",
          "createdAt": "2023-10-23T09:14:33Z",
          "updatedAt": "2023-10-23T09:14:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5jJwGZ",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-10-08T18:18:03Z",
          "updatedAt": "2023-10-08T18:32:10Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "MAY is to weak!\r\n\r\nI really prefer the previous text where the JTI MUST be present and the AS MAY evaluate it. It doesn't cost nothing to the implementers, that would be just an uuid4",
              "createdAt": "2023-10-08T18:18:03Z",
              "updatedAt": "2023-10-08T18:45:21Z"
            },
            {
              "originalPosition": 17,
              "body": "`iat`, `exp` and claims belongin to JWT should include a ref to the RFC that defined them, so that there also the format and any other relevant information could be given in relation to these",
              "createdAt": "2023-10-08T18:26:40Z",
              "updatedAt": "2023-10-08T18:32:10Z"
            },
            {
              "originalPosition": 23,
              "body": "did we say something about the epic alg `none` here? ;-)",
              "createdAt": "2023-10-08T18:27:22Z",
              "updatedAt": "2023-10-08T18:32:10Z"
            },
            {
              "originalPosition": 38,
              "body": "agreed, then we shoudl mandate the presence of `jti` in the WIA as it was before this PR",
              "createdAt": "2023-10-08T18:28:37Z",
              "updatedAt": "2023-10-08T18:32:10Z"
            },
            {
              "originalPosition": 39,
              "body": "may we say something on the minimum length of the nonce?",
              "createdAt": "2023-10-08T18:29:38Z",
              "updatedAt": "2023-10-08T18:32:10Z"
            },
            {
              "originalPosition": 40,
              "body": "here we don't say who's the issuer of the existing artefact and from where and when it was taken.\r\n\r\nI understand the meaning but for editorial sake we should say something more explicit here",
              "createdAt": "2023-10-08T18:32:05Z",
              "updatedAt": "2023-10-08T18:32:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5jJz07",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-10-08T18:44:41Z",
          "updatedAt": "2023-10-08T18:47:37Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n3. The JWT MUST contain the \"aud\" (audience) claim containing a value that identifies the authorization server as an intended audience. The {{RFC8414}} issuer identifier URL of the authorization server MUST be used as a value for an \"aud\" element to identify the authorization server as the intended audience of the JWT.\r\n```\r\n\r\nWDYT about using the instead of \"an\"? If agreed, please change all the occurence accordignly or ask to me to give a suggestion to have them easy to be merged",
              "createdAt": "2023-10-08T18:44:41Z",
              "updatedAt": "2023-10-08T18:47:37Z"
            },
            {
              "originalPosition": 39,
              "body": "as for all the other parameters, it would be better to give a ref to the RFC that have defined them, for the nonce it would be something like \r\n\r\nshall require the nonce parameter defined in Section 3.1.2.1 of [OIDC](https://openid.net/specs/openid-connect-core-1_0.html) in the authentication request.",
              "createdAt": "2023-10-08T18:47:28Z",
              "updatedAt": "2023-10-08T18:47:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k2p0U",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T09:03:37Z",
          "updatedAt": "2023-10-23T09:03:38Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "agreed to this in discussion with Tobias. The PR is from an old repo of mine and I will file a fresh one, sry for that",
              "createdAt": "2023-10-23T09:03:38Z",
              "updatedAt": "2023-10-23T09:03:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k2qC_",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T09:04:08Z",
          "updatedAt": "2023-10-23T09:04:08Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I would leave this to native speakers and to a separate issue, please raise one if thats important to you",
              "createdAt": "2023-10-23T09:04:08Z",
              "updatedAt": "2023-10-23T09:04:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k2qg9",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T09:05:08Z",
          "updatedAt": "2023-10-23T09:05:08Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "This is a good idea, but I would like to keep this PR short",
              "createdAt": "2023-10-23T09:05:08Z",
              "updatedAt": "2023-10-23T09:05:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k2q0S",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T09:05:48Z",
          "updatedAt": "2023-10-23T09:05:48Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I think the text is clear enough here",
              "createdAt": "2023-10-23T09:05:48Z",
              "updatedAt": "2023-10-23T09:05:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k2q_c",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T09:06:09Z",
          "updatedAt": "2023-10-23T09:06:10Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "agreed",
              "createdAt": "2023-10-23T09:06:09Z",
              "updatedAt": "2023-10-23T09:06:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k2tXq",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T09:11:22Z",
          "updatedAt": "2023-10-23T09:11:22Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "done in new PR",
              "createdAt": "2023-10-23T09:11:22Z",
              "updatedAt": "2023-10-23T09:11:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k2tqB",
          "commit": {
            "abbreviatedOid": "d5d5ffe"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T09:11:59Z",
          "updatedAt": "2023-10-23T09:11:59Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "I don't see OIDC making it explicit about the nonce length either",
              "createdAt": "2023-10-23T09:11:59Z",
              "updatedAt": "2023-10-23T09:12:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 50,
      "id": "PR_kwDOJaEkaM5cMd2Q",
      "title": "Update referenced rfcs",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/50",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses # <!-- Issue # here -->\r\n\r\n## \ud83d\udcd1 Description\r\n<!-- Add a brief description of the pr -->\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-08T15:12:59Z",
      "updatedAt": "2023-10-23T07:31:05Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "2afbd665e8cbd9e9c2c82fabf918da05ed573037",
      "headRepository": "paulbastian/draft-looker-oauth-attested-key-based-client-authentication",
      "headRefName": "update-referenced-rfcs",
      "headRefOid": "290dbb93a54965e589a81a4d8506bb1d0cccbc84",
      "closedAt": "2023-10-23T07:31:05Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 51,
      "id": "PR_kwDOJaEkaM5cRKk4",
      "title": "add text on aal",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/51",
      "state": "CLOSED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses #15 \r\nCloses #29 \r\n\r\n## \ud83d\udcd1 Description\r\nAdd text on aal claim\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-09T14:31:36Z",
      "updatedAt": "2024-08-22T06:47:32Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "efa100ca094afee2303275bd8f518b81c9a0c97a",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "aal",
      "headRefOid": "ca1825a223e6f3d9b2dc0d996578e0ad6287f0d7",
      "closedAt": "2024-08-22T06:47:32Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "Supported here\r\nhttps://github.com/italia/eudi-wallet-it-docs/pull/155\r\n\r\nanyway it would be better define within the specs the grouping of the security capabilities according to the levels low, medium and high\r\n",
          "createdAt": "2023-11-02T11:53:55Z",
          "updatedAt": "2023-11-02T11:53:55Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "regarding the current ideas developed in OpenID4VCI to separate wallet attestation and key attestation (see https://github.com/openid/OpenID4VCI/issues/355 ) this no longer makes sense here",
          "createdAt": "2024-08-22T06:47:32Z",
          "updatedAt": "2024-08-22T06:47:32Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5k1yrW",
          "commit": {
            "abbreviatedOid": "5972c61"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T06:56:08Z",
          "updatedAt": "2023-10-23T06:56:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n8. The JWT MAY contain a \"aal\" (authenticator assurance level) claim that describes the attested assurance level of the Client Instance and the Client Instance Key. The claim value contains a URI that references a jurisdictional framework. Consumers of the client attestation are RECOMMENDED to evaluate this claim, if they intend to state an assurance level for their issued tokens themselves.\r\n```",
              "createdAt": "2023-10-23T06:56:09Z",
              "updatedAt": "2023-10-23T06:56:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5nVqQ1",
          "commit": {
            "abbreviatedOid": "b58032e"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-16T08:03:30Z",
          "updatedAt": "2023-11-16T08:03:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n8. The JWT MAY contain a \"aal\" (authenticator assurance level) claim that describes the attested assurance level of the Client Instance and the Client Instance Key. The claim value contains a URI that references a jurisdictional framework. Consumers of the Client attestation are RECOMMENDED to evaluate this claim, if they intend to state an assurance level for their issued tokens themselves.\r\n```",
              "createdAt": "2023-11-16T08:03:31Z",
              "updatedAt": "2023-11-16T08:03:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 52,
      "id": "PR_kwDOJaEkaM5dfsiC",
      "title": "redesigning sequence diagram for introduction",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/52",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses #28 \r\n\r\n## \ud83d\udcd1 Description\r\n<!-- Add a brief description of the pr -->\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-23T07:08:55Z",
      "updatedAt": "2023-10-23T20:17:36Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "f3bcbb6d51e53179e5305a87ee77b94e0d05d6c6",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "pb/introduction",
      "headRefOid": "cec19c496f893a2aa174859bd75c2d9057c37a3a",
      "closedAt": "2023-10-23T20:17:36Z",
      "mergedAt": "2023-10-23T20:17:36Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "da0aa67d34880a59621d7a2715d08fbb9f40e60b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5k79LP",
          "commit": {
            "abbreviatedOid": "53f3483"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T20:06:58Z",
          "updatedAt": "2023-10-23T20:06:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5k8ATu",
          "commit": {
            "abbreviatedOid": "53f3483"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T20:15:47Z",
          "updatedAt": "2023-10-23T20:15:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 53,
      "id": "PR_kwDOJaEkaM5dfyGb",
      "title": "remove JWT ID from Client Attestation JWT",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/53",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses # <!-- Issue # here -->\r\n\r\n## \ud83d\udcd1 Description\r\n<!-- Add a brief description of the pr -->\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-23T07:25:56Z",
      "updatedAt": "2023-10-23T18:22:41Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "2afbd665e8cbd9e9c2c82fabf918da05ed573037",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "pb/remove-jti",
      "headRefOid": "7fa2916a9c05756d36b93aa4d03765f0c4d746cc",
      "closedAt": "2023-10-23T18:22:41Z",
      "mergedAt": "2023-10-23T18:22:41Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "c984b2efd5177e8909d731552eefbe45bec5c9f9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5k7JPV",
          "commit": {
            "abbreviatedOid": "7fa2916"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T18:22:35Z",
          "updatedAt": "2023-10-23T18:22:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 54,
      "id": "PR_kwDOJaEkaM5dgaPD",
      "title": "replay attack prevention",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/54",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses #49\r\nCloses #9 \r\n\r\n## \ud83d\udcd1 Description\r\nAdd security consideration for replay attack prevention and add nonce as optional value for PoP JWT\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-23T09:14:13Z",
      "updatedAt": "2023-10-23T20:15:32Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "c6044dced77de65a5706bcafc7baec4587ba8201",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "pb/replay-attack-prevention",
      "headRefOid": "307b46da9a75cd6e6c07622d90ccfe087dc9119f",
      "closedAt": "2023-10-23T20:15:31Z",
      "mergedAt": "2023-10-23T20:15:31Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "f3bcbb6d51e53179e5305a87ee77b94e0d05d6c6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5k7Kpp",
          "commit": {
            "abbreviatedOid": "06f791f"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T18:26:06Z",
          "updatedAt": "2023-10-23T18:26:07Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Should we make this into a sub heading like `Replay Attack Detection`?",
              "createdAt": "2023-10-23T18:26:06Z",
              "updatedAt": "2023-10-23T18:26:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k79uZ",
          "commit": {
            "abbreviatedOid": "06f791f"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T20:08:29Z",
          "updatedAt": "2023-10-23T20:08:29Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n## Replay Attack Detection\r\n\r\nThe following mechanisms exist within this client authentication method in order to allow an authorization server to detect replay attacks for presented client attestation PoPs:\r\n```",
              "createdAt": "2023-10-23T20:08:29Z",
              "updatedAt": "2023-10-23T20:10:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k7-3k",
          "commit": {
            "abbreviatedOid": "29de252"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T20:11:40Z",
          "updatedAt": "2023-10-23T20:11:41Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n## Replay Attack Detection\r\n\r\nThe following mechanisms exist within this client authentication method in order to allow an authorization server to detect replay attacks for presented client attestation PoPs:\r\n```",
              "createdAt": "2023-10-23T20:11:40Z",
              "updatedAt": "2023-10-23T20:11:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k7_jT",
          "commit": {
            "abbreviatedOid": "29de252"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T20:13:40Z",
          "updatedAt": "2023-10-23T20:13:40Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nThe approach using a nonce explicitly provided by the authorization server gives stronger replay attack detection guarantees, however support by the authorization server is OPTIONAL to simplify mandatory implementation requirements. The \"jti\" method is mandatory and hence acts as a default fallback.\r\n```",
              "createdAt": "2023-10-23T20:13:40Z",
              "updatedAt": "2023-10-23T20:14:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5k8AI9",
          "commit": {
            "abbreviatedOid": "307b46d"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T20:15:16Z",
          "updatedAt": "2023-10-23T20:15:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 55,
      "id": "PR_kwDOJaEkaM5dkTHB",
      "title": "update acknowledments",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/55",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses # <!-- Issue # here -->\r\n\r\n## \ud83d\udcd1 Description\r\n<!-- Add a brief description of the pr -->\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-10-23T19:12:05Z",
      "updatedAt": "2023-10-23T20:07:12Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "c984b2efd5177e8909d731552eefbe45bec5c9f9",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "pb/acknowledgments",
      "headRefOid": "dffbd0bf8cd6756d8d2d59e95ab8744918298cff",
      "closedAt": "2023-10-23T20:07:12Z",
      "mergedAt": "2023-10-23T20:07:12Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "a0c84e9505d9d1750ee9a8aabbf3a268a21a3499"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5k78c4",
          "commit": {
            "abbreviatedOid": "dffbd0b"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T20:04:58Z",
          "updatedAt": "2023-10-23T20:04:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 63,
      "id": "PR_kwDOJaEkaM5fST1s",
      "title": "Add text on cnf key rotation",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/63",
      "state": "MERGED",
      "author": "cobward",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses #57 \r\n\r\n## \ud83d\udcd1 Description\r\nThis PR makes explicit an already implicit feature of the specification - that it is not possible to rotate the confirmation key.\r\n<!--\r\n## Preview Link\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)\r\n-->",
      "createdAt": "2023-11-13T10:52:13Z",
      "updatedAt": "2024-02-13T17:42:06Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "4375d894ce7e58c91d5ed282cfd733dd48417812",
      "headRepository": "cobward/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "patch-1",
      "headRefOid": "4e783cc13e5929318a5915c67407e6d184c14aa0",
      "closedAt": "2024-02-13T17:42:06Z",
      "mergedAt": "2024-02-13T17:42:06Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "ac2eec4c4bcc3e206aca6df55910e5dc40da2eac"
      },
      "comments": [
        {
          "author": "cobward",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tlodderstedt @paulbastian Any reason this can't be merged?",
          "createdAt": "2024-02-06T12:13:09Z",
          "updatedAt": "2024-02-06T12:13:09Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": " Waiting for @tplooker approval",
          "createdAt": "2024-02-06T12:15:31Z",
          "updatedAt": "2024-02-06T12:15:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5m-nAU",
          "commit": {
            "abbreviatedOid": "a6df619"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-13T16:20:27Z",
          "updatedAt": "2023-11-13T16:21:25Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n## Rotation of Client Instance Key\r\n\r\nThis specification does not provide a mechanism to rotate the Client Instance Key in the Client Attestation JWT's \"cnf\" claim. If the Client Instance needs to use a new Client Instance Key for any reason, then it MUST request a new Client Attestation JWT from its Client Backend.\r\n\r\n```",
              "createdAt": "2023-11-13T16:20:28Z",
              "updatedAt": "2023-11-13T16:21:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5nHIUt",
          "commit": {
            "abbreviatedOid": "4e783cc"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-14T14:48:08Z",
          "updatedAt": "2023-11-14T14:48:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5nVqln",
          "commit": {
            "abbreviatedOid": "4e783cc"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-16T08:04:25Z",
          "updatedAt": "2023-11-16T08:04:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5nXBlr",
          "commit": {
            "abbreviatedOid": "4e783cc"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-16T10:55:21Z",
          "updatedAt": "2023-11-16T10:55:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5v1UG_",
          "commit": {
            "abbreviatedOid": "4e783cc"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-12T20:48:02Z",
          "updatedAt": "2024-02-12T20:48:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOJaEkaM5fajeK",
      "title": "Adds server-provided nonces for Client Attestation PoP JWT freshness verification",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/64",
      "state": "CLOSED",
      "author": "pmhsfelix",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses #59\r\n\r\n## \ud83d\udcd1 Description\r\nThis PR adds server-provided nonces as a way to check the freshness of Client Attestation PoP JWT, in a similar way to what is done in DPoP (RFC 9449).\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\nNA",
      "createdAt": "2023-11-14T14:08:40Z",
      "updatedAt": "2025-03-03T19:08:04Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "4375d894ce7e58c91d5ed282cfd733dd48417812",
      "headRepository": "pmhsfelix/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "add-server-provided-nonce",
      "headRefOid": "fa66a20f14e5e2425f583d1c53ac8e13c3c31c73",
      "closedAt": "2025-03-03T19:08:04Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "This is the obvious solution going in the right direction. I'm not convinced yet that this is the ideal solution, especially in combination with DPoP.",
          "createdAt": "2023-11-15T15:53:01Z",
          "updatedAt": "2023-11-15T15:53:01Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @paulbastian:\r\n> This is the obvious solution going in the right direction. I'm not convinced yet that this is the ideal solution, especially in combination with DPoP. \r\n \r\nAgree with the direction and also unsureness around DPoP. There's a lot of overlap and duplicative text and functionality with DPoP in this nonce mechanism and the Client Attestation PoP JWT itself. A lot. It makes me question (again) if it wouldn't be better to use the DPoP Proof JWT as the PoP mechanism in this work rather than recreate so much of it with the Client Attestation PoP JWT. \r\n",
          "createdAt": "2023-11-16T18:17:25Z",
          "updatedAt": "2023-11-16T18:17:25Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bc-pi \r\n\"It makes me question (again) if it wouldn't be better to use the DPoP Proof JWT as the PoP mechanism in this work rather than recreate so much of it with the Client Attestation PoP JWT.\"\r\n\r\nThat ties two mechanisms together that were built for different purposes. I think that would make sense if client attestation would always be used with DPoP bound access tokens. That means: a) no client attestation without sender constrained access tokens and b) no mTLS for sender constrained access tokens when using client attestation. ",
          "createdAt": "2023-11-16T18:26:57Z",
          "updatedAt": "2023-11-16T18:26:57Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That ties two mechanisms together that were built for different purposes. \r\n\r\nThe [DPoP proof JWT ](https://www.rfc-editor.org/rfc/rfc9449.html#name-dpop-proof-jwts) part of RFC9449 was built exactly for the purpose of proving possession of a key in the context of an HTTP request. And can be used without necessarily binding access tokens. ",
          "createdAt": "2023-11-16T18:40:55Z",
          "updatedAt": "2023-11-16T18:40:55Z"
        },
        {
          "author": "pmhsfelix",
          "authorAssociation": "NONE",
          "body": ">@bc-pi\r\n>There's a lot of overlap and duplicative text and functionality with DPoP in this nonce mechanism and the Client Attestation PoP JWT itself. A lot. It makes me question (again) if it wouldn't be better to use the DPoP Proof JWT as the PoP mechanism in this work rather than recreate so much of it with the Client Attestation PoP JWT.\r\n\r\nAlso had the exact same feeling while writing the PR, namely the creation of a duplicate header and a duplicate OAuth error code. Using DPoP for the proof-of-possession did also cross my mind.\r\n\r\nWe could perhaps decouple the DPoP proof of possession JWT from the `DPoP` HTTP header. \r\nMy current understanding is that the `DPoP` header serves *two* purposes when used on a Token Request:\r\n- Convey a public key proof-of-possesion JWT.\r\n- Request the issued tokens to be bound to that public key.\r\nOTOH, when used on a Resource Server request, the `DPoP` header seems to only serve the first purpose.\r\n\r\nIf we want to use DPoP all the way, then this seems to work perfectly. \r\nHowever, if we don't want to bind the access tokens using DPoP, we could still use the DPoP proof of possession JWT but convey it in a different way (e.g. on the token request body or on a different header, instead of on the `DPoP` header). The `DPoP-nonce` and `use_dpop_nonce` could still be used to provide a fresher nonce.\r\n\r\n",
          "createdAt": "2023-11-16T19:04:01Z",
          "updatedAt": "2023-11-16T19:04:01Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> [...] if we don't want to bind the access tokens using DPoP, [...] \r\n\r\nDPoP itself specifically has text in the [DPoP Access Token Request](https://www.rfc-editor.org/rfc/rfc9449.html#name-dpop-access-token-request) section that [allows for an AS to issue access tokens that are not DPoP bound](https://www.rfc-editor.org/rfc/rfc9449.html#section-5-9). It says:\r\n\r\n> An authorization server MAY elect to issue access tokens that are not DPoP bound, which is signaled to the client with a value of Bearer in the token_type parameter of the access token response per [RFC6750].\r\n\r\nAnd this draft could certainly reiterate that, if it went with the DPoP proof as its PoP mechanism.\r\n\r\nThere is and has been (it's come up previously) a lot of resistance to that approach though. But maybe that resistance was from the misconception that DPoP usage at the token endpoint meant that access tokens had to be DPoP bound. ",
          "createdAt": "2023-11-16T21:44:44Z",
          "updatedAt": "2023-11-16T21:45:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> > [...] if we don't want to bind the access tokens using DPoP, [...]\r\n> \r\n> DPoP itself specifically has text in the [DPoP Access Token Request](https://www.rfc-editor.org/rfc/rfc9449.html#name-dpop-access-token-request) section that [allows for an AS to issue access tokens that are not DPoP bound](https://www.rfc-editor.org/rfc/rfc9449.html#section-5-9). It says:\r\n> \r\n> > An authorization server MAY elect to issue access tokens that are not DPoP bound, which is signaled to the client with a value of Bearer in the token_type parameter of the access token response per [RFC6750].\r\n> \r\n> And this draft could certainly reiterate that, if it went with the DPoP proof as its PoP mechanism.\r\n> \r\n> There is and has been (it's come up previously) a lot of resistance to that approach though. But maybe that resistance was from the misconception that DPoP usage at the token endpoint meant that access tokens had to be DPoP bound.\r\n\r\nAt least I'd failed to realise this language existed in DPoP and it feels like because of that I dont really see why we shouldn't consider using the DPoP format for the PoP, it feels both generalised enough for other endpoints AND doesn't mandate the tokens issued from the token endpoint are DPoP bound.",
          "createdAt": "2023-11-17T02:51:48Z",
          "updatedAt": "2023-11-17T02:51:48Z"
        },
        {
          "author": "pmhsfelix",
          "authorAssociation": "NONE",
          "body": "So we would use the DPoP token format *and* convey it via the `DPoP` header? Or just use the DPoP token format (and associated nonce management)?",
          "createdAt": "2023-11-17T16:46:00Z",
          "updatedAt": "2023-11-17T16:46:00Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm somehow hesitant to put everything in the headers.\n\nI think we should evaluate to reuse the key from the client attestation as a key for dpop binding and somehow reuse the nonce providing mechanism. As this is a major use case in mind, we should avoid sending multiple nonces, using multiple keys and proofs.",
          "createdAt": "2023-11-17T18:39:14Z",
          "updatedAt": "2023-11-17T18:39:14Z"
        },
        {
          "author": "ju-cu",
          "authorAssociation": "NONE",
          "body": "I also prefer reusing and building upon existing specs, i.e. DPoP (RFC 9449) and Assertion based client authentication (RFC 7521), over copying text. This spec already profiles RFC 7521 but could also use DPoP to satisfy the key-binding of the client attestation. Instead of concatenating two JWTs into a single assertion, the `client_assertion` parameter should hold a key-binding JWT, aka the client attestation JWT. The DPoP HTTP header holds the DPoP proof JWT that serves as the client attestation PoP JWT. In that way, there is no need to define the client attestation PoP JWT in this spec as it can just point to DPoP and use all the mechanisms defined there, including the nonce mechanism. A token request would look like this:\r\n\r\n```http\r\nPOST /token HTTP/1.1\r\nHost: as.example\r\nContent-Type: application/x-www-form-urlencoded\r\nDPoP: eyJ0eXAiOiJkcG9wK2p3dCIsImp3ayI6eyJhbGciOiJFUzI1NiIsImNydiI6IlAtMjU2Iiwia3R5IjoiRUMiLCJ4IjoiaThReW03NFRNUHVLQXVKUGlZczFSZlVsYTVjemNxelVobEpmRHNMdzd0NCIsInkiOiJGQjlUY2ZmeVZDSEpFQjJjejc4NTE2MUE0SmxlTkh2cG44bXhHRldZMlNjIn0sImFsZyI6IkVTMjU2In0.eyJqdGkiOiIzNTc2ODI5Ny1kZWM1LTQ2ZjYtODVlNS1iNzU4MjE2YWI1ZmYiLCJodG0iOiJQT1NUIiwiaHR1IjoiaHR0cHM6Ly9hcy5leGFtcGxlL3Rva2VuIiwiaWF0IjoxNzAwODEyODAwLCJub25jZSI6ImV5SjdTX3pHLmV5SkgwLVouSFg0dy03diJ9.5VuDrkd8RhMRaps_AzJBs2p-_UXXWT4dVHITBHiQxe31GeDq81otnIh3HBQN8_XjS1diHPq1tti1pn55eZdI5g\r\n\r\ngrant_type=authorization_code&\r\ncode=n0esc3NRze7LTCu7iYzS6a5acc3f0ogp4&\r\nclient_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-client-attestation&\r\nclient_assertion=eyJhbGciOiJSUzI1NiIsImtpZCI6IjIyIn0.eyJpc3Mi[...omitted for brevity...].cC4hiUPo[...omitted for brevity...]\r\n\r\n```\r\n\r\nwhere the DPoP proof JWT decodes as follows:\r\n```json\r\nJOSE Header\r\n{\r\n  \"typ\": \"dpop+jwt\",\r\n  \"jwk\" : {\r\n    \"alg\": \"ES256\",\r\n    \"crv\": \"P-256\",\r\n    \"kty\": \"EC\",\r\n    \"x\": \"i8Qym74TMPuKAuJPiYs1RfUla5czcqzUhlJfDsLw7t4\",\r\n    \"y\": \"FB9TcffyVCHJEB2cz785161A4JleNHvpn8mxGFWY2Sc\"\r\n   },\r\n  \"alg\": \"ES256\"\r\n}\r\n\r\nPayload\r\n{\r\n  \"jti\": \"35768297-dec5-46f6-85e5-b758216ab5ff\",\r\n  \"htm\": \"POST\",\r\n  \"htu\": \"https://as.example/token\",\r\n  \"iat\": \"1700812800\",\r\n  \"nonce\": \"eyJ7S_zG.eyJH0-Z.HX4w-7v\"\r\n}\r\n```\r\n\r\nNote, that the DPoP proof JWT MUST contain the `jwk` parameter in the JOSE header according to RFC 9449. In the context of client authentication as defined in this spec, the authorization server MUST use the public key from the `cnf` claim of the `client_assertion` to validate the DPoP proof. The authorization server MAY ignore the `jwk` parameter of the DPoP proof JWT.",
          "createdAt": "2023-11-24T08:21:29Z",
          "updatedAt": "2023-11-24T08:23:35Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ju-cu's description of how the DPoP proof JWT would serve as the client attestation PoP JWT is pretty much in line with how I'd envisioned it. Although I believe it'd need to be a bit less prescriptive about checking the confirmation/pop key and just say that the public key from the `cnf` of Client Attestation JWT must match the key of the `jwk` header of the DPoP proof JWT. This would allow for the _conventional_ processing order with DPoP where the DPoP proof JWT is validated first followed by binding to or checking the binding of things against the key of the DPoP proof JWT. \r\n\r\n",
          "createdAt": "2023-11-29T21:19:56Z",
          "updatedAt": "2023-11-29T21:19:56Z"
        },
        {
          "author": "pmhsfelix",
          "authorAssociation": "NONE",
          "body": "This conversation made me consider the following:\r\n- There is already [RFC 7523](https://www.rfc-editor.org/rfc/rfc7523.html) for **bearer** JWT-based client authentication (as a profile to [RFC 7521](https://www.rfc-editor.org/rfc/rfc7521)).\r\n- However, there isn't any standard for JWT-based client authentication using **holder-of-key** assertions instead of bearer, which is useful for high assurance scenarios.\r\n\r\nSo, what if, instead of having an attestation specific specification, this work was divided into two parts.\r\n- First, a \"sibling\" of RFC 7523 using **DPoP-based holder-of-key JWT assertions**. \r\n- Second, a set of attestation-specific claims, communicating extra attestation-specific information about the client to the AS.\r\n\r\nSeems a bit more work, but the result is also much more general: a mechanism for client authentication using JWT assertions with proof-of-possession, independent of attestation. And by using the DPoP specification, the proof-of-possession part could be relatively easier to specify.\r\n\r\nIf you think this is a conversation worth having, I can create an issue, since this isn't specifically related to this PR.",
          "createdAt": "2023-12-04T16:09:58Z",
          "updatedAt": "2023-12-04T16:09:58Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Please see #67 for a concrete proposal to shift to using DPoP as the PoP syntax for this client authentication method.",
          "createdAt": "2024-01-15T21:29:42Z",
          "updatedAt": "2024-01-15T21:29:42Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "After giving it much thought, I realized that DPoP uses HTTP headers in HTTP requests, and consequently, it makes sense to obtain a nonce within the headers of the received HTTP responses.\r\n\r\nMeanwhile, the nonces we use in OAuth and for endpoint requests utilize GET or POST parameters, and the idea of forcibly using HTTP headers for nonce provisioning doesn't excite me.\r\n\r\nWe already have a nonce endpoint in IETF literature, for example in ACME (RFC8555), and with the aim of creating something highly specialized, reusable in other contexts, efficient, and scalable, I thought of this:\r\n\r\nhttps://github.com/peppelinux/draft-demarco-nonce-endpoint",
          "createdAt": "2024-02-04T00:46:40Z",
          "updatedAt": "2024-02-04T00:46:40Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "We had a discussion on this topic in today's editors call, I posted my thoughts here: https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/issues/59#issuecomment-2304146071",
          "createdAt": "2024-08-22T09:02:39Z",
          "updatedAt": "2024-08-22T09:02:39Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing given we have merged in #99 ",
          "createdAt": "2025-03-03T19:08:04Z",
          "updatedAt": "2025-03-03T19:08:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5nM2UE",
          "commit": {
            "abbreviatedOid": "fa66a20"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-15T07:49:31Z",
          "updatedAt": "2023-11-15T07:49:32Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nThe Client MUST use this new nonce value to create a new Client Attestation PoP JWT and resend the previous request.\r\n```\r\n@pmhsfelix I'm wondering if using Client as defined term in OAuth 2.0. If yes this change is required within the entire text",
              "createdAt": "2023-11-15T07:49:31Z",
              "updatedAt": "2023-11-15T07:49:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5nNIHX",
          "commit": {
            "abbreviatedOid": "fa66a20"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2023-11-15T08:36:46Z",
          "updatedAt": "2023-11-15T08:36:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5nNG8r",
          "commit": {
            "abbreviatedOid": "fa66a20"
          },
          "author": "ju-cu",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "I suggest some normative language for the `nonce` syntax and HTTP error message. All in all good, so green light from me. ",
          "createdAt": "2023-11-15T08:33:54Z",
          "updatedAt": "2023-11-15T10:10:23Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nIn addition, a mismatch between the time reference of a client (e.g. a mobile device) and the time reference of the authorization server, may result in Client Attestation PoP JWT that are never accepted by the authorization server.\r\n```",
              "createdAt": "2023-11-15T08:33:54Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nIncluding a nonce value provided by the authorization server in the Client Attestation PoP JWT MAY be used by authorization servers to limit the lifetime of those proofs, both protecting against attacks and allowing for interoperability with clients with different time references.\r\n```\r\n\"provided\" because it maps the header.",
              "createdAt": "2023-11-15T08:36:55Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 30,
              "body": "Use formative language:\r\n\r\n```suggestion\r\nIf the authorization server requires the use of nonces, the authorization server MUST return an HTTP response with the `400` status and an `error` field with the value `\"use_attestation_nonce\"`, when the Client Attestation PoP JWT present in the HTTP request does not contain a valid nonce.\r\n```",
              "createdAt": "2023-11-15T08:39:18Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nThe server provided nonce must be included in the `nonce` JWT payload claim, as a string.\r\n```\r\nDoesn't \"JWT payload claim\" imply that the data is JSON?",
              "createdAt": "2023-11-15T08:42:15Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nAuthorization servers MAY also include the `Attestation-Nonce` in success responses, as a way to communicate newer nonce values to clients.\r\n```",
              "createdAt": "2023-11-15T08:43:02Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 50,
              "body": "```suggestion\r\nResponses that include the `Attestation-Nonce` HTTP header should be uncacheable (e.g., using `Cache-Control: no-store` in response to a GET request) to prevent returning cached, stale nonce values in subsequent requests.\r\n```",
              "createdAt": "2023-11-15T08:49:45Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 35,
              "body": "Repeating expression:\r\n```suggestion\r\nThe following non-normative example represents a non-success response, including the new nonce in the `Attestation-Nonce` header.\r\n```",
              "createdAt": "2023-11-15T08:51:51Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nThe following non-formative example shows a 200 OK response providing a new nonce value.\r\n```",
              "createdAt": "2023-11-15T08:54:20Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            },
            {
              "originalPosition": 66,
              "body": "I believe this sentence is missing a formative language. We may even add it above where the`nonce` claim is originally defined.\r\n",
              "createdAt": "2023-11-15T08:55:50Z",
              "updatedAt": "2023-11-15T10:10:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5nVo7P",
          "commit": {
            "abbreviatedOid": "fa66a20"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "just editorial, consider it approved",
          "createdAt": "2023-11-16T07:59:42Z",
          "updatedAt": "2023-11-16T08:02:42Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nThis section outlines a method that utilizes server-generated opaque nonces to restrict the lifespan of a Client Attestation Proof of Possession (PoP) JWT., similar to the one defined in section 8 of {{RFC9449}}.\r\n```",
              "createdAt": "2023-11-16T07:59:43Z",
              "updatedAt": "2023-11-16T08:02:42Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nWithout this mechanism, a malicious entity, which could include the end-user, controlling the client can generate Client Attestation Proof of Possession (PoP) JWTs for unrestricted future use. Moreover, a discrepancy between the time reference of a benign client (like a mobile device) and the authorization server's time reference could lead to Client Attestation PoP JWTs that the authorization server never accepts.\r\n```",
              "createdAt": "2023-11-16T08:01:05Z",
              "updatedAt": "2023-11-16T08:02:42Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nThis requirement is communicated to the Client by having the authorization server return an HTTP response with the `400` status and an `error` field with the value `\"use_attestation_nonce\"`, when the Client Attestation PoP JWT present in the HTTP request does not contain a valid nonce.\r\n```",
              "createdAt": "2023-11-16T08:01:34Z",
              "updatedAt": "2023-11-16T08:02:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 65,
      "id": "PR_kwDOJaEkaM5gJfwG",
      "title": "Update draft-ietf-oauth-attestation-based-client-auth.md",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/65",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "affiliation status for IETF still unclear",
      "createdAt": "2023-11-22T16:04:05Z",
      "updatedAt": "2023-11-22T19:37:35Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "4375d894ce7e58c91d5ed282cfd733dd48417812",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "affiliation",
      "headRefOid": "edd6ad8fb1b66c78af04b121fb1102c2ba7a37ea",
      "closedAt": "2023-11-22T19:37:35Z",
      "mergedAt": "2023-11-22T19:37:35Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "efa100ca094afee2303275bd8f518b81c9a0c97a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5oBqUA",
          "commit": {
            "abbreviatedOid": "edd6ad8"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-22T19:37:30Z",
          "updatedAt": "2023-11-22T19:37:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 67,
      "id": "PR_kwDOJaEkaM5kIFOQ",
      "title": "feat: initial proposal to use dpop",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/67",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "**DRAFT PR FOR DISCUSSION**\r\n\r\n## \ud83d\udcd1 Description\r\n\r\nFollowing discussion across multiple issues and PR's including #59 and #64. This PR represents a draft proposal to use the DPoP HTTP Header as defined in [RFC9449](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop-16#name-the-dpop-http-header) instead of the client attestation pop.\r\n\r\n## Preview Link\r\n\r\n[click here for rendered preview of PR](https://vcstuff.github.io/draft-ietf-oauth-attestation-based-client-auth/tl/dpop-proof/draft-ietf-oauth-attestation-based-client-auth.html)",
      "createdAt": "2024-01-15T21:23:08Z",
      "updatedAt": "2024-03-28T03:02:34Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "efa100ca094afee2303275bd8f518b81c9a0c97a",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/dpop-proof",
      "headRefOid": "833eea8467ea257c1efdfa109546db2b14b46300",
      "closedAt": "2024-03-28T03:02:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "A similar vision was brought by me here\r\n~https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/67/files~ sorry, wrong url, see: https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/issues/45\r\n\r\ngenerally I agree with this, however we still have an issue with DPoP, as explained below.\r\n\r\nThere are discussions about the requirement to provide more than a single wallet attestation in eIDAS.\r\nat the same time, for the purpose of a global standard, I see the requirement to provide a way to allow multiple client_assertion, where an ecosystem might require this, for future features.\r\n\r\nat the current stage, we can provide multiple client_assertion in a single url (see [this](https://github.com/openid/OpenID4VCI/issues/149)) providing their PoP. Using DPoP it is possible for HTTP to carry multiple headers with the same name. This is defined in the HTTP/1.1 specification (RFC 2616). According to the specification, multiple message-header fields with the same field-name may be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list. It must be possible to combine the multiple header fields into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma.\r\n\r\nhowever this approach doesn't give the binding of which PoP is related to which client attestation, requiring to the entity that evaluates assertions+pop to parse and validate them in a loop. This loop has computational costs that can be avoided by design, as the current specs allows.\r\n\r\nanother issue could be that HTTP Header maximum size configured in the httpd services could represent a limit where multiple DPoP are provided. Anyway I feel optimistic about each the DPoP payload size and the number of http headers parameters included in a single http request.\r\n\r\njust to be clear:\r\n\r\nI prefer DPoP and I love to reuse things without redefining new one.\r\nAt the same time the DPoP HTTP header doesn't give a proper mapping to the client assertion where multiple client assertion are provided. The real-world may require this and we should take the best decision in term of design\r\n\r\n",
          "createdAt": "2024-01-16T10:45:01Z",
          "updatedAt": "2024-01-18T07:57:59Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for doing the work on this @tplooker! I am very supportive of this direction. I do wonder if it'd be worthwhile to include some explanatory text with this change about the fact that use of a DPoP proof does not mandate bound access tokens? It was a point of confusion/contention in prior discussions (eg https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/64#issuecomment-1815362871, https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/64#issuecomment-1815668038, etc) which might benefit from a brief mention in this document. \r\n",
          "createdAt": "2024-01-16T14:47:10Z",
          "updatedAt": "2024-01-16T17:43:14Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I understand DPoP correctly, this proposals leads to a situation where authentication with an client attestation always leads to an access token bound to the public key in the 'cnf' claim of the attestation.  \r\n\r\nThis means, clients must always bind their access tokens and cannot use different keys for client authentication and the key binding of their access tokens. \r\n\r\nIs that correct? ",
          "createdAt": "2024-01-18T03:05:05Z",
          "updatedAt": "2024-01-18T03:05:05Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> If I understand DPoP correctly, this proposals leads to a situation where authentication with an client attestation always leads to an access token bound to the public key in the 'cnf' claim of the attestation.\r\n\r\nNo that is not entirely correct, as @bc-pi pointed out [in this comment](https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/64#issuecomment-1815362871) just because you are using a DPoP proof in the token request to convey the client attestation PoP doesn't mean a DPoP enabled access token has to be issued as a response. You are correct though that in the event a DPoP access token is issued, the access token will be bound to the one in the `cnf` claim of the client attestation which I personally find a useful simplification. What are the usecases for wanting a seperate key for client auth vs token binding (in the event it is used)?\r\n",
          "createdAt": "2024-01-18T05:12:48Z",
          "updatedAt": "2024-01-18T05:12:48Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am pretty strongly against this mechanism. I think it is ok to have this as an optimization but mandating using the same PoP for client attestation and DPoP overloads both mechanisms and limits the use-cases.\r\n\r\nPlease see my comment above to ensure you understand what we are proposing here, I don't think this significantly limits use cases and on the flip side it significantly reduces what needs to be defined in this draft. If you still feel the same can you please elaborate on which usecases you think this would limit?",
          "createdAt": "2024-01-18T05:14:55Z",
          "updatedAt": "2024-01-18T05:14:55Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "Is there any reaction about the potential requirement to provide multiple client assertions in a request and my previous comment, shown below:\r\n\r\n> however this approach doesn't give the binding of which PoP is related to which client attestation, requiring to the entity that evaluates assertions+(d)pop to parse and validate them in a loop. This loop has computational costs that can be avoided by design, as the current specs allows.",
          "createdAt": "2024-01-18T08:00:19Z",
          "updatedAt": "2024-01-18T08:00:19Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "> A similar vision was brought by me here ~https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/67/files~ sorry, wrong url, see: #45\r\n> \r\n> generally I agree with this, however we still have an issue with DPoP, as explained below.\r\n> \r\n> There are discussions about the requirement to provide more than a single wallet attestation in eIDAS. at the same time, for the purpose of a global standard, I see the requirement to provide a way to allow multiple client_assertion, where an ecosystem might require this, for future features.\r\n> \r\n> at the current stage, we can provide multiple client_assertion in a single url (see [this](https://github.com/openid/OpenID4VCI/issues/149)) providing their PoP. Using DPoP it is possible for HTTP to carry multiple headers with the same name. This is defined in the HTTP/1.1 specification (RFC 2616). According to the specification, multiple message-header fields with the same field-name may be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list. It must be possible to combine the multiple header fields into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma.\r\n> \r\n> however this approach doesn't give the binding of which PoP is related to which client attestation, requiring to the entity that evaluates assertions+pop to parse and validate them in a loop. This loop has computational costs that can be avoided by design, as the current specs allows.\r\n> \r\n> another issue could be that HTTP Header maximum size configured in the httpd services could represent a limit where multiple DPoP are provided. Anyway I feel optimistic about each the DPoP payload size and the number of http headers parameters included in a single http request.\r\n> \r\n> just to be clear:\r\n> \r\n> I prefer DPoP and I love to reuse things without redefining new one. At the same time the DPoP HTTP header doesn't give a proper mapping to the client assertion where multiple client assertion are provided. The real-world may require this and we should take the best decision in term of design\r\n\r\nHi Giuseppe,\r\nthe proposed idea in the eIDAS discussion EPIC-09 is the wrong way. Currently client attestation supports one attestation and that's the way it should stay. I have outlined my position here: https://github.com/openid/OpenID4VCI/issues/215",
          "createdAt": "2024-01-18T10:06:40Z",
          "updatedAt": "2024-01-18T10:06:40Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> No that is not entirely correct, as @bc-pi pointed out [in this comment](https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/64#issuecomment-1815362871) just because you are using a DPoP proof in the token request to convey the client attestation PoP doesn't mean a DPoP enabled access token has to be issued as a response.\n\nThe text @bc-pi is referring to leaves it at the discretion of the AS to decide whether the access token is key bound. How would the client influence that decision?",
          "createdAt": "2024-01-18T10:54:49Z",
          "updatedAt": "2024-01-18T10:59:26Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> The text @bc-pi is referring to leaves it at the discretion of the AS to decide whether the access token is key bound. How would the client influence that decision?\r\n\r\nI think that is a general question for DPoP, but one that is important to answer. If by influence you mean the client is able to communicate to the AS that it supports dpop bound access tokens then I would agree, but at the end of the day the decision as to whether to issue a DPop enabled access token is still always at the discretion of the AS. With regard to how this would be achieved practically I would assume client metadata is the most effective way for the client to communicate this and [Section 5.2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop-16#section-5.2) has the `dpop_bound_access_tokens` element registered. Although the definition for this parameter might not intuitively appear to fit, I think the intended normative requirements on the AS do? Specifically this statement which applies to this metadata elements value:\r\n\r\n> If true, the authorization server MUST reject token requests from this client that do not contain the DPoP header.\r\n\r\nAlternatively if we don't think this is sufficient perhaps we can consider registering a new client metadata element.\r\n\r\nPerhaps @bc-pi you have some further thoughts on this?",
          "createdAt": "2024-01-18T20:19:33Z",
          "updatedAt": "2024-01-18T20:19:33Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is there really a reason the client would need to influence that decision? I'd imagine the AS would issue the access token based on expectations/knowledge of the RS(s) it's intended for. ",
          "createdAt": "2024-01-19T20:22:35Z",
          "updatedAt": "2024-01-19T20:22:35Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is there really a reason the client would need to influence that decision? I'd imagine the AS would issue the access token based on expectations/knowledge of the RS(s) it's intended for.\r\n\r\nWith the current revision of the spec (before this PR), a client can use an attestation to just authenticate. If it wants a DPoP bound access token, it would add a DPoP header to the request. With the proposal in this PR, this is no longer possible. This effectively means every client using client attestation must also implement DPoP and use it if the AS decides the access token must be key bound. \r\n\r\nAlso, the client does not have a choice to use different keys for attestation and DPoP. I could think of situations where the DPoP key is managed in a local security module to achieve better performance for subsequent API calls whereas the client attestation key lives in a remote HSM for higher security, which adds significant latency to every signing operation. With the new proposal, the application's performance would suffer simply because any API call might also require a remote signing operation for the DPoP proof. \r\n\r\nAlso, I would like to understand whether the proposed approach would work with PAR. We will most likely need attestation based client authentication at the PAR endpoint. I assume the DPoP header would be used to perform the authentication only. Is that correct?",
          "createdAt": "2024-01-20T01:02:55Z",
          "updatedAt": "2024-01-20T01:02:55Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n>\r\n> With the current revision of the spec (before this PR), a client can use an attestation to just authenticate. If it wants a DPoP bound access token, it would add a DPoP header to the request. With the proposal in this PR, this is no longer possible. This effectively means every client using client attestation must also implement DPoP and use it if the AS decides the access token must be key bound.\r\n\r\nTrue but ultimately the need to use key bound access token comes from the RS so the client would have to already be capable. I don't think it'd really be an issue in practice. But maybe I'm wrong. Some sort of signaling could be added to this - metadata as Tobias mentioned or a new claim in the DPoP proof or similar. \r\n\r\n> \r\n> Also, the client does not have a choice to use different keys for attestation and DPoP. I could think of situations where the DPoP key is managed in a local security module to achieve better performance for subsequent API calls whereas the client attestation key lives in a remote HSM for higher security, which adds significant latency to every signing operation. With the new proposal, the application's performance would suffer simply because any API call might also require a remote signing operation for the DPoP proof.\r\n\r\nIt is true that this PR doesn't allow the client to use of different keys for attestation and DPoP. I don't know if the kind of scenario you describe is likely enough to warrant the extra complexity of requiring two proofs in the other more common and simpler cases. I tend to aim for simplicity as much as possible/appropriate. \r\n\r\n> \r\n> Also, I would like to understand whether the proposed approach would work with PAR. We will most likely need attestation based client authentication at the PAR endpoint. I assume the DPoP header would be used to perform the authentication only. Is that correct?\r\n\r\nIt would work with PAR the same as at the token endpoint as far as I understand it. The authz code would be key bound as a result too but that'd be invisible to the client who anyway needs to present the same attestation auth and proof when subsequently exchange that auth code. So it'd just work while adding a bit of extra security to the code. \r\n",
          "createdAt": "2024-01-21T16:37:11Z",
          "updatedAt": "2024-01-21T16:37:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> With the current revision of the spec (before this PR), a client can use an attestation to just authenticate. If it wants a DPoP bound access token, it would add a DPoP header to the request. With the proposal in this PR, this is no longer possible. This effectively means every client using client attestation must also implement DPoP and use it if the AS decides the access token must be key bound.\r\n\r\nI think the most important point here is highlighted by @bc-pi. In the situation where the AS requires DPoP bound access tokens as per an RS policy, whether we use the DPoP proof syntax in this spec or not, it doesn't change the fact that the client won't be able to get an access token it can actually use with the RS.\r\n\r\nThe only potential gap I see (which I think is highly unlikely) is in the event a client supports this client authentication method, but doesn't support DPoP access tokens AND the RS + AS supports both DPoP and bearer based access tokens, the situation could arise where the client might be sent back a DPoP access token (based on the DPoP header implying support in the token request) which it can't use, when it could have been sent a bearer token. Again as I said above, I find this situation highly unlikely, but I think it could be easily resolved through additional client metadata.\r\n\r\n> Also, the client does not have a choice to use different keys for attestation and DPoP. I could think of situations where the DPoP key is managed in a local security module to achieve better performance for subsequent API calls whereas the client attestation key lives in a remote HSM for higher security, which adds significant latency to every signing operation. With the new proposal, the application's performance would suffer simply because any API call might also require a remote signing operation for the DPoP proof.\r\n\r\nI'm also wary as to how common this use case is and whether the complexity it creates is justifiable. To play the devils advocate, this proposal as it currently stands creates an efficient way (when DPoP access tokens are used), to authenticate that the key the DPoP access token will be bound to, is clearly authenticated back to the client (through the client attestation). If instead we want to continue to support different keys for client authentication and DPoP token binding, the question then becomes how do we get the same assurance e.g that the DPoP key is authenticated for the client? The client attestation PoP, to use the terminology pre this PR would have to somehow reference and authenticate the seperate DPoP key. \r\n\r\n> It would work with PAR the same as at the token endpoint as far as I understand it. The authz code would be key bound as a result too but that'd be invisible to the client who anyway needs to present the same attestation auth and proof when subsequently exchange that auth code. So it'd just work while adding a bit of extra security to the code.\r\n\r\nThis is my understanding too.",
          "createdAt": "2024-01-21T21:46:00Z",
          "updatedAt": "2024-01-21T21:46:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "As a consequence of discussing some of the advantages this PR brings, a new usecase/requirement surfaced which has been captured in PR #69",
          "createdAt": "2024-01-26T03:42:09Z",
          "updatedAt": "2024-01-26T20:12:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favour of #74 ",
          "createdAt": "2024-03-28T03:02:34Z",
          "updatedAt": "2024-03-28T03:02:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5ssQM7",
          "commit": {
            "abbreviatedOid": "d963646"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-16T14:19:03Z",
          "updatedAt": "2024-01-16T14:19:03Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "typo fix\r\n```suggestion\r\n2. The DPoP proof JWT present in the DPoP HTTP header MUST be valid in all other respects per the processing rules defined in {{RFC9449}}.\r\n```",
              "createdAt": "2024-01-16T14:19:03Z",
              "updatedAt": "2024-01-16T14:19:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ssXYo",
          "commit": {
            "abbreviatedOid": "d963646"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-16T14:27:04Z",
          "updatedAt": "2024-01-16T14:27:04Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "What is/was the reason behind this recommendation? I suspect many/most ASs typically do processing of the DPoP proof header first followed by 'application' layer stuff like binding to or checking the binding of other artifacts against the key of the DPoP proof JWT. I'd like to avoid a recommendation against the likely conventional processing pipeline unless there's a concrete reason for it. \r\n\r\n```suggestion\r\n```",
              "createdAt": "2024-01-16T14:27:04Z",
              "updatedAt": "2024-01-16T14:27:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5ssbMm",
          "commit": {
            "abbreviatedOid": "d963646"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-16T14:31:45Z",
          "updatedAt": "2024-01-16T14:31:45Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "previously missing word?\r\n\r\n```suggestion\r\n4. The JWT MUST contain an \"cnf\" claim conforming to {{RFC7800}} that conveys the key to be used for producing the DPoP HTTP header for client authentication with an authorization server. The key MUST be expressed using the \"jwk\" representation.\r\n```",
              "createdAt": "2024-01-16T14:31:45Z",
              "updatedAt": "2024-01-16T14:31:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5s4TO3",
          "commit": {
            "abbreviatedOid": "d963646"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I am pretty strongly against this mechanism. I think it is ok to have this as an optimization but mandating using the same PoP for client attestation and DPoP overloads both mechanisms and limits the use-cases.",
          "createdAt": "2024-01-17T08:01:38Z",
          "updatedAt": "2024-01-17T08:01:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5tCUXP",
          "commit": {
            "abbreviatedOid": "3b845b9"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I have discussed this with my colleagues and we came to the following conclusions:\r\n\r\n## status quo:\r\n\r\npreparation: potentially fetch 2x nonce\r\nToken Request: client_attestation + client_attestation_pop + Dpop proof header\r\nToken Response: Dpop-bound access token\r\n\r\n## proposed:\r\n\r\npreparation: potentially fetch 1x nonce\r\nToken Request: client_attestation + Dpop proof header (client_attestation.cnf == Dpop.header.jwk)\r\nToken Response: Dpop-bound access token\r\n\r\n## con:\r\n- concepts are tightly coupled, key must be the same if both concepts want to be used, may have unforeseeable disadvantages\r\n- benefits in auth code flow are unclear if I would use client attestation at PAR endpoint\r\n- jwk present in the client attestation JWT is duplicated to jwk header in Dpop proof\r\n- refresh tokens are automatically dpop-bound?\r\n\r\n## pro: \r\n- only fetch 1x nonce\r\n- do one less key/PoP operation / generate one less key\r\n- wallet attestation makes only sense when coupled with Dpop currently\r\n- leverage better assurance of client_attestation key for Dpop (may be hw-bound)\r\n- draft may leverage the Dpop nonce fetching (although its ugly ;) ) -> may avoid https://github.com/vcstuff/draft-ietf-oauth-attestation-based-client-auth/pull/64\r\n\r\nFor me, the advantages are bigger, so I'm **supportive** of this. But I would like to get more feedback and understand @Sakurann concerns. Also, some more editorial work may be needed",
          "createdAt": "2024-01-18T10:12:01Z",
          "updatedAt": "2024-01-18T10:12:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5tqQzg",
          "commit": {
            "abbreviatedOid": "d963646"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-23T19:48:09Z",
          "updatedAt": "2024-01-23T19:48:10Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "As suggested by the diff, I really just updated the language in this particular section from s/Client Attestation PoP/DPoP HTTP header. I'm ok with removing this recommendation based on your feedback.",
              "createdAt": "2024-01-23T19:48:09Z",
              "updatedAt": "2024-01-23T19:48:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5t5Rtg",
          "commit": {
            "abbreviatedOid": "833eea8"
          },
          "author": "awoie",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "I'm also supportive of this PR since it simplifies things since I'm unclear about the use cases for which the proposed approach won't work. It is actually a good higher assurance enforcing function.",
          "createdAt": "2024-01-25T13:19:02Z",
          "updatedAt": "2024-01-25T13:21:15Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I don't think the second sentence is necessary since it is implied by the former sentence.\r\n```suggestion\r\nThe value of the \"client_assertion\" parameter contains a single JWT known as the client attestation JWT as defined defined in [](#client-attestation-jwt).\r\n```",
              "createdAt": "2024-01-25T13:19:02Z",
              "updatedAt": "2024-01-25T13:19:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5t9tqr",
          "commit": {
            "abbreviatedOid": "833eea8"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-26T00:00:17Z",
          "updatedAt": "2024-01-26T00:00:17Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I think we would want this constraint wouldn't we? Why would you like to remove it?",
              "createdAt": "2024-01-26T00:00:17Z",
              "updatedAt": "2024-01-26T00:00:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5uRGQH",
          "commit": {
            "abbreviatedOid": "833eea8"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-29T23:45:43Z",
          "updatedAt": "2024-01-29T23:45:43Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Didn't read your original comment just the suggestion, while I agree I think this makes the normative requirement a little more explicit. I took the language structure from [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523#section-2.2)\r\n\r\n> The value of the \"client_assertion\" parameter contains a single JWT.\r\n   It MUST NOT contain more than one JWT.\r\n\r\nI'm ok with removing this additional sentence though.",
              "createdAt": "2024-01-29T23:45:43Z",
              "updatedAt": "2024-01-29T23:45:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 74,
      "id": "PR_kwDOJaEkaM5q_2E4",
      "title": "feat: initial proposal to use http headers",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/74",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "## \ud83d\udcd1 Description\r\n\r\nBased on the discussions had at IETF 119 in the OAuth WG, this PR attempts to make the following changes to the draft\r\n\r\n- Move away from usage of the assertion framework defined in RFC 7521 and RFC 7523 for conveying the client attestation and client attestation pop.\r\n- Instead use two newly defined HTTP headers OAuth-Client-Attestation and OAuth-Client-Attestation-PoP for conveyance in an HTTP request, akin to how DPoP works.\r\n- Explicitly mention this mechanism could be used in a variety of places including with a resource server.\r\n\r\nNote, there are still many outstanding items I would like to add, however I felt this PR was already big enough as it is, these include\r\n\r\n- Error responses for the token endpoint #73\r\n- Optimisation for when this mechanism is used with DPoP to avoid having to send two PoP's\r\n- Formalising whether this mechanism still constitutes a form of client authentication",
      "createdAt": "2024-03-28T01:21:01Z",
      "updatedAt": "2024-05-29T06:45:30Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "ac2eec4c4bcc3e206aca6df55910e5dc40da2eac",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/header-syntax-proposal",
      "headRefOid": "c6bdd4c68242841db67e999cd3fcdf96c712c717",
      "closedAt": "2024-05-29T06:45:25Z",
      "mergedAt": "2024-05-29T06:45:25Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "2b711a053edd47a06be903cd116a3996dd689a5f"
      },
      "comments": [
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "For some reason it seems to not create an html version?\r\n\r\nThis is the rendered text:\r\nhttps://vcstuff.github.io/draft-ietf-oauth-attestation-based-client-auth/tl/header-syntax-proposal/draft-ietf-oauth-attestation-based-client-auth.txt\r\n",
          "createdAt": "2024-03-28T06:36:38Z",
          "updatedAt": "2024-03-28T06:36:38Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "I think there were potential objections mentioned about moving to headers as to whether we'd run into size limits (I think 8 KB was mentioned as a common restriction) and people felt jwts with embedded x5c headers etc may get close to these limits?",
          "createdAt": "2024-03-28T12:58:31Z",
          "updatedAt": "2024-03-28T12:58:31Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "@jogu indeed. We may have a client attestation with an huge x509 certificate chain or an openid federation trust chain with several metadata, trust marks and jwks. \r\n\r\nI don't see the benefit of moving from what it is actually more efficient (wa~wa-pop)\r\n\r\nmore over, technically we can have multiple client_assertions that embedes their pop (using ~), while having multiple http headers that divide attestation from pop forces the implementations to loop all the assertions and all the pop to find the matching ones",
          "createdAt": "2024-03-28T16:28:44Z",
          "updatedAt": "2024-03-28T16:28:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Added client instance definition and updated to use US based spelling of authorization instead of authorisation.",
          "createdAt": "2024-04-03T19:03:16Z",
          "updatedAt": "2024-04-03T19:03:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "@jogu @peppelinux I can understand the desire to want to use X.509 certificates to validate the client assertion (e.g as an alternative key resolution mechanism to resolving a JWKS document from a domain), however I don't see how the certificate chain would be more then 1 certificate (maybe 2) in length (bearing in mind the root certificate(s) would be communicated to the issuer out of band and pre-trusted for the client). W.r.t other aspects of the client attestation or client attestation pop being too big for an HTTP header could you elaborate on what you see as the contents of your attestation @peppelinux? Because IIUC you perhaps want to use the client attestation to convey all client metadata? If that is the case IMO the client attestation isn't for this purpose, client metadata should continue to be communicated outside of these attestations with the pre-existing mechanisms we already have defined.\r\n\r\nFinally even if we did begin to encroach on header payload limits with a client attestation, we aren't talking about hard limits here, rather just the default maximums that common web server platforms have configured, which can always be adjusted. ",
          "createdAt": "2024-04-03T19:10:52Z",
          "updatedAt": "2024-04-03T19:10:52Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "there some point for clarification\r\n\r\n1. assertion weight: a client assertion may have a x5c or an openid federation trust chain within its JWT header. This is an issuer's choice, allowed by RFC 7515 that might be not supported by httpd maximum header body size, that's a deployment/configuration choice that might be different within different domains.\r\n2. chain length: it could be assumed that a chain may not exceed 2 or 3 certificate breaks. This depends on the number of intermediates, an aspect that falls outside the technical specification and is determined by the federation's topology and composition.\r\n3. client metadata: we have some required claims in the wallet attestations and the possibility to include any other custom claim or any other claims pertaining the wallet capabilities or anything else related to the trust framework. My comment is not related to assertion payload, but to the previous point 1 and 2. However, the payload also impacts in the assertion weight, as pointed out at point 1.\r\n\r\nThe missing point concerns the processing of multiple DPoP tokens within the same request. Handling multiple DPoP tokens necessitates a loop to identify the one that matches a specific assertion. This introduces additional computational and development efforts not present in the current approach (WA~WA-POP), which directly associates an assertion with its proof of possession (PoP), facilitating a straightforward and efficient identification of matching pairs.",
          "createdAt": "2024-04-04T05:47:19Z",
          "updatedAt": "2024-04-04T05:49:22Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> assertion weight: a client assertion may have a x5c or an openid federation trust chain within its JWT header. This is an issuer's choice, allowed by RFC 7515 that might be not supported by httpd maximum header body size, that's a deployment/configuration choice that might be different within different domains.\r\n\r\nOk great so do we agree that this isn't an issue because servers are freely able to re-configure the max header size based on their application? Because it isn't a hard limit.",
          "createdAt": "2024-04-05T03:04:37Z",
          "updatedAt": "2024-04-05T03:04:37Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> chain length: it could be assumed that a chain may not exceed 2 or 3 certificate breaks. This depends on the number of intermediates, an aspect that falls outside the technical specification and is determined by the federation's topology and composition.\r\n\r\nUnderstood but based on the above point is this actually an issue if the limit on header size isn't a hard limit?",
          "createdAt": "2024-04-05T03:05:12Z",
          "updatedAt": "2024-04-05T03:05:12Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> The missing point concerns the processing of multiple DPoP tokens within the same request. Handling multiple DPoP tokens necessitates a loop to identify the one that matches a specific assertion. This introduces additional computational and development efforts not present in the current approach (WA~WA-POP), which directly associates an assertion with its proof of possession (PoP), facilitating a straightforward and efficient identification of matching pairs.\r\n\r\nRight but to be clear, the current draft does not handle multiple wallet attestations either though so I think this a new requirement that we should discuss separately, would you mind opening a seperate issue?",
          "createdAt": "2024-04-05T03:06:36Z",
          "updatedAt": "2024-04-05T03:06:53Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "The issue extends beyond the realm of multiple wallet attestations, as there could also be multiple DPoP tokens involved.\r\n\r\nAn additional consideration, which we have not yet fully addressed but may emerge as a future requirement, is the scenario where a wallet instance operates under more than one trust framework, necessitating specialized assertions for each. While we have consciously chosen to limit the scope to a single wallet attestation to simplify implementation, it's important to acknowledge that this decision does not preclude the possibility of requiring multiple assertions in the future. Implementers may need to adapt or extend the specification to accommodate such needs. However, to avoid digressing further, let's focus on the matter of handling multiple DPoP headers for now.\r\n\r\nThe approach currently documented, which aims to streamline the process by limiting it to a single attestation, is designed to offer the same benefits while minimizing computational overhead.",
          "createdAt": "2024-04-05T07:08:00Z",
          "updatedAt": "2024-04-05T07:08:00Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "> > assertion weight: a client assertion may have a x5c or an openid federation trust chain within its JWT header. This is an issuer's choice, allowed by RFC 7515 that might be not supported by httpd maximum header body size, that's a deployment/configuration choice that might be different within different domains.\r\n> \r\n> Ok great so do we agree that this isn't an issue because servers are freely able to re-configure the max header size based on their application? Because it isn't a hard limit.\r\n\r\nWhile it is possible to reconfigure these options, it is important to keep default values of the wide-spread implementations in mind to allow an easy path for adoption.\r\n\r\nI took the time to look at some of the frameworks I would say are good indicators:\r\n- nginx: [link](https://nginx.org/en/docs/http/ngx_http_core_module.html#large_client_header_buffers) --> 8KB for 1 header max\r\n- envoy (used in istio): [link](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto) --> 60 KB for headers\r\n- node.js: [link](https://nodejs.org/api/http.html#httpmaxheadersize)  --> 16KB for headers\r\n- traefik: [link](https://github.com/traefik/traefik/issues/8846) --> re-uses go/http: 1MB for headers\r\n\r\n--> After looking at this, I would say we can go with headers",
          "createdAt": "2024-04-05T07:33:39Z",
          "updatedAt": "2024-04-05T07:33:39Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "An OpenID Federation trust chain with two intermediates, the trust anchor entity configuration with a long list of trust mark issuers and the leaf entity configuration with a very verbose configuration, such as an AS + Openid4VCI + OpenID4VP (considering an EAA provider), with policies and a consistent number of trust mark might be 20KB.\r\n\r\nA serialized X.509 certificate chain, with 4 intermediates, custom extensions and QWACs ... Considering each certificate up to 2.2KB, might it be 8.8KB? \r\n\r\n(please, consider that openid federation brings policy languages, trust marks and multiple protocol specific metadata)\r\n\r\nI'm worried about these aspects:\r\n\r\n1. loop required for parse/matching the correct DPoP when multiple DPoP are present, while WIA~WIA-POP doesn't bring this problem. What's the benefit of having this breaking change that reduce the flexibility while increasing the complexity?\r\n2. size limitations: Do we have to imagine to standardize something upon the assumption that a federation topology should not have more than 2 or 4 or 8 intermediates, since this decision is out of scope on this specification.\r\n\r\n\r\n",
          "createdAt": "2024-04-05T08:57:18Z",
          "updatedAt": "2024-04-05T08:59:16Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "A bit off-topic for the current discussion:\r\nWe need to fix the examples - they are way too long which breaks the rendering/conversion and will cause problems with the datatracker. I do believe that this is also the reason why the html file was not created.",
          "createdAt": "2024-04-05T14:04:43Z",
          "updatedAt": "2024-04-05T14:05:20Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that rfc9449 does not allow for multiple DPoP headers. It could maybe have been stated more clearly but is kinda implied and was absolutely the intent of the RFC overall and specific text like https://www.rfc-editor.org/rfc/rfc9449.html#section-4.3-2.2",
          "createdAt": "2024-04-05T16:25:54Z",
          "updatedAt": "2024-04-05T16:25:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> loop required for parse/matching the correct DPoP when multiple DPoP are present, while WIA~WIA-POP doesn't bring this problem. What's the benefit of having this breaking change that reduce the flexibility while increasing the complexity?\r\n\r\n@peppelinux as I implied with my earlier comment, the current draft text doesn't support multiple attestations so I don't view this proposal to shift to headers as removing functionality, it appears this is a new usecase and I think we should discuss it in a seperate issue.\r\n\r\n> size limitations: Do we have to imagine to standardize something upon the assumption that a federation topology should not have more than 2 or 4 or 8 intermediates, since this decision is out of scope on this specification.\r\n\r\nNo I dont think we do, what was identified above is that there is no size limit on headers in HTTP rather defaults that servers apply which can be adjusted, in reality web servers also apply limits to the body of an HTTP request (although often much larger then what is allocated for headers).",
          "createdAt": "2024-04-07T21:31:10Z",
          "updatedAt": "2024-04-07T21:31:10Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed with @paulbastian, I will add an implementation consideration around the default size limits for HTTP headers.",
          "createdAt": "2024-04-15T17:10:18Z",
          "updatedAt": "2024-04-15T17:10:18Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "@tplooker what about using compressed values?\r\n\r\nunfortunately this sounds like giving a solution that may bring other problems, at the same time we can consider zlib (RFC 1950) for doing this.",
          "createdAt": "2024-04-15T17:25:42Z",
          "updatedAt": "2024-04-15T17:25:42Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "Something broke with linking the html rendered versions properly\r\n\r\nRendered html: https://vcstuff.github.io/draft-ietf-oauth-attestation-based-client-auth/tl/header-syntax-proposal/draft-ietf-oauth-attestation-based-client-auth.html\r\n",
          "createdAt": "2024-05-16T09:10:19Z",
          "updatedAt": "2024-05-16T09:10:19Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It just (re)occurred to me that specs defining new HTTP headers (which the cool kids call fields nowadays) are supposed to request their registration in the [Hypertext Transfer Protocol (HTTP) Field Name Registry](https://www.iana.org/assignments/http-fields/http-fields.xhtml). I don't want to hold up this PR for this but will create an issue from this comment so as not to lose track of it. ",
          "createdAt": "2024-05-21T16:47:04Z",
          "updatedAt": "2024-05-21T16:47:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM51lZKj",
          "commit": {
            "abbreviatedOid": "5c172ff"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T06:37:19Z",
          "updatedAt": "2024-04-02T06:37:19Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Add Client Instance as a term",
              "createdAt": "2024-04-02T06:37:19Z",
              "updatedAt": "2024-04-02T06:37:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM51lbAj",
          "commit": {
            "abbreviatedOid": "5c172ff"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T06:41:28Z",
          "updatedAt": "2024-04-02T06:41:28Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Add Motivation, public clients need to authenticate etc..\r\nthis spec for authenticating client instances of public clients",
              "createdAt": "2024-04-02T06:41:28Z",
              "updatedAt": "2024-04-02T06:42:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM51lc32",
          "commit": {
            "abbreviatedOid": "5c172ff"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T06:44:33Z",
          "updatedAt": "2024-04-02T06:44:33Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "add that this can be used as client authentication mechanisms for the AS",
              "createdAt": "2024-04-02T06:44:33Z",
              "updatedAt": "2024-04-02T06:44:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM51uA_Y",
          "commit": {
            "abbreviatedOid": "5c172ff"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T20:47:02Z",
          "updatedAt": "2024-04-02T20:47:02Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "and Authorization rather than Authorisation (sorry, but for consistency with all the other OAuth RFCs that use that spelling) ",
              "createdAt": "2024-04-02T20:47:02Z",
              "updatedAt": "2024-04-02T20:47:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM51uBm-",
          "commit": {
            "abbreviatedOid": "5c172ff"
          },
          "author": "bc-pi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T20:47:57Z",
          "updatedAt": "2024-04-02T20:47:58Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nThis draft introduces the concept of client attestations to the OAuth 2 protocol, which consists of two JWT's, a Client Attestation and Client Attestation PoP, which are conveyed via HTTP headers in an HTTP request sent by a client to an Authorization Server or Resource Server. The purpose of these headers is to authenticate or attest to the Client Instance.\r\n```",
              "createdAt": "2024-04-02T20:47:57Z",
              "updatedAt": "2024-04-02T20:47:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM53UOm_",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-15T17:33:11Z",
          "updatedAt": "2024-04-15T17:33:12Z",
          "comments": [
            {
              "originalPosition": 196,
              "body": "```suggestion\r\n\r\nImplementers should consider the technical limitations of header sizes of the deployed web servers. If the Client Attestations size is becoming large, e.g. a `x5c` header containing multiple certificates with RSA keys as a trust mechanism, web server implementations receiving the HTTP request could fail as the header does not fit into the buffer dedicated for the HTTP headers. It shall be noted, that this limit is not given by the HTTP standard, but only by the technical implementations. As of 2024, typical limits for HTTP headers is 8 kB or above, which seems sufficient. \r\n```",
              "createdAt": "2024-04-15T17:33:12Z",
              "updatedAt": "2024-04-15T17:33:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM53VHjo",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-15T19:48:27Z",
          "updatedAt": "2024-04-15T19:48:27Z",
          "comments": [
            {
              "originalPosition": 196,
              "body": "```suggestion\r\n\r\n### Web Server Default Maximum HTTP Header Sizes\r\n\r\nBecause the Client Attestation and Client Attestation PoP are communicated using HTTP headers, implementers should consider that web servers may have a default maximum HTTP header size configured which could be too low to allow conveying a Client Attestation and or Client Attestation PoP in an HTTP request. It should be noted, that this limit is not given by the HTTP {{RFC9112}}, but instead web server implementations commonly set a default maximum size for HTTP headers. As of 2024, typical limits for modern web servers configure maximum HTTP headers as 8 kB or more as a default.\r\n```",
              "createdAt": "2024-04-15T19:48:27Z",
              "updatedAt": "2024-04-16T21:05:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM53bu1g",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-16T14:04:52Z",
          "updatedAt": "2024-04-16T14:04:52Z",
          "comments": [
            {
              "originalPosition": 196,
              "body": "I don't think that \"which seems sufficient\" should be included.",
              "createdAt": "2024-04-16T14:04:52Z",
              "updatedAt": "2024-04-16T14:04:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM53dROK",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "This should hopefully fix the rendering",
          "createdAt": "2024-04-16T16:47:23Z",
          "updatedAt": "2024-04-16T16:52:49Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nOAuth-Client-Attestation: eyJhbGciOiAiRVMyNTYiLCJraWQiOiAiMTEifQ.eyJ\\\r\npc3MiOiJodHRwczovL2NsaWVudC5leGFtcGxlLmNvbSIsInN1YiI6Imh0dHBzOi8vY2x\\\r\npZW50LmV4YW1wbGUuY29tIiwibmJmIjoxMzAwODE1NzgwLCJleHAiOjEzMDA4MTkzODA\\\r\nsImNuZiI6eyJqd2siOnsia3R5IjoiRUMiLCJ1c2UiOiJzaWciLCJjcnYiOiJQLTI1NiI\\\r\nsIngiOiIxOHdITGVJZ1c5d1ZONlZEMVR4Z3BxeTJMc3pZa01mNko4bmpWQWlidmhNIiw\\\r\nieSI6Ii1WNGRTNFVhTE1nUF80Zlk0ajhpcjdjbDFUWGxGZEFnY3g1NW83VGtjU0EifX1\\\r\n9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\r\n```",
              "createdAt": "2024-04-16T16:47:23Z",
              "updatedAt": "2024-04-16T16:52:49Z"
            },
            {
              "originalPosition": 102,
              "body": "```suggestion\r\nOAuth-Client-Attestation-PoP: eyJhbGciOiJFUzI1NiJ9.eyJpc3MiOiJodHRwc\\\r\nzovL2NsaWVudC5leGFtcGxlLmNvbSIsImF1ZCI6Imh0dHBzOi8vYXMuZXhhbXBsZS5jb\\\r\n20iLCJuYmYiOjEzMDA4MTU3ODAsImV4cCI6MTMwMDgxOTM4MH0.coB_mtdXwvi9RxSMz\\\r\nbIey8GVVQLv9qQrBUqmc1qj9Bs\r\n```",
              "createdAt": "2024-04-16T16:48:03Z",
              "updatedAt": "2024-04-16T16:52:49Z"
            },
            {
              "originalPosition": 182,
              "body": "```suggestion\r\nPOST /token HTTP/1.1\r\nHost: as.example.com\r\nContent-Type: application/x-www-form-urlencoded\r\nOAuth-Client-Attestation: eyJhbGciOiAiRVMyNTYiLCJraWQiOiAiMTEifQ.eyJ\\\r\npc3MiOiJodHRwczovL2NsaWVudC5leGFtcGxlLmNvbSIsInN1YiI6Imh0dHBzOi8vY2x\\\r\npZW50LmV4YW1wbGUuY29tIiwibmJmIjoxMzAwODE1NzgwLCJleHAiOjEzMDA4MTkzODA\\\r\nsImNuZiI6eyJqd2siOnsia3R5IjoiRUMiLCJ1c2UiOiJzaWciLCJjcnYiOiJQLTI1NiI\\\r\nsIngiOiIxOHdITGVJZ1c5d1ZONlZEMVR4Z3BxeTJMc3pZa01mNko4bmpWQWlidmhNIiw\\\r\nieSI6Ii1WNGRTNFVhTE1nUF80Zlk0ajhpcjdjbDFUWGxGZEFnY3g1NW83VGtjU0EifX1\\\r\n9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\r\nOAuth-Client-Attestation-PoP: eyJhbGciOiJFUzI1NiJ9.eyJpc3MiOiJodHRwc\\\r\nzovL2NsaWVudC5leGFtcGxlLmNvbSIsImF1ZCI6Imh0dHBzOi8vYXMuZXhhbXBsZS5jb\\\r\n20iLCJuYmYiOjEzMDA4MTU3ODAsImV4cCI6MTMwMDgxOTM4MH0.coB_mtdXwvi9RxSMz\\\r\nbIey8GVVQLv9qQrBUqmc1qj9Bs\r\n\r\ngrant_type=authorization_code&\r\ncode=n0esc3NRze7LTCu7iYzS6a5acc3f0ogp4\r\n```",
              "createdAt": "2024-04-16T16:49:50Z",
              "updatedAt": "2024-04-16T16:52:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM53ell8",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-16T20:05:55Z",
          "updatedAt": "2024-04-16T20:05:55Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nThis specification introduces an extension to the OAuth 2.0 protocol, as outlined in {{RFC6749}}, enabling Client Instances to include an attestation in their interactions with Authorization Servers or Resource Servers. This method allows Client Instances, typically considered as public clients in traditional deployments, to authenticate to an Authorization Server or Resource Server by providing an attestation, thereby enhancing the authentication process for Client Instances.\r\n```",
              "createdAt": "2024-04-16T20:05:55Z",
              "updatedAt": "2024-04-16T20:05:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM53enBM",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-04-16T20:09:22Z",
          "updatedAt": "2024-04-16T20:22:13Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nPlease note that the protocol details for steps (2) and (4), particularly how the Client Instance authenticates to the client Backend, are beyond the scope of this specification. Furthermore, this specification is designed to be flexible and can be implemented even in scenarios where the client does not have a backend server. In such cases, each Client Instance is responsible for performing the functions typically handled by the backend on its own. \r\n\r\nThis approach acknowledges the evolving landscape of OAuth 2.0 deployments, where the ability for public clients to authenticate securely and reliably has become increasingly important. \r\n```",
              "createdAt": "2024-04-16T20:09:22Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 52,
              "body": "```suggestion\r\n: A specific deployment or instantiation of a client application in the OAuth 2.0 framework, representing a single, distinct version of the client software running on a device or in an environment. Each Client Instance can have its own unique configuration, state, and identity, distinguishing it from other deployments of the same client application. This concept is particularly relevant in contexts where a client application might be installed and operated across multiple devices or environments, each requiring individual authentication and authorization processes with OAuth 2.0 Authorization Servers or Resource Servers.\r\n```",
              "createdAt": "2024-04-16T20:11:41Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 56,
              "body": "```suggestion\r\n:  A cryptographic asymmetric key pair that is generated by the Client Instance where the public key of the key pair is provided to the client backend. This public key is then encapsulated within the Client Attestation JWT and is utilized to sign the Client Attestation Proof of Possession.\r\n```",
              "createdAt": "2024-04-16T20:12:33Z",
              "updatedAt": "2024-05-16T06:47:21Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nThis draft introduces the concept of client attestations to the OAuth 2 protocol, using two JWTs: a Client Attestation and a Client Attestation Proof of Possession (PoP). These JWTs are transmitted via HTTP headers in an HTTP request from a Client Instance to an Authorization Server or Resource Server. The primary purpose of these headers is to authenticate the Client Instance.\r\n```",
              "createdAt": "2024-04-16T20:14:13Z",
              "updatedAt": "2024-05-16T06:49:30Z"
            },
            {
              "originalPosition": 71,
              "body": "```suggestion\r\n: A JWT that conforms to the structure and syntax as defined in [](#client-attestation-jwt)\r\n```",
              "createdAt": "2024-04-16T20:14:52Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 107,
              "body": "```suggestion\r\nAs specified in {{RFC9110}}, header field names are case-insensitive; therefore, OAUTH-CLIENT-ATTESTATION, oauth-client-attestation, and other case variations are all valid and equivalent header field names. However, it is important to consider that the case is significant in the value of the header field.\r\n```",
              "createdAt": "2024-04-16T20:16:25Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 125,
              "body": "```suggestion\r\nThe following rules apply to validating the Client Attestation JWT. Application of additional restrictions and policy are at the discretion of the Authorization Server.\r\n```",
              "createdAt": "2024-04-16T20:16:48Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 148,
              "body": "```suggestion\r\n11. The Authorization Server MUST reject a JWT that is not valid in all other respects per \"JSON Web Token (JWT)\" {{RFC7519}}.\r\n```",
              "createdAt": "2024-04-16T20:17:10Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 166,
              "body": "```suggestion\r\nThe Authorization Server MUST perform all of the checks outlined in [](#checking-http-requests-with-client-attestations) for a received access token request which is making use of the client attestation mechanism as defined by this draft.\r\n```",
              "createdAt": "2024-04-16T20:17:47Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 190,
              "body": "```suggestion\r\nImplementers should be aware that the design of this authentication mechanism deliberately allows for a Client Instance to re-use a single Client Attestation JWT in multiple interactions/requests with an Authorization Server, whilst producing a fresh Client Attestation PoP JWT. Client deployments should consider this when determining the validity period for issued Client Attestation JWTs as this ultimately controls how long a Client Instance can re-use a single Client Attestation JWT.\r\n```",
              "createdAt": "2024-04-16T20:18:26Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            },
            {
              "originalPosition": 196,
              "body": "anyway, this \"default\" limitation would have huge impacts on the topologies of the infrastructure of trust which will tend to not scale upon multiple intermediates, facilitating therefore the old-single-central-point. \r\n\r\nI see a regression, in a way that is as if we were trying as much as possible to distance ourselves from a potential complexity that we would like to avoid at all costs (and which will therefore haunt us!).",
              "createdAt": "2024-04-16T20:21:47Z",
              "updatedAt": "2024-04-16T20:22:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM53fAZB",
          "commit": {
            "abbreviatedOid": "383f06f"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-16T21:19:26Z",
          "updatedAt": "2024-04-16T21:19:27Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n  RFC9110: RFC9110\r\n  RFC9112: RFC9112\r\n```",
              "createdAt": "2024-04-16T21:19:26Z",
              "updatedAt": "2024-04-16T21:19:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM536B4V",
          "commit": {
            "abbreviatedOid": "96e6b12"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-19T15:15:58Z",
          "updatedAt": "2024-04-26T13:03:28Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "```suggestion\r\ntoken68                        = 1*( ALPHA / DIGIT / \"-\" / \".\" / \r\n                                     \"_\" / \"~\" / \"+\" / \"/\" ) *\"=\"\r\n```",
              "createdAt": "2024-04-19T15:15:59Z",
              "updatedAt": "2024-04-26T13:03:28Z"
            },
            {
              "originalPosition": 229,
              "body": "Need to remove reference to RFC6755",
              "createdAt": "2024-04-19T15:17:07Z",
              "updatedAt": "2024-04-26T13:03:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM547L4u",
          "commit": {
            "abbreviatedOid": "96e6b12"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-04-29T15:06:24Z",
          "updatedAt": "2024-04-29T15:13:31Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I would argue the client instance authenticates as a certain client id from the perspective of the AS. As a test, a client instance could use different JWTs with different confirmation keys but would be still the same client. ",
              "createdAt": "2024-04-29T15:06:24Z",
              "updatedAt": "2024-04-29T15:13:31Z"
            },
            {
              "originalPosition": 16,
              "body": "attestation -> assertion",
              "createdAt": "2024-04-29T15:07:27Z",
              "updatedAt": "2024-04-29T15:13:31Z"
            },
            {
              "originalPosition": 62,
              "body": "The concept of assertions was introduced in OAuth in RFC 7521 and RFC 7523 introduced use of JWTs as assertions to authenticate clients. This draft adds key binding on top of JWT-based client authentication. ",
              "createdAt": "2024-04-29T15:09:02Z",
              "updatedAt": "2024-04-29T15:13:31Z"
            },
            {
              "originalPosition": 206,
              "body": "Binding the refresh token to a client instance requires this draft to introduce a client instance identifier and makes client instances trackable across key binding JWTs. I suggest to bind the refresh token to the JWT instance id or the binding key instead.",
              "createdAt": "2024-04-29T15:12:40Z",
              "updatedAt": "2024-04-29T15:13:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM56xMlp",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-16T06:35:41Z",
          "updatedAt": "2024-05-16T06:35:42Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nThis specification defines an extension to the OAuth 2 protocol as defined in {{RFC6749}} which enables a Client Instance to include an attestation in interactions with an Authorization Server or a Resource Server. This new method enables Client Instances involved in a client deployment that is traditionally viewed as a public client, to be able to provide an attestation in order to authenticate.\r\n```",
              "createdAt": "2024-05-16T06:35:41Z",
              "updatedAt": "2024-05-16T06:37:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM56xOim",
          "commit": {
            "abbreviatedOid": "1c4f76c"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-16T06:40:55Z",
          "updatedAt": "2024-05-16T06:40:55Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "The existing definition is from an already published RFC and while it is short I believe it accurately captures the required detail",
              "createdAt": "2024-05-16T06:40:55Z",
              "updatedAt": "2024-05-16T06:40:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM56xUcx",
          "commit": {
            "abbreviatedOid": "96e6b12"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-16T06:52:30Z",
          "updatedAt": "2024-05-16T06:52:30Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "We will create a seperate issue to discuss this terminology change.",
              "createdAt": "2024-05-16T06:52:30Z",
              "updatedAt": "2024-05-16T06:52:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM56xU7k",
          "commit": {
            "abbreviatedOid": "96e6b12"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-16T06:53:36Z",
          "updatedAt": "2024-05-16T06:53:36Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "As above I think this is a more general terminology change we will tackle seperately, we have created an issue.",
              "createdAt": "2024-05-16T06:53:36Z",
              "updatedAt": "2024-05-16T06:53:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM56xVha",
          "commit": {
            "abbreviatedOid": "96e6b12"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-16T06:54:56Z",
          "updatedAt": "2024-05-16T06:54:56Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "Im not sure I follow the current language does bind to the key represented in the \"cnf\" claim.",
              "createdAt": "2024-05-16T06:54:56Z",
              "updatedAt": "2024-05-16T06:54:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM56xWVZ",
          "commit": {
            "abbreviatedOid": "013d25c"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-16T06:56:52Z",
          "updatedAt": "2024-05-16T06:56:52Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "I think the current language is sufficient even though it is a little more brief.",
              "createdAt": "2024-05-16T06:56:52Z",
              "updatedAt": "2024-05-16T06:56:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57BkHP",
          "commit": {
            "abbreviatedOid": "f8953ea"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-17T17:12:29Z",
          "updatedAt": "2024-05-17T17:12:30Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nThis approach acknowledges the evolving landscape of OAuth 2 deployments, where the ability for public clients to authenticate securely and reliably has become increasingly important.\r\n```",
              "createdAt": "2024-05-17T17:12:30Z",
              "updatedAt": "2024-05-17T17:12:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57BlmC",
          "commit": {
            "abbreviatedOid": "f8953ea"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-05-17T17:16:31Z",
          "updatedAt": "2024-05-17T17:39:56Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "The example neither include nonce nor jti, so it does not have replay protection?",
              "createdAt": "2024-05-17T17:16:31Z",
              "updatedAt": "2024-05-17T17:39:56Z"
            },
            {
              "originalPosition": 175,
              "body": "```suggestion\r\n3. The signature of the Client Attestation PoP JWT obtained from the OAuth-Client-Attestation-PoP HTTP header verifies with the Client Instance Key contained in the `cnf` claim of the Client Attestation JWT obtained from the OAuth-Client-Attestation HTTP header.\r\n```",
              "createdAt": "2024-05-17T17:37:04Z",
              "updatedAt": "2024-05-17T17:39:56Z"
            },
            {
              "originalPosition": 177,
              "body": "```suggestion\r\n# Client Attestation at the Token Endpoint\r\n```",
              "createdAt": "2024-05-17T17:38:19Z",
              "updatedAt": "2024-05-17T17:39:56Z"
            },
            {
              "originalPosition": 179,
              "body": "```suggestion\r\nWhile usage of the the client attestation mechanism defined by this draft can be used in a variety of different HTTP requests to different endpoints, usage within the token request as defined by {{RFC6749}} has particular additional considerations outlined below.\r\n```",
              "createdAt": "2024-05-17T17:38:57Z",
              "updatedAt": "2024-05-17T17:39:56Z"
            },
            {
              "originalPosition": 204,
              "body": "Should we explcitly say that this may be used at the PAR endpoint?",
              "createdAt": "2024-05-17T17:39:43Z",
              "updatedAt": "2024-05-17T17:39:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57FfWN",
          "commit": {
            "abbreviatedOid": "f8953ea"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-19T09:39:15Z",
          "updatedAt": "2024-05-19T09:39:15Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "Agreed, created an issue.",
              "createdAt": "2024-05-19T09:39:15Z",
              "updatedAt": "2024-05-19T09:39:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57FfbZ",
          "commit": {
            "abbreviatedOid": "f8953ea"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-19T09:40:54Z",
          "updatedAt": "2024-05-19T09:40:54Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Agreed created an issue to track seperately.",
              "createdAt": "2024-05-19T09:40:54Z",
              "updatedAt": "2024-05-19T09:40:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57FfrG",
          "commit": {
            "abbreviatedOid": "e2a05bf"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-19T09:46:55Z",
          "updatedAt": "2024-05-19T09:46:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM57F0gg",
          "commit": {
            "abbreviatedOid": "e2a05bf"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I do believe there should be a discussion about terminology (attestation vs assertion) as it seems to create quite a bit of confusion, but I do think a different issue/PR is better suited for that.\r\n\r\nMinor nit: Client Attestation seems to be used in lower and upper case somewhat inconsistently. Should every usage be upper case (e.g., also client attestation mechanism)? ",
          "createdAt": "2024-05-19T18:09:25Z",
          "updatedAt": "2024-05-19T18:09:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM57JD9x",
          "commit": {
            "abbreviatedOid": "e2a05bf"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-05-20T11:19:20Z",
          "updatedAt": "2024-05-20T11:34:29Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nThis specification defines an extension to the OAuth 2 protocol as defined in {{RFC6749}} which enables a Client Instance to include an attestation in interactions with an Authorization Server or a Resource Server. This new method enables Client Instances involved in a client deployment that is traditionally viewed as a public client, to be able to authenticate.\r\n```",
              "createdAt": "2024-05-20T11:19:20Z",
              "updatedAt": "2024-05-20T11:34:29Z"
            },
            {
              "originalPosition": 43,
              "body": "\"public clients\" ... \"to authenticate\" is a contradiction. The text further up speaks about \"deployments traditionally viewed as a public client\", that's a better description. I would even argue either this spec is for confidential clients of a new kind or it is a new type of client. But it is not for public clients.",
              "createdAt": "2024-05-20T11:23:01Z",
              "updatedAt": "2024-05-20T11:34:29Z"
            },
            {
              "originalPosition": 63,
              "body": "it is difficult if the text states client backend is out of scope but refers to the backend in the definition. Perhaps a more abstract definition would help. In the end, there must be a party trusted by the AS that signs the client attestations/assertions. It does not matter whether that is the client backend. ",
              "createdAt": "2024-05-20T11:26:46Z",
              "updatedAt": "2024-05-20T11:34:29Z"
            },
            {
              "originalPosition": 67,
              "body": "I still believe the term \"attestation\" should be replaced by \"assertion\". That's more appropriate and it does not confuse the audience as the term \"attestation\". ",
              "createdAt": "2024-05-20T11:28:05Z",
              "updatedAt": "2024-05-20T11:34:29Z"
            },
            {
              "originalPosition": 206,
              "body": "you are right, I resolve the comment. ",
              "createdAt": "2024-05-20T11:33:03Z",
              "updatedAt": "2024-05-20T11:34:29Z"
            },
            {
              "originalPosition": 228,
              "body": "```suggestion\r\nImplementers should be aware that using the same client attestation across multiple authorization servers could result in correlation of the end user using the Client Instance through claim values (including the Client Instance Key in the `cnf` claim). Client deployments are therefore RECOMMENDED to use different Client Attestation JWTs with different Client Instance Keys across different authorization servers.\r\n```",
              "createdAt": "2024-05-20T11:34:18Z",
              "updatedAt": "2024-05-20T14:21:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57KZBT",
          "commit": {
            "abbreviatedOid": "e2a05bf"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-20T14:14:31Z",
          "updatedAt": "2024-05-20T14:14:32Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "How about that? If we rename the draft we may rename attestation, but until then I would keep it\r\n```suggestion\r\nThis specification defines an extension to the OAuth 2 protocol as defined in {{RFC6749}} which enables a Client Instance to include a key-bound attestation in interactions with an Authorization Server or a Resource Server. This new method enables Client Instances involved in a client deployment that is traditionally viewed as a public client, to be able to utilize this key-bound attestation to authenticate.\r\n```",
              "createdAt": "2024-05-20T14:14:31Z",
              "updatedAt": "2024-05-20T14:14:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57KaQ3",
          "commit": {
            "abbreviatedOid": "e2a05bf"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-20T14:17:00Z",
          "updatedAt": "2024-05-20T14:17:00Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "The text doesn't say Client Backend is out of scope as `iss` of the Client Attestation JWT is the Client Backend but only that how Client Backend authenticates the client instance is out of scope",
              "createdAt": "2024-05-20T14:17:00Z",
              "updatedAt": "2024-05-20T14:17:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57Ka5n",
          "commit": {
            "abbreviatedOid": "e2a05bf"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-20T14:18:14Z",
          "updatedAt": "2024-05-20T14:18:14Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "It will be a dedicated discussion in OAuth Interims Call and we have a separate Issue #71, but it shouldn't delay this PR in my mind",
              "createdAt": "2024-05-20T14:18:14Z",
              "updatedAt": "2024-05-20T14:18:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57Kcgj",
          "commit": {
            "abbreviatedOid": "e2a05bf"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-20T14:21:29Z",
          "updatedAt": "2024-05-20T14:21:29Z",
          "comments": [
            {
              "originalPosition": 228,
              "body": "applied with some additional corrections",
              "createdAt": "2024-05-20T14:21:29Z",
              "updatedAt": "2024-05-20T14:21:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57Y-AP",
          "commit": {
            "abbreviatedOid": "30ae9a8"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-22T05:43:39Z",
          "updatedAt": "2024-05-22T05:43:40Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I created Issue #79 to pursue this topic",
              "createdAt": "2024-05-22T05:43:40Z",
              "updatedAt": "2024-05-22T05:43:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM57w7pj",
          "commit": {
            "abbreviatedOid": "567e381"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-24T09:52:34Z",
          "updatedAt": "2024-05-24T09:52:34Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I like your proposal. ",
              "createdAt": "2024-05-24T09:52:34Z",
              "updatedAt": "2024-05-24T09:52:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 80,
      "id": "PR_kwDOJaEkaM5w2nJL",
      "title": "fix broken links after moving the repo",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/80",
      "state": "MERGED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-05-29T08:39:24Z",
      "updatedAt": "2024-05-31T09:20:12Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "2b711a053edd47a06be903cd116a3996dd689a5f",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "c2bo/fix-links-repo-move",
      "headRefOid": "db0f5bc72b821dd8c296dfb1d7b8a72dc91ec63b",
      "closedAt": "2024-05-31T09:20:09Z",
      "mergedAt": "2024-05-31T09:20:09Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "d5b5558c1f045a4e358ce79f3efae453fc1857b6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM58l0gE",
          "commit": {
            "abbreviatedOid": "db0f5bc"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-31T09:20:04Z",
          "updatedAt": "2024-05-31T09:20:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 82,
      "id": "PR_kwDOJaEkaM55t96Y",
      "title": "add http field name (header) iana registration",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/82",
      "state": "MERGED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "closes #78\r\n",
      "createdAt": "2024-08-28T14:21:54Z",
      "updatedAt": "2024-08-29T07:40:03Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "94b0fdfbd3ee492f07b2334063565d47ed15ef34",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "c2bo/iana-headers",
      "headRefOid": "60320c0726879d8cfca666f55dc45424f41f6343",
      "closedAt": "2024-08-29T07:39:59Z",
      "mergedAt": "2024-08-29T07:39:59Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "26212a233b69350ee92b1e437341c8ab347eee72"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6HLcHg",
          "commit": {
            "abbreviatedOid": "60320c0"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-29T07:39:42Z",
          "updatedAt": "2024-08-29T07:39:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6HLcN9",
          "commit": {
            "abbreviatedOid": "60320c0"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-29T07:39:53Z",
          "updatedAt": "2024-08-29T07:39:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 83,
      "id": "PR_kwDOJaEkaM55yTud",
      "title": "add christian as author",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/83",
      "state": "MERGED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We should run the \"Update generated files\" action after this PR - that will also upgrade all of the github actions to current versions",
      "createdAt": "2024-08-29T06:31:36Z",
      "updatedAt": "2024-08-29T07:39:00Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "94b0fdfbd3ee492f07b2334063565d47ed15ef34",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "c2bo/add-as-author",
      "headRefOid": "bf6da6e87b46c88a993769141fcccded834014df",
      "closedAt": "2024-08-29T07:38:57Z",
      "mergedAt": "2024-08-29T07:38:57Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "b14788f752878703c82a2719e63f6270cf7b792c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6HLbd-",
          "commit": {
            "abbreviatedOid": "bf6da6e"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-29T07:38:27Z",
          "updatedAt": "2024-08-29T07:38:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6HLbqw",
          "commit": {
            "abbreviatedOid": "bf6da6e"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-29T07:38:49Z",
          "updatedAt": "2024-08-29T07:38:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 87,
      "id": "PR_kwDOJaEkaM5-oNuz",
      "title": "fix PoP examples to include jti and nonce",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/87",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #77 ",
      "createdAt": "2024-10-15T06:49:58Z",
      "updatedAt": "2024-10-16T06:35:13Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "26212a233b69350ee92b1e437341c8ab347eee72",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "77-update-client-attestation-pop-to-include-jti-and-nonce",
      "headRefOid": "95ce1adb353887e722503e49e0725714837822e1",
      "closedAt": "2024-10-16T06:35:10Z",
      "mergedAt": "2024-10-16T06:35:10Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "52766bce76492c19a69022de67a53020e201419f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6NVr44",
          "commit": {
            "abbreviatedOid": "95ce1ad"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-16T05:54:51Z",
          "updatedAt": "2024-10-16T05:54:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6NV5lO",
          "commit": {
            "abbreviatedOid": "95ce1ad"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-16T06:29:14Z",
          "updatedAt": "2024-10-16T06:29:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 90,
      "id": "PR_kwDOJaEkaM5_OXvl",
      "title": "Restructure text and add alternative representation",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/90",
      "state": "MERGED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "- fixes a small bug in the PoP examples (backslash)\r\n- Restructures text into 2 major parts\r\n  - header based syntax\r\n  - concatenated representation (\\<attestation jwt\\> ~ \\<attestation jwt pop\\>)\r\n- adds format & validation similar to an sd-jwt (but simpler)\r\n\r\nRendered version: https://drafts.oauth.net/draft-ietf-oauth-attestation-based-client-auth/c2bo/proposed-format/draft-ietf-oauth-attestation-based-client-auth.html\r\n\r\ncloses #86\r\ncloses #76\r\nprobably closes #46?",
      "createdAt": "2024-10-20T13:05:17Z",
      "updatedAt": "2024-10-21T18:41:42Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "52766bce76492c19a69022de67a53020e201419f",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "c2bo/proposed-format",
      "headRefOid": "8417c2ce5ad152490bfc3f437045bc42ae5b1b7d",
      "closedAt": "2024-10-21T18:41:38Z",
      "mergedAt": "2024-10-21T18:41:38Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "05670e6079baef279d03d5e4cee1bad5b3a703db"
      },
      "comments": [
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "> lgtm, should we include that the header based syntax is a MUST implementation support?\r\n\r\nI thought about language like that as well, but I don't think it really helps here. It should be in something like HAIP that profiles an ecosystem - a client will/must know what it needs to support and an AS etc. can choose depending on the ecosystem.",
          "createdAt": "2024-10-21T06:07:40Z",
          "updatedAt": "2024-10-21T06:07:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6N5ooY",
          "commit": {
            "abbreviatedOid": "36e2c29"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm, should we include that the header based syntax is a MUST implementation support?",
          "createdAt": "2024-10-20T23:08:58Z",
          "updatedAt": "2024-10-20T23:13:49Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "```suggestion\r\n## Validating HTTP requests feature client attestations {#checking-http-requests-with-client-attestations}\r\n```",
              "createdAt": "2024-10-20T23:08:58Z",
              "updatedAt": "2024-10-20T23:13:49Z"
            },
            {
              "originalPosition": 141,
              "body": "```suggestion\r\n2. There is precisely one OAuth-Client-Attestation-PoP HTTP request header field, where its value is a single well-formed JWT conforming to the syntax outlined in [](client-attestation-pop-jwt).\r\n3. The signature of the Client Attestation PoP JWT obtained from the OAuth-Client-Attestation-PoP HTTP header verifies with the Client Instance Key contained in the `cnf` claim of the Client Attestation JWT obtained from the OAuth-Client-Attestation HTTP header.\r\n```",
              "createdAt": "2024-10-20T23:10:33Z",
              "updatedAt": "2024-10-20T23:13:49Z"
            },
            {
              "originalPosition": 201,
              "body": "```suggestion\r\nA Client Attestation according to this specification MAY be presented using an alternative representation for cases where the header-based mechanism (as introduced in introduced in [](#headers) does not fit the underlying protocols, e.g., for direct calls to Browser APIs.\r\n```",
              "createdAt": "2024-10-20T23:12:01Z",
              "updatedAt": "2024-10-20T23:13:49Z"
            },
            {
              "originalPosition": 238,
              "body": "```suggestion\r\n1. Before the '~' character, there exists precisely a single well-formed JWT conforming to the syntax outlined in [](client-attestation-jwt).\r\n2. After the '~' character, there exists precisely a single well-formed JWT conforming to the syntax outlined in [](client-attestation-pop-jwt).\r\n```",
              "createdAt": "2024-10-20T23:12:42Z",
              "updatedAt": "2024-10-20T23:13:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6N8Ql2",
          "commit": {
            "abbreviatedOid": "8d65674"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T09:00:03Z",
          "updatedAt": "2024-10-21T09:00:03Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "```suggestion\r\nThe following section defines how a Client Attestation can be provided in an HTTP request using HTTP headers.\r\n```",
              "createdAt": "2024-10-21T09:00:03Z",
              "updatedAt": "2024-10-21T09:00:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6N8RAr",
          "commit": {
            "abbreviatedOid": "8d65674"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T09:00:45Z",
          "updatedAt": "2024-10-21T09:00:45Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "No real notion of default here so thought it was better to rephrase.",
              "createdAt": "2024-10-21T09:00:45Z",
              "updatedAt": "2024-10-21T09:00:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6OCnmt",
          "commit": {
            "abbreviatedOid": "8417c2c"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T18:41:27Z",
          "updatedAt": "2024-10-21T18:41:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 91,
      "id": "PR_kwDOJaEkaM5_PUqL",
      "title": "add RATS relation",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/91",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #60 ",
      "createdAt": "2024-10-20T20:09:37Z",
      "updatedAt": "2024-10-21T18:44:39Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "05670e6079baef279d03d5e4cee1bad5b3a703db",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "pb/rats",
      "headRefOid": "764d0066f8634a5366f45c7e2419b6775b44ae5c",
      "closedAt": "2024-10-21T18:44:38Z",
      "mergedAt": "2024-10-21T18:44:38Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "0bc7bce46936f6506f0c805c564041e8fe3488a8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6N61ST",
          "commit": {
            "abbreviatedOid": "4c5feb5"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I am not that familiar with RATS, but looks good for me",
          "createdAt": "2024-10-21T06:11:11Z",
          "updatedAt": "2024-10-21T06:11:11Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6N8Ryw",
          "commit": {
            "abbreviatedOid": "4c5feb5"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T09:01:57Z",
          "updatedAt": "2024-10-21T09:01:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 92,
      "id": "PR_kwDOJaEkaM5_PilT",
      "title": "add typ values",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/92",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #30 \r\nCloses #72 ",
      "createdAt": "2024-10-20T23:14:24Z",
      "updatedAt": "2024-10-21T19:03:23Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "0bc7bce46936f6506f0c805c564041e8fe3488a8",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "pb/typ_values",
      "headRefOid": "9af6469d5a5c4268e3a8f60747b30bcfa73f3bf5",
      "closedAt": "2024-10-21T19:03:22Z",
      "mergedAt": "2024-10-21T19:03:22Z",
      "mergedBy": "c2bo",
      "mergeCommit": {
        "oid": "5d164320ad677e0d5302f86d053d955358d39850"
      },
      "comments": [
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "This includes #90 which makes it pretty hard to see the changes to main :/ I guess let's wait until 90 is merged?",
          "createdAt": "2024-10-21T07:17:41Z",
          "updatedAt": "2024-10-21T07:17:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6OB_ih",
          "commit": {
            "abbreviatedOid": "b9de7d1"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T17:45:07Z",
          "updatedAt": "2024-10-21T17:49:31Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "Should we explain what happens if claims are not understood by a RP?\r\nWe have 2 options and should probably clearly state how to deal with such a situation in the spec:\r\n- ignore not understood claims\r\n- fail validation of the client attestation",
              "createdAt": "2024-10-21T17:45:07Z",
              "updatedAt": "2024-10-21T17:49:31Z"
            },
            {
              "originalPosition": 156,
              "body": "Same as above: How to deal with claims that are not understood by a RP?",
              "createdAt": "2024-10-21T17:49:19Z",
              "updatedAt": "2024-10-21T17:49:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6OCugG",
          "commit": {
            "abbreviatedOid": "baba770"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T18:57:14Z",
          "updatedAt": "2024-10-21T18:57:39Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "```suggestion\r\n1. The JWT MAY contain other claims. All claims that are not understood by implementations MUST be ignored.\r\n```",
              "createdAt": "2024-10-21T18:57:14Z",
              "updatedAt": "2024-10-21T18:57:39Z"
            },
            {
              "originalPosition": 156,
              "body": "```suggestion\r\n1. The JWT MAY contain other claims. All claims that are not understood by implementations MUST be ignored.\r\n```",
              "createdAt": "2024-10-21T18:57:34Z",
              "updatedAt": "2024-10-21T18:57:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6OCvjK",
          "commit": {
            "abbreviatedOid": "9af6469"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T18:59:43Z",
          "updatedAt": "2024-10-21T18:59:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6OCvkc",
          "commit": {
            "abbreviatedOid": "9af6469"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T18:59:46Z",
          "updatedAt": "2024-10-21T18:59:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 93,
      "id": "PR_kwDOJaEkaM5_Pi5G",
      "title": "remove annex as key attestations are moved out of scope  for now",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/93",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #88 ",
      "createdAt": "2024-10-20T23:18:10Z",
      "updatedAt": "2024-10-21T19:09:16Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "5d164320ad677e0d5302f86d053d955358d39850",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "remove_annex",
      "headRefOid": "0ef8a3abd3be09254001941410a7dd347bb4bb4c",
      "closedAt": "2024-10-21T19:09:15Z",
      "mergedAt": "2024-10-21T19:09:15Z",
      "mergedBy": "c2bo",
      "mergeCommit": {
        "oid": "8be32e23f15c3936fdff51e3f3f27907788452f5"
      },
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, would do so in an introduction rewrite ",
          "createdAt": "2024-10-21T06:29:02Z",
          "updatedAt": "2024-10-21T06:29:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6N62kI",
          "commit": {
            "abbreviatedOid": "9561b98"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Should we add text, that while this specification focuses on a client attestation and only specifies this, there might be other values included like an optional key attestation?\r\n\r\nI guess in general we should add the standard extensibility text to the Attestation JWT - but we don't have to do that in this PR",
          "createdAt": "2024-10-21T06:14:57Z",
          "updatedAt": "2024-10-21T06:14:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6N7SML",
          "commit": {
            "abbreviatedOid": "9561b98"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T07:12:02Z",
          "updatedAt": "2024-10-21T07:12:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6OCpRw",
          "commit": {
            "abbreviatedOid": "9561b98"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T18:45:17Z",
          "updatedAt": "2024-10-21T18:45:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 96,
      "id": "PR_kwDOJaEkaM6IWVZo",
      "title": "fix examples (missing typ)",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/96",
      "state": "MERGED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "fixes #94, #89",
      "createdAt": "2025-01-20T12:34:28Z",
      "updatedAt": "2025-02-28T09:10:15Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "8be32e23f15c3936fdff51e3f3f27907788452f5",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "94-typ-header",
      "headRefOid": "8da14090941419d2404da0d7102e6db1f7d79476",
      "closedAt": "2025-02-28T09:10:15Z",
      "mergedAt": "2025-02-28T09:10:15Z",
      "mergedBy": "c2bo",
      "mergeCommit": {
        "oid": "2954aac8f2a0cd7f86d5ea9a0b727e9b97b2c2d6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6Zy34N",
          "commit": {
            "abbreviatedOid": "8da1409"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-29T07:57:59Z",
          "updatedAt": "2025-01-29T07:57:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 97,
      "id": "PR_kwDOJaEkaM6I0KFz",
      "title": "update ietf template",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/97",
      "state": "MERGED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Same problem as in the status list repo",
      "createdAt": "2025-01-23T20:55:36Z",
      "updatedAt": "2025-01-29T07:57:26Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "8be32e23f15c3936fdff51e3f3f27907788452f5",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "c2bo/update-ietf-template",
      "headRefOid": "f5287aa935565fab49709fbf16d8af5ee3bc92a9",
      "closedAt": "2025-01-29T07:57:26Z",
      "mergedAt": "2025-01-29T07:57:26Z",
      "mergedBy": "c2bo",
      "mergeCommit": {
        "oid": "8b03bfc8941fb825022fed82a01c0866a9037c03"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6ZdjGG",
          "commit": {
            "abbreviatedOid": "f5287aa"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-27T07:04:37Z",
          "updatedAt": "2025-01-27T07:04:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6Zy2qC",
          "commit": {
            "abbreviatedOid": "f5287aa"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-29T07:55:44Z",
          "updatedAt": "2025-01-29T07:55:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 98,
      "id": "PR_kwDOJaEkaM6JSGnS",
      "title": "update org",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/98",
      "state": "MERGED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-01-28T21:09:43Z",
      "updatedAt": "2025-01-29T07:58:07Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "8be32e23f15c3936fdff51e3f3f27907788452f5",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "c2bo/switch-org",
      "headRefOid": "84b6fd38dfe11104cf90375d583920b1ce6deca8",
      "closedAt": "2025-01-29T07:58:06Z",
      "mergedAt": "2025-01-29T07:58:06Z",
      "mergedBy": "c2bo",
      "mergeCommit": {
        "oid": "2a8ec45761258161d6c005f4efd03c4f9b80a5e2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6Zv4nR",
          "commit": {
            "abbreviatedOid": "84b6fd3"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-28T21:38:30Z",
          "updatedAt": "2025-01-28T21:38:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6Zy2jI",
          "commit": {
            "abbreviatedOid": "84b6fd3"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-29T07:55:27Z",
          "updatedAt": "2025-01-29T07:55:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 99,
      "id": "PR_kwDOJaEkaM6M8eZs",
      "title": "initial formulation on server provided nonce",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/99",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #39 \r\nCloses #59 \r\nCloses #85 \r\n\r\nSupersedes #64 ",
      "createdAt": "2025-02-28T14:11:08Z",
      "updatedAt": "2025-03-03T19:07:27Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "c7f7a11b81d5e2a837fb8d99605d7539a613a715",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "59-server-provided-nonce",
      "headRefOid": "83a3d4b799104826916099a05da41eb56df5a88b",
      "closedAt": "2025-03-03T19:07:27Z",
      "mergedAt": "2025-03-03T19:07:27Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "0d1e8330a3490fbc9ad29b6e35b031288852dbf1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6eI52V",
          "commit": {
            "abbreviatedOid": "25bb87c"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-03T06:03:19Z",
          "updatedAt": "2025-03-03T06:03:20Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nThis specification defines header fields that allow a Client to request a fresh nonce value to be used in the OAuth-Client-Attestation-PoP header.\r\n```\r\n\r\nor something to this affect otherwise it feels like the sentence is incomplete.",
              "createdAt": "2025-03-03T06:03:20Z",
              "updatedAt": "2025-03-03T06:03:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6ePzeN",
          "commit": {
            "abbreviatedOid": "163dcc9"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-03T18:39:23Z",
          "updatedAt": "2025-03-03T18:39:24Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "```suggestion\r\n* Metadata Description: An array of URLs that specify the endpoints supporting the nonce retrieval and expecting a Client Attestation bound to a server-provided nonce.\r\n```",
              "createdAt": "2025-03-03T18:39:24Z",
              "updatedAt": "2025-03-03T18:39:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6eP0Lx",
          "commit": {
            "abbreviatedOid": "83a3d4b"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-03T18:40:47Z",
          "updatedAt": "2025-03-03T18:40:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6eP0Zm",
          "commit": {
            "abbreviatedOid": "83a3d4b"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I appove",
          "createdAt": "2025-03-03T18:41:03Z",
          "updatedAt": "2025-03-03T18:41:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6eQFPc",
          "commit": {
            "abbreviatedOid": "83a3d4b"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-03T19:07:20Z",
          "updatedAt": "2025-03-03T19:07:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 100,
      "id": "PR_kwDOJaEkaM6NEJql",
      "title": "improve introduction, rename client backend to client attester",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/100",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-02T14:01:25Z",
      "updatedAt": "2025-03-03T07:14:19Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "2954aac8f2a0cd7f86d5ea9a0b727e9b97b2c2d6",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "pb/introduction2",
      "headRefOid": "a4028506faeec4bc555b43f05ce0f7c386456c81",
      "closedAt": "2025-03-03T07:12:55Z",
      "mergedAt": "2025-03-03T07:12:55Z",
      "mergedBy": "c2bo",
      "mergeCommit": {
        "oid": "c7f7a11b81d5e2a837fb8d99605d7539a613a715"
      },
      "comments": [
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "Closes #84, #32 ",
          "createdAt": "2025-03-03T07:14:18Z",
          "updatedAt": "2025-03-03T07:14:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6eHbSY",
          "commit": {
            "abbreviatedOid": "a402850"
          },
          "author": "selfissued",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-02T14:55:45Z",
          "updatedAt": "2025-03-02T14:55:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6eHiFm",
          "commit": {
            "abbreviatedOid": "a402850"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-02T17:14:33Z",
          "updatedAt": "2025-03-02T17:14:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6eI6tw",
          "commit": {
            "abbreviatedOid": "a402850"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-03T06:06:11Z",
          "updatedAt": "2025-03-03T06:06:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 106,
      "id": "PR_kwDOJaEkaM6Q_2_1",
      "title": "Create generator-generic-ossf-slsa3-publish.yml",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/106",
      "state": "CLOSED",
      "author": "Stefan41199",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-04-01T21:42:40Z",
      "updatedAt": "2025-04-17T06:33:07Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "0d1e8330a3490fbc9ad29b6e35b031288852dbf1",
      "headRepository": "Stefan41199/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "Stefan41199-patch-1",
      "headRefOid": "9d398504efe3be6adb6ede22da0406a150b19206",
      "closedAt": "2025-04-17T06:33:07Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Hello @Stefan41199 do you have any further explanations, comments or feedback what this PR is about?",
          "createdAt": "2025-04-03T06:53:35Z",
          "updatedAt": "2025-04-03T06:53:35Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as no comment",
          "createdAt": "2025-04-17T06:33:07Z",
          "updatedAt": "2025-04-17T06:33:07Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 112,
      "id": "PR_kwDOJaEkaM6VmKZu",
      "title": "new proposal for challenge endpoint",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/112",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #73 \r\nCloses #110 \r\nCloses #104 \r\nCloses #102 \r\nCloses #101 \r\nCloses #103 \r\nCloses #116 \r\nCloses #109\r\n\r\n- [x] include some security consideration comparing freshness and replay prevention @paulbastian \r\n- [ ] discuss option to include some state parameter to the challenge request \r\n- [x] IANA registry entry @tplooker \r\n- [x] adapt header based syntax to Attestation-Challenge @paulbastian \r\n- [x] clarify that the response using the HTTP header may also be an error @c2bo \r\n- [x] introduce an use_attestation_challenge OAuth error @c2bo \r\n- [x] introduce invalid_client_attestation @c2bo \r\n- [x] consider namespacing headers etc @tplooker ",
      "createdAt": "2025-05-09T14:25:35Z",
      "updatedAt": "2025-07-07T06:42:09Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "0d1e8330a3490fbc9ad29b6e35b031288852dbf1",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "nonce_endpoint",
      "headRefOid": "abf6874c47e7f89961de693c45f58aac84277867",
      "closedAt": "2025-07-07T06:42:09Z",
      "mergedAt": "2025-07-07T06:42:08Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "adf7c67a896d112b28c5f626f139d1e5824af56d"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "FYI\r\n[f1fef28](https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/112/commits/f1fef28c224fee753ea2c436463123cee76a96b9) updates the iana registration.\r\n[803ea07](https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/112/commits/803ea079375a6e1fd3a3aae1254ec540d7fef7d0) namespaces the Attestation-Challenge HTTP header by suffixing it with OAuth-Client- making it consistent with the other HTTP headers we've defined in the spec.",
          "createdAt": "2025-06-04T00:00:06Z",
          "updatedAt": "2025-06-04T00:00:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Have updated the list of issues this PR closes as I think it also addresses #103, with this sentence.\r\n\r\n> If the Authorization Server offers a challenge endpoint, the Client MUST retrieve a challenge and MUST use this challenge in the OAuth-Attestation-PoP as defined in (#client-attestation-pop-jwt).\r\n\r\nWe could if we felt the need make this even clearer but I'm pretty comfortable with it, as it is.",
          "createdAt": "2025-06-04T00:08:38Z",
          "updatedAt": "2025-06-04T00:08:38Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Also added #116 to the list of issues this PR closes.",
          "createdAt": "2025-06-04T00:22:06Z",
          "updatedAt": "2025-06-04T00:22:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "To discuss whether this also covers #109 ",
          "createdAt": "2025-06-04T00:36:52Z",
          "updatedAt": "2025-06-04T00:36:52Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think this is in a decent state now - at least good enough to get more feedback. Should we post this to the mailing list and ask for feedback?\n\nI agree. Next steps afterwards should be making PoP exp optional/removed and the processing & verification to round it up. However, this is ready for the mailing list. Wdyt @tplooker ",
          "createdAt": "2025-06-14T06:43:25Z",
          "updatedAt": "2025-06-14T06:43:25Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> I agree. Next steps afterwards should be making PoP exp optional/removed and the processing & verification to round it up. However, this is ready for the mailing list. Wdyt @tplooker\r\n\r\nI agree",
          "createdAt": "2025-06-16T06:27:06Z",
          "updatedAt": "2025-06-16T06:27:06Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "@jricher would you be able to give this a review, as we've discussed this at EIC?",
          "createdAt": "2025-06-24T06:39:07Z",
          "updatedAt": "2025-06-24T06:39:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6ouj0R",
          "commit": {
            "abbreviatedOid": "6cbc2ae"
          },
          "author": "TimoGlastra",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-10T12:44:29Z",
          "updatedAt": "2025-05-10T12:44:30Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Standard practice is to use snake case, specific reason to use `-` here?\r\n\r\n```suggestion\r\n* attestation_challenge: REQUIRED. String containing a Challenge to be used in the OAuth-Attestation-PoP as defined in (#client-attestation-pop-jwt).\r\n```",
              "createdAt": "2025-05-10T12:44:29Z",
              "updatedAt": "2025-05-10T12:44:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6ouj43",
          "commit": {
            "abbreviatedOid": "6cbc2ae"
          },
          "author": "TimoGlastra",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-10T12:46:19Z",
          "updatedAt": "2025-05-10T12:46:19Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "I think it should look something like this\r\n\r\n```suggestion\r\nContent-Type: application/json\r\n\r\n{\r\n  \"attestation_challenge\": \"AYjcyMzY3ZDhiNmJkNTZ\"\r\n}\r\n```",
              "createdAt": "2025-05-10T12:46:19Z",
              "updatedAt": "2025-05-10T12:46:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6ouj6z",
          "commit": {
            "abbreviatedOid": "6cbc2ae"
          },
          "author": "TimoGlastra",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-10T12:46:59Z",
          "updatedAt": "2025-05-10T12:47:00Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "At least that's how i understood the \"message body of the HTTP response using the application/json media type\" from above",
              "createdAt": "2025-05-10T12:47:00Z",
              "updatedAt": "2025-05-10T12:47:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6oukCk",
          "commit": {
            "abbreviatedOid": "6cbc2ae"
          },
          "author": "TimoGlastra",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-10T12:49:53Z",
          "updatedAt": "2025-05-10T12:49:53Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Now that there's a dedicated endpoint, this should be registered in the iana registry i think? ",
              "createdAt": "2025-05-10T12:49:53Z",
              "updatedAt": "2025-05-10T12:49:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6ouuBH",
          "commit": {
            "abbreviatedOid": "6cbc2ae"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-10T13:42:28Z",
          "updatedAt": "2025-05-10T13:42:28Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Yeah, we didn't get to finish that part yesterday - your proposal looks good",
              "createdAt": "2025-05-10T13:42:28Z",
              "updatedAt": "2025-05-10T13:42:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6pyuig",
          "commit": {
            "abbreviatedOid": "6cbc2ae"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-18T02:55:20Z",
          "updatedAt": "2025-05-18T02:55:20Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n: A String that is the input to a cryptographic challenge-response pattern. This is traditionally called a nonce within OAuth.\r\n```",
              "createdAt": "2025-05-18T02:55:20Z",
              "updatedAt": "2025-05-18T02:55:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6pyvdU",
          "commit": {
            "abbreviatedOid": "6cbc2ae"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-18T02:57:11Z",
          "updatedAt": "2025-05-18T02:57:11Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\n* `challenge`: OPTIONAL. The `challenge` (challenge) claim MUST specify a String value that is provided by the authorization server for the client to include in the Client Attestation PoP JWT.\r\n```\r\n\r\nI know this language wasn't modified in the PR but just took the opportunity to make a minor edit.",
              "createdAt": "2025-05-18T02:57:11Z",
              "updatedAt": "2025-05-18T06:41:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6pyxYQ",
          "commit": {
            "abbreviatedOid": "6cbc2ae"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-18T03:01:44Z",
          "updatedAt": "2025-05-18T03:01:44Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Generally the challenge really provides the AS with an assurance around freshness when taken to the extreme this can then be used to detect replay attacks but certain implementations might allow for limited replay-ability of challenges for other reasons such as scalability.",
              "createdAt": "2025-05-18T03:01:44Z",
              "updatedAt": "2025-05-18T03:01:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6pzMXl",
          "commit": {
            "abbreviatedOid": "6cbc2ae"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-18T06:42:16Z",
          "updatedAt": "2025-05-18T06:42:16Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\r\nThis section defines an optional mechanism that allows a Client to request a fresh Challenge from the Authorization Server to be included in the Client Attestation PoP JWT. This construct may be similar or equivalent to a nonce, see [](terminology). The value of the challenge is opaque to the client.\r\n```",
              "createdAt": "2025-05-18T06:42:16Z",
              "updatedAt": "2025-05-18T06:44:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6pzMyc",
          "commit": {
            "abbreviatedOid": "6cbc2ae"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-18T06:48:09Z",
          "updatedAt": "2025-05-18T06:48:09Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "```suggestion\r\nAn Authorization Server MAY offer a challenge endpoint which it MUST signal support for via inclusion of the `challenge_endpoint` entry in the Authorisation Server metadata response as defined in {{RFC8414}}}. If the Authorization Server offers a challenge endpoint, the Client MUST retrieve a challenge and MUST use this challenge in the OAuth-Attestation-PoP as defined in (#client-attestation-pop-jwt).\r\n```\r\n\r\nJust checking we are intending all AS's MUST support RFC 8414 with this language, that could be somewhat strict.",
              "createdAt": "2025-05-18T06:48:09Z",
              "updatedAt": "2025-05-20T16:01:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6pzM0z",
          "commit": {
            "abbreviatedOid": "6cbc2ae"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-18T06:49:03Z",
          "updatedAt": "2025-05-18T06:49:03Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Agreed we should add an IANA registration request here for this element.",
              "createdAt": "2025-05-18T06:49:03Z",
              "updatedAt": "2025-05-18T06:49:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6pzNaN",
          "commit": {
            "abbreviatedOid": "6cbc2ae"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-18T06:55:24Z",
          "updatedAt": "2025-05-18T06:55:24Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "While we are doing the renaming, do we want maybe consider something that might give us a little more collision resistance e.g `oauth-client-attestation-challenge`? Don't feel too strongly about it",
              "createdAt": "2025-05-18T06:55:24Z",
              "updatedAt": "2025-05-18T06:55:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6qKMIx",
          "commit": {
            "abbreviatedOid": "6cbc2ae"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-20T16:04:31Z",
          "updatedAt": "2025-05-20T16:04:31Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "```suggestion\r\nAn Authorization Server MAY offer a challenge endpoint for Clients to fetch Challenges in the context of this specification. If the Authorization Server supports metadata as defined in {{RFC8414}}, it MUST signal support for the challenge endpoint by including the metadata entry `challenge_endpoint` containing the URL of the endpoint as its value. If the Authorization Server offers a challenge endpoint, the Client MUST retrieve a challenge and MUST use this challenge in the OAuth-Attestation-PoP as defined in (#client-attestation-pop-jwt).\r\n```\r\nAlternative as discussed with @c2bo to only mandate the challenge endpoint if metadata is used by AS.",
              "createdAt": "2025-05-20T16:04:31Z",
              "updatedAt": "2025-05-20T16:07:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6qKVRX",
          "commit": {
            "abbreviatedOid": "6cbc2ae"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-20T16:14:08Z",
          "updatedAt": "2025-05-20T16:14:08Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "@tplooker I feel the same, but DPoP also has no prefix",
              "createdAt": "2025-05-20T16:14:08Z",
              "updatedAt": "2025-05-20T16:14:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6qKacs",
          "commit": {
            "abbreviatedOid": "b067835"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-20T16:21:55Z",
          "updatedAt": "2025-05-20T16:21:55Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "exchage this with challenge_endpoint",
              "createdAt": "2025-05-20T16:21:55Z",
              "updatedAt": "2025-05-20T16:21:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6rDM4y",
          "commit": {
            "abbreviatedOid": "b067835"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T06:22:37Z",
          "updatedAt": "2025-05-27T06:22:37Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Similarity to OpenID4VCI: A Credential Issuer that requires c_nonce values to be incorporated into proofs in the Credential Request (see [Section 8.2](https://openid.github.io/OpenID4VCI/openid-4-verifiable-credential-issuance-wg-draft.html#credential-request)) MUST offer a Nonce Endpoint.",
              "createdAt": "2025-05-27T06:22:37Z",
              "updatedAt": "2025-05-27T06:22:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6rDQpF",
          "commit": {
            "abbreviatedOid": "ce8fc80"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T06:28:30Z",
          "updatedAt": "2025-05-27T06:28:31Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nThe Authorization Server MAY provide a fresh Challenge on any previous successful response using a HTTP header-based syntax. The HTTP header field parameter MUST be named \"Attestation-Challenge\" and contain the value of the Challenge. The Client MUST use this new Challenge for the next OAuth-Client-Attestation-PoP.\r\n```",
              "createdAt": "2025-05-27T06:28:31Z",
              "updatedAt": "2025-05-27T06:28:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6rDQ0N",
          "commit": {
            "abbreviatedOid": "ce8fc80"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T06:28:45Z",
          "updatedAt": "2025-05-27T06:28:46Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "```suggestion\r\nAttestation-Challenge: AYjcyMzY3ZDhiNmJkNTZ\r\n```",
              "createdAt": "2025-05-27T06:28:46Z",
              "updatedAt": "2025-05-27T06:28:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6sQQK0",
          "commit": {
            "abbreviatedOid": "bc574ab"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-02T21:08:00Z",
          "updatedAt": "2025-06-02T21:08:35Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "```suggestion\r\n* Field Name: Attestation-Challenge\r\n```",
              "createdAt": "2025-06-02T21:08:00Z",
              "updatedAt": "2025-06-02T21:08:35Z"
            },
            {
              "originalPosition": 103,
              "body": "```suggestion\r\nThe Authorization Server MAY provide a fresh Challenge on any previous successful response using a HTTP header-based syntax. The HTTP header field parameter MUST be named \"Attestation-Challenge\" and contain the value of the Challenge. The Client MUST use this new Challenge for the next OAuth-Client-Attestation-PoP. Note that this also includes error responses.\r\n```",
              "createdAt": "2025-06-02T21:08:12Z",
              "updatedAt": "2025-06-02T21:08:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6sToUv",
          "commit": {
            "abbreviatedOid": "43261f9"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-03T06:11:30Z",
          "updatedAt": "2025-06-03T06:11:31Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nAn error parameter according to Section 3 of {{RFC6750}} SHOULD be included to indicate why a request was declined. If the Client Attestation is absent or not using an expected server-provided challenge, the value `use_attestation_challenge` can be used to indicate that an attestation with a server-provided challenge was expected. If the attestation was present but could not be successfully verified, the value `invalid_client_attestation` is used.\r\n```",
              "createdAt": "2025-06-03T06:11:30Z",
              "updatedAt": "2025-06-03T06:11:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6sTqmP",
          "commit": {
            "abbreviatedOid": "43261f9"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-03T06:15:18Z",
          "updatedAt": "2025-06-03T06:15:18Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "say SHOULD instead of can be used/is used?",
              "createdAt": "2025-06-03T06:15:18Z",
              "updatedAt": "2025-06-03T06:15:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6shT47",
          "commit": {
            "abbreviatedOid": "f1fef28"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-03T23:54:40Z",
          "updatedAt": "2025-06-03T23:54:41Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Added in https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/112/commits/f1fef28c224fee753ea2c436463123cee76a96b9",
              "createdAt": "2025-06-03T23:54:41Z",
              "updatedAt": "2025-06-03T23:54:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6shUUV",
          "commit": {
            "abbreviatedOid": "f1fef28"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-03T23:56:18Z",
          "updatedAt": "2025-06-03T23:56:18Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Given the whole error parameter here is already a SHOULD i think its already covered, but im ok if we want to be more explicit.",
              "createdAt": "2025-06-03T23:56:18Z",
              "updatedAt": "2025-06-03T23:56:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6tmqrt",
          "commit": {
            "abbreviatedOid": "a43db1b"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-10T08:52:03Z",
          "updatedAt": "2025-06-10T08:52:03Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "```suggestion\r\n  - send the challenge as part of another previous response to the Client Instance of providing the challenge explicitly\r\n  - reuse an existing artefact of the Client Instance's session, e.g. the authorization code. This MUST be communicated out-of-band between Authorization Server and Client.\r\n```",
              "createdAt": "2025-06-10T08:52:03Z",
              "updatedAt": "2025-06-10T08:52:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6uXT4Q",
          "commit": {
            "abbreviatedOid": "e4b289e"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T15:57:53Z",
          "updatedAt": "2025-06-13T15:57:53Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "I don't think we need the SHOULD here. This section was more or less directly copied from other RFCs (I think it was DPoP) to stay consistent in language/behaviour.",
              "createdAt": "2025-06-13T15:57:53Z",
              "updatedAt": "2025-06-13T15:57:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6uXVLn",
          "commit": {
            "abbreviatedOid": "e4b289e"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I think this is in a decent state now - at least good enough to get more feedback. Should we post this to the mailing list and ask for feedback?",
          "createdAt": "2025-06-13T15:59:20Z",
          "updatedAt": "2025-06-13T16:02:17Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "```suggestion\r\nAuthorization Servers implementing measures to detect replay attacks as described in [](#security-consideration-replay) require efficient data structures to manage large amounts of challenges for use cases with high volumes of transactions. To limit the size of the data structure, the Authorization Server should use a sliding window, allowing Client Attestation PoPs within a certain time window, in which the seen `challenge` or `jti` values are stored, but discarded afterwards. To ensure security, Client Attestation PoPs outside this time window MUST be rejected by the Authorization Server. The allowed window is determined by the `iat` of the Client Attestation PoP and the sliding window time duration chosen by the Authorization Server. These data structures need to:\r\n```",
              "createdAt": "2025-06-13T15:59:20Z",
              "updatedAt": "2025-06-13T16:02:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6wdSjb",
          "commit": {
            "abbreviatedOid": "32254ad"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-26T03:59:58Z",
          "updatedAt": "2025-06-26T03:59:59Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "```suggestion\r\n  - manage a list of witnessed `challenge` values, similar to the previously described `jti` approach. Details how to implement such a data structure to maintain `challenge` values is given in [](#implementation-consideration-replay). This guarantees stronger replay protection with a challenge chosen by the Authorization Server itself, at the potential cost of an additional round-trip.\r\n```",
              "createdAt": "2025-06-26T03:59:59Z",
              "updatedAt": "2025-06-26T03:59:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6wdZj3",
          "commit": {
            "abbreviatedOid": "32254ad"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-26T04:22:09Z",
          "updatedAt": "2025-06-26T04:22:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6yDVtt",
          "commit": {
            "abbreviatedOid": "962e5d1"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Review as per @paulbastian's request. \ud83d\ude4f ",
          "createdAt": "2025-07-04T13:18:05Z",
          "updatedAt": "2025-07-04T13:48:25Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\n  \"challenge\": \"5c1a9e10-29ff-4c2b-ae73-57c0957c09c4\"\n```",
              "createdAt": "2025-07-04T13:18:05Z",
              "updatedAt": "2025-07-04T13:48:25Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\nAn error parameter according to Section 3 of {{RFC6750}} SHOULD be included to indicate why a request was declined. If the Client Attestation is absent or not using an expected server-provided challenge, the value `use_attestation_challenge` can be used to indicate that an attestation with a server-provided challenge was expected. If the attestation and proof of possession was present but could not be successfully verified, the value `invalid_client_attestation` is used.\n```",
              "createdAt": "2025-07-04T13:24:03Z",
              "updatedAt": "2025-07-04T13:48:25Z"
            },
            {
              "originalPosition": 84,
              "body": "Can we make it optionally REQUIRED for the purposes of this specification but generally OPTIONAL if this endpoint happens to find its use in future extensions?",
              "createdAt": "2025-07-04T13:28:50Z",
              "updatedAt": "2025-07-04T13:48:25Z"
            },
            {
              "originalPosition": 103,
              "body": "```suggestion\nThe Authorization Server MAY provide a fresh Challenge with any HTTP response using a HTTP header-based syntax. The HTTP header field parameter MUST be named \"OAuth-Client-Attestation-Challenge\" and contain the value of the Challenge. The Client MUST use this new Challenge for the next OAuth-Client-Attestation-PoP.\n```",
              "createdAt": "2025-07-04T13:30:11Z",
              "updatedAt": "2025-07-04T13:48:25Z"
            },
            {
              "originalPosition": 112,
              "body": "This is a very poor example as it indicates a 302 from an authorization endpoint to the user-agent which the client has no way of getting the `OAuth-Client-Attestation-Challenge` out of. Please use an example such as a 200 OK from the token endpoint.",
              "createdAt": "2025-07-04T13:32:31Z",
              "updatedAt": "2025-07-04T13:48:25Z"
            },
            {
              "originalPosition": 142,
              "body": "> An Authorization Server MUST implement measures to detect replay attacks by the Client Instance.\n\nThis seems overly strong. I don't think we need replay protection requirements any stronger for this auth method than we have for DPoP or private_key_jwt do. In there IIRC it's a recommendation at best.",
              "createdAt": "2025-07-04T13:40:55Z",
              "updatedAt": "2025-07-04T13:48:25Z"
            },
            {
              "originalPosition": 156,
              "body": "A fresh challenge should mean the `iat` value check may be relaxed. Just like in DPoP.\r\n\r\nQuoting from DPoP\r\n\r\n> Because clock skews between servers and clients may be large, servers MAY limit DPoP proof lifetimes by using server-provided nonce values containing the time at the server rather than comparing the client-supplied iat time to the time at the server. Nonces created in this way yield the same result even in the face of arbitrarily large clock skews.\r\n\r\n> The creation time of the JWT, as determined by either the iat claim or a server managed timestamp via the nonce claim, is within an acceptable window",
              "createdAt": "2025-07-04T13:43:48Z",
              "updatedAt": "2025-07-04T14:11:22Z"
            },
            {
              "originalPosition": 142,
              "body": "Furthermore, it should be permitted to re-use the same challenge if new one was not received or manually retrieved.\n\nQuoting from DPoP:\n\n> Server-provided nonces are an effective means for further reducing the chances for successful DPoP proof replay. Unlike cryptographic nonces, it is acceptable for clients to use the same nonce multiple times and for the server to accept the same nonce multiple times. As long as the jti value is tracked and duplicates are rejected for the lifetime of the nonce, there is no additional risk of token replay.\n\nWhat i'm looking for here is flexibility in the deployed protection proportional to the use case this method is deployed in.",
              "createdAt": "2025-07-04T13:46:18Z",
              "updatedAt": "2025-07-04T13:48:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6yF4UD",
          "commit": {
            "abbreviatedOid": "962e5d1"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-04T16:59:14Z",
          "updatedAt": "2025-07-04T16:59:14Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Does this look good to you @panva ?\r\n\r\n```suggestion\r\nHTTP/1.1 200 OK\r\nContent-Type: application/json\r\nCache-Control: no-store\r\nOAuth-Client-Attestation-Challenge: AYjcyMzY3ZDhiNmJkNTZ\r\n\r\n{\r\n  \"access_token\": \"2YotnFZFEjr1zCsicMWpAA\",\r\n  \"token_type\": \"Bearer\",\r\n  \"expires_in\": 3600\r\n}\r\n```",
              "createdAt": "2025-07-04T16:59:14Z",
              "updatedAt": "2025-07-05T07:39:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6yGOPi",
          "commit": {
            "abbreviatedOid": "962e5d1"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-04T17:41:18Z",
          "updatedAt": "2025-07-04T17:41:18Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Hmm do you have a proposal on wording for this?",
              "createdAt": "2025-07-04T17:41:18Z",
              "updatedAt": "2025-07-04T17:41:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6yGQja",
          "commit": {
            "abbreviatedOid": "962e5d1"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-04T17:50:20Z",
          "updatedAt": "2025-07-04T17:50:21Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Smth like this?\r\n\r\n> OPTIONAL. String containing a Challenge to be used in the OAuth-Attestation-PoP as defined in (#client-attestation-pop-jwt). REQUIRED if the authorization server supports {{this specification/attestation based client auth}}. ",
              "createdAt": "2025-07-04T17:50:21Z",
              "updatedAt": "2025-07-04T17:50:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6yGpCP",
          "commit": {
            "abbreviatedOid": "962e5d1"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-04T18:45:20Z",
          "updatedAt": "2025-07-04T18:45:20Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "```http\r\nHTTP/1.1 200 OK\r\nContent-Type: application/json\r\nCache-Control: no-store\r\nOAuth-Client-Attestation-Challenge: AYjcyMzY3ZDhiNmJkNTZ\r\n\r\n{\r\n  \"access_token\": \"2YotnFZFEjr1zCsicMWpAA\",\r\n  \"token_type\": \"Bearer\",\r\n  \"expires_in\": 3600\r\n}\r\n```",
              "createdAt": "2025-07-04T18:45:20Z",
              "updatedAt": "2025-07-04T18:46:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6yW5S4",
          "commit": {
            "abbreviatedOid": "66fc8ba"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T06:30:01Z",
          "updatedAt": "2025-07-07T06:30:01Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "```suggestion\r\n* attestation_challenge: REQUIRED if the authorization server supports Client Attestations and server provided challenges as described in this document. String containing a Challenge to be used in the OAuth-Attestation-PoP as defined in (#client-attestation-pop-jwt). The intention of this element not being required in other circumstances is to preserve the ability for the challenge endpoint to be used in other applications unrelated to client attestations.\r\n```",
              "createdAt": "2025-07-07T06:30:01Z",
              "updatedAt": "2025-07-07T06:30:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6yW6U1",
          "commit": {
            "abbreviatedOid": "1b3e83d"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T06:32:04Z",
          "updatedAt": "2025-07-07T06:32:04Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "```suggestion\r\nAn Authorization Server SHOULD implement measures to detect replay attacks by the Client Instance. In the context of this specification, this means to detect that an attacker is resending the same Client Attestation PoP JWT in multiple requests. The following options are RECOMMENDED for this client authentication method:\r\n```",
              "createdAt": "2025-07-07T06:32:04Z",
              "updatedAt": "2025-07-07T06:32:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6yW_fY",
          "commit": {
            "abbreviatedOid": "b442da8"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-07T06:41:23Z",
          "updatedAt": "2025-07-07T06:41:24Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "```suggestion\r\nBecause clock skews between servers and clients may be large, Authorization Servers MAY limit Client Attestation PoP lifetimes by using server-provided challenge values containing the time at the server rather than comparing the client-supplied iat time to the time at the server. Challenges created in this way yield the same result even in the face of arbitrarily large clock skews.\r\n\r\nIn any case the Authorization Server SHOULD ensure the freshness of the Client Attestation PoP by checking either the iat claim or if present the server provided challenge, is within an acceptable time window.\r\n```",
              "createdAt": "2025-07-07T06:41:23Z",
              "updatedAt": "2025-07-07T06:41:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 115,
      "id": "PR_kwDOJaEkaM6X7bUW",
      "title": "update example attestation jwt iss",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/115",
      "state": "MERGED",
      "author": "panva",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Updates the the `iss` claim in the Client Attestation JWT example to use a value that clearly describes it as the \"attester\" rather than a generic \"server\"\r\n\r\nAlso adds a blank space between the claim and value for NumericDate claims.",
      "createdAt": "2025-05-28T09:29:13Z",
      "updatedAt": "2025-06-04T10:28:14Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "0d1e8330a3490fbc9ad29b6e35b031288852dbf1",
      "headRepository": "panva/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "example-attester",
      "headRefOid": "4052fc8de35d08cfc083e82b106f5eaae5236721",
      "closedAt": "2025-06-04T08:53:03Z",
      "mergedAt": "2025-06-04T08:53:03Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "91861b0d00a86d2bf91d3e9ee9a04fa9333beefe"
      },
      "comments": [
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the PR @panva, could you also update the other examples that use the older payload?",
          "createdAt": "2025-06-03T06:19:40Z",
          "updatedAt": "2025-06-03T06:19:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6sfktV",
          "commit": {
            "abbreviatedOid": "4052fc8"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-03T20:05:25Z",
          "updatedAt": "2025-06-03T20:05:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6sgcJ7",
          "commit": {
            "abbreviatedOid": "4052fc8"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-03T21:36:27Z",
          "updatedAt": "2025-06-03T21:36:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6sm4ba",
          "commit": {
            "abbreviatedOid": "4052fc8"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-04T08:51:56Z",
          "updatedAt": "2025-06-04T08:51:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 120,
      "id": "PR_kwDOJaEkaM6Y61_w",
      "title": "Minor tweak to implementation considerations formatting",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/120",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #119\r\n\r\nThanks @macke.",
      "createdAt": "2025-06-04T00:04:16Z",
      "updatedAt": "2025-06-05T20:52:06Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "0d1e8330a3490fbc9ad29b6e35b031288852dbf1",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/issue-119",
      "headRefOid": "f735b5bb6501e6e34308ccfcc6c8e84b29c6cdfe",
      "closedAt": "2025-06-05T20:52:00Z",
      "mergedAt": "2025-06-05T20:52:00Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "78ed1e485e3f3fccc1e923b10d4de6b71e301f54"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Pretty sure the failing CI check is just because of the branch name I gave for this PR.",
          "createdAt": "2025-06-04T00:05:58Z",
          "updatedAt": "2025-06-04T00:05:58Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "seems to have some problem with the branch name tl/ for some reason?",
          "createdAt": "2025-06-05T10:12:54Z",
          "updatedAt": "2025-06-05T10:12:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6sm59Q",
          "commit": {
            "abbreviatedOid": "f735b5b"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-04T08:53:45Z",
          "updatedAt": "2025-06-04T08:53:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6s1flS",
          "commit": {
            "abbreviatedOid": "f735b5b"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-05T10:09:42Z",
          "updatedAt": "2025-06-05T10:09:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 121,
      "id": "PR_kwDOJaEkaM6ZLPRx",
      "title": "Add missing +jwt in Client Attestation PoP JWT example",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/121",
      "state": "MERGED",
      "author": "thomasdarimont",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Adds a missing+jwt in Client Attestation PoP JWT for consistency.",
      "createdAt": "2025-06-05T10:32:10Z",
      "updatedAt": "2025-06-24T06:37:10Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "91861b0d00a86d2bf91d3e9ee9a04fa9333beefe",
      "headRepository": "thomasdarimont/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "fix/fix-client-pop-jwt-example",
      "headRefOid": "cca859bb29432f4287d1aa4d624e0b179054fdb7",
      "closedAt": "2025-06-24T06:37:10Z",
      "mergedAt": "2025-06-24T06:37:10Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "513ebddcbd90240c27e95709a9d4c4e3e9f4e2e7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6tF2Tc",
          "commit": {
            "abbreviatedOid": "cca859b"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-06T07:04:53Z",
          "updatedAt": "2025-06-06T07:04:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6tGOFw",
          "commit": {
            "abbreviatedOid": "cca859b"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Good catch, thank you!",
          "createdAt": "2025-06-06T07:49:53Z",
          "updatedAt": "2025-06-06T07:49:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6tM6Bi",
          "commit": {
            "abbreviatedOid": "cca859b"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-06T19:00:34Z",
          "updatedAt": "2025-06-06T19:00:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 125,
      "id": "PR_kwDOJaEkaM6dZAEF",
      "title": "Remove expr from pop",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/125",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #124 ",
      "createdAt": "2025-07-04T07:46:54Z",
      "updatedAt": "2025-07-07T06:44:29Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "adf7c67a896d112b28c5f626f139d1e5824af56d",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "remove_expr_from_pop",
      "headRefOid": "b7c2d13f5d6332f9c1324fe9f35b91fb92b70f57",
      "closedAt": "2025-07-07T06:44:29Z",
      "mergedAt": "2025-07-07T06:44:29Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "a9166a2bd3aeb295eb350b85d042d7fdf6e577aa"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Easiest to just review the final commit on this PR https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/125/commits/09e2be735aeeec071d736d1aab6cd825995f4860 as this is dependent on #112 being merged ahead.",
          "createdAt": "2025-07-06T22:02:22Z",
          "updatedAt": "2025-07-06T22:02:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6yUkyE",
          "commit": {
            "abbreviatedOid": "09e2be7"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-06T22:04:11Z",
          "updatedAt": "2025-07-06T22:04:11Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\n* `jti`: REQUIRED. The `jti` (JWT identifier) claim MUST specify a unique identifier for the Client Attestation PoP. The authorization server can utilize the `jti` value for replay attack detection, see [](#security-consideration-replay).\r\n```\r\n\r\nIm not sure making it normative here helps, I'd prefer 'can' as its providing guidance on how to accomplish something.",
              "createdAt": "2025-07-06T22:04:11Z",
              "updatedAt": "2025-07-06T22:04:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6yUk6C",
          "commit": {
            "abbreviatedOid": "09e2be7"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "One minor suggestion otherwise LGTM.",
          "createdAt": "2025-07-06T22:04:30Z",
          "updatedAt": "2025-07-06T22:04:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6yXAxy",
          "commit": {
            "abbreviatedOid": "bd67cd1"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-07T06:43:47Z",
          "updatedAt": "2025-07-07T06:43:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 126,
      "id": "PR_kwDOJaEkaM6dokOt",
      "title": "Verification and Processing rules",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/126",
      "state": "MERGED",
      "author": "c2bo",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #122 ",
      "createdAt": "2025-07-06T13:59:29Z",
      "updatedAt": "2025-07-07T07:11:37Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "d9d72754470a4769deead9f43a1f4794ae3bca7f",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "122-processing-and-validation-rules",
      "headRefOid": "919c74ed9103f8735332bfcdf4dd65fd56b3dcd9",
      "closedAt": "2025-07-07T07:11:37Z",
      "mergedAt": "2025-07-07T07:11:37Z",
      "mergedBy": "c2bo",
      "mergeCommit": {
        "oid": "b89ad4139a902463d0ad046b3c8e04f373d5bd41"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6yTuHm",
          "commit": {
            "abbreviatedOid": "de64a7b"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-06T16:57:59Z",
          "updatedAt": "2025-07-06T17:01:37Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "maybe leave in MAC, if we want to enable repudiable signatures based on ECDH-MAC and alike. Also not sure what local means in \"per local policy\"\r\n```suggestion\r\n4. The alg JOSE Header Parameter for both JWTs indicates a registered asymmetric digital signature algorithm {{IANA.JOSE.ALGS}}, is not none, is supported by the application, and is acceptable per local policy.\r\n```",
              "createdAt": "2025-07-06T16:57:59Z",
              "updatedAt": "2025-07-06T17:01:37Z"
            },
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nUpon receiving a Client Attestation, the receiving server MUST ensure the following conditions and rules:\r\n```",
              "createdAt": "2025-07-06T16:58:14Z",
              "updatedAt": "2025-07-06T17:01:37Z"
            },
            {
              "originalPosition": 73,
              "body": "should add checking of iat/exp of the Client Attestaiton JWT?",
              "createdAt": "2025-07-06T17:00:25Z",
              "updatedAt": "2025-07-06T17:01:37Z"
            },
            {
              "originalPosition": 73,
              "body": "I think we need to mention replay attack detection here as well",
              "createdAt": "2025-07-06T17:01:22Z",
              "updatedAt": "2025-07-06T17:01:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6yXPLp",
          "commit": {
            "abbreviatedOid": "e741ce3"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-07T07:02:24Z",
          "updatedAt": "2025-07-07T07:02:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6yXPcW",
          "commit": {
            "abbreviatedOid": "4946f15"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM as a first cut, will require further refinement.",
          "createdAt": "2025-07-07T07:02:47Z",
          "updatedAt": "2025-07-07T07:02:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 127,
      "id": "PR_kwDOJaEkaM6dpMEV",
      "title": "Update paul's affiliation",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/127",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-06T16:51:56Z",
      "updatedAt": "2025-07-07T06:44:39Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "513ebddcbd90240c27e95709a9d4c4e3e9f4e2e7",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "affiliation_paul",
      "headRefOid": "9119494fa95a948e6335c76d0cdfe6a1949937fa",
      "closedAt": "2025-07-07T06:44:39Z",
      "mergedAt": "2025-07-07T06:44:39Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "d9d72754470a4769deead9f43a1f4794ae3bca7f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6yUj0e",
          "commit": {
            "abbreviatedOid": "9119494"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-06T22:00:27Z",
          "updatedAt": "2025-07-06T22:00:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6yXBPr",
          "commit": {
            "abbreviatedOid": "9119494"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-07T06:44:33Z",
          "updatedAt": "2025-07-07T06:44:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 128,
      "id": "PR_kwDOJaEkaM6dqNll",
      "title": "Editorial nit about usage of client attestation outside of OAuth",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/128",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #117 ",
      "createdAt": "2025-07-06T22:11:30Z",
      "updatedAt": "2025-07-07T06:47:52Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "d9d72754470a4769deead9f43a1f4794ae3bca7f",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/issue_117",
      "headRefOid": "71c0c559f07c57d1009f6f674bde485af9714de8",
      "closedAt": "2025-07-07T06:47:52Z",
      "mergedAt": "2025-07-07T06:47:52Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "15de548a46326d94117ca8c13a8304b53088cfc6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6yXCVK",
          "commit": {
            "abbreviatedOid": "71c0c55"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-07T06:46:14Z",
          "updatedAt": "2025-07-07T06:46:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6yXDIN",
          "commit": {
            "abbreviatedOid": "71c0c55"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-07T06:47:29Z",
          "updatedAt": "2025-07-07T06:47:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 129,
      "id": "PR_kwDOJaEkaM6dqOUd",
      "title": "Clarify that client_id in client attestation MUST be consistent with token request",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/129",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #81 ",
      "createdAt": "2025-07-06T22:17:41Z",
      "updatedAt": "2025-07-07T06:53:13Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "15de548a46326d94117ca8c13a8304b53088cfc6",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "tl/issue_81",
      "headRefOid": "b7390de4b2454fc2da31a3bc689422854029bc16",
      "closedAt": "2025-07-07T06:53:13Z",
      "mergedAt": "2025-07-07T06:53:13Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "2d6228cde6b7d329a681e603dc96fb85527bb035"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6yXFxL",
          "commit": {
            "abbreviatedOid": "9974a1c"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-07T06:51:32Z",
          "updatedAt": "2025-07-07T06:51:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6yXF_G",
          "commit": {
            "abbreviatedOid": "c500f62"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-07T06:51:55Z",
          "updatedAt": "2025-07-07T06:51:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 132,
      "id": "PR_kwDOJaEkaM6ecrqI",
      "title": "fix using use_attestation_challenge error parameter code for missing \u2026",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/132",
      "state": "CLOSED",
      "author": "mickrau",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "solves #131 ",
      "createdAt": "2025-07-11T08:16:57Z",
      "updatedAt": "2025-08-12T06:14:35Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "b89ad4139a902463d0ad046b3c8e04f373d5bd41",
      "headRepository": "mickrau/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "issue_131",
      "headRefOid": "d55a321f49973ef0f7aa8b7991d566f3432cd8b4",
      "closedAt": "2025-08-12T06:14:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @mickrau, although I'm in favour of #135 here which builds on this PR and provides a little more clarity around when these errors should be returned.",
          "createdAt": "2025-07-13T21:31:32Z",
          "updatedAt": "2025-07-13T21:31:32Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "Closing since #135 was merged",
          "createdAt": "2025-08-12T06:14:35Z",
          "updatedAt": "2025-08-12T06:14:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6zXWAJ",
          "commit": {
            "abbreviatedOid": "d55a321"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-11T08:29:50Z",
          "updatedAt": "2025-07-11T08:29:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6zhB4e",
          "commit": {
            "abbreviatedOid": "d55a321"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-11T19:48:12Z",
          "updatedAt": "2025-07-11T19:48:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6zndRN",
          "commit": {
            "abbreviatedOid": "d55a321"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-12T18:57:47Z",
          "updatedAt": "2025-07-12T18:59:20Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nWhen validation errors are encountered the following error codes are defined for use in either Authorization Server authenticated endpoint error responses or Resource Server error responses.\r\n\r\n- `use_attestation_challenge` MUST be used when the Client Attestation PoP JWT is not using an expected server-provided challenge. When used this error code MUST be accompanied by the `OAuth-Client-Attestation-Challenge` HTTP header field parameter (as described in [](#challenge-header)).\r\n- `invalid_client_attestation` MAY be used if the attestation or its proof of possession could not be successfully verified.\r\n```",
              "createdAt": "2025-07-12T18:57:47Z",
              "updatedAt": "2025-07-12T19:11:19Z"
            },
            {
              "originalPosition": 5,
              "body": "And change\n\n```\n## Providing Challenges on Previous Responses\n```\n\nto \n\n```\n## Providing Challenges on Previous Responses {#challenge-header}\n```",
              "createdAt": "2025-07-12T18:59:12Z",
              "updatedAt": "2025-07-12T18:59:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6zngxx",
          "commit": {
            "abbreviatedOid": "d55a321"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-12T19:13:54Z",
          "updatedAt": "2025-07-12T19:13:54Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I am making this suggestion because a) this section is referenced from Token and PAR endpoint sections and linking 6750 error handling is invalid.\r\n\r\nMaking `use_attestation_challenge` a MUST use when challenge validations fail just makes sense and having to have it accompanied by `OAuth-Client-Attestation-Challenge` as well. I don't mind defining `invalid_client_attestation` but only as a MAY because on the AS authenticated endpoints the convention is already `invalid_client` for client authentication failures.",
              "createdAt": "2025-07-12T19:13:54Z",
              "updatedAt": "2025-07-12T19:13:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6znhTH",
          "commit": {
            "abbreviatedOid": "d55a321"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-12T19:21:59Z",
          "updatedAt": "2025-07-12T19:22:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I've opened #135 as an alternative to this PR with all suggestions applied.",
              "createdAt": "2025-07-12T19:22:00Z",
              "updatedAt": "2025-07-12T19:22:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 134,
      "id": "PR_kwDOJaEkaM6epHOW",
      "title": "require iat in PoP",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/134",
      "state": "MERGED",
      "author": "panva",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The draft has a lot to say about utilizing `iat` and `jti` for replay detection, to that end the `iat` must be present.\r\n\r\ncloses #133",
      "createdAt": "2025-07-12T18:50:41Z",
      "updatedAt": "2025-07-16T06:27:11Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "b89ad4139a902463d0ad046b3c8e04f373d5bd41",
      "headRepository": "panva/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "iat",
      "headRefOid": "45b6ff620698263c2cfa0e1df7e12ae0af6f5ca7",
      "closedAt": "2025-07-16T06:27:11Z",
      "mergedAt": "2025-07-16T06:27:11Z",
      "mergedBy": "c2bo",
      "mergeCommit": {
        "oid": "bfb8948607e5b87a8ef35822f3566d27951456f1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6znrhO",
          "commit": {
            "abbreviatedOid": "260f4d5"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Yeah, especially with the removal of exp, mandating iat seems like a good idea.",
          "createdAt": "2025-07-12T20:48:03Z",
          "updatedAt": "2025-07-12T20:48:31Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n-07\r\n\r\n```",
              "createdAt": "2025-07-12T20:48:03Z",
              "updatedAt": "2025-07-12T20:48:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6zn5ed",
          "commit": {
            "abbreviatedOid": "45b6ff6"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-12T22:05:31Z",
          "updatedAt": "2025-07-12T22:05:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6zqr2f",
          "commit": {
            "abbreviatedOid": "45b6ff6"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-13T21:05:05Z",
          "updatedAt": "2025-07-13T21:05:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 135,
      "id": "PR_kwDOJaEkaM6epLsO",
      "title": "Updates to error handling",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/135",
      "state": "MERGED",
      "author": "panva",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Additional to #131 this updates the error section a bit more since it is referenced from later Token and PAR endpoint sections and linking to RFC6750 error handling is just not right then.\r\n\r\nMaking `use_attestation_challenge` a MUST use when challenge validations fail just makes sense and having to have it accompanied by `OAuth-Client-Attestation-Challenge` as well. I don't mind defining `invalid_client_attestation` but only as a MAY because on the AS authenticated endpoints the convention is already invalid_client for client authentication failures, for the RS responses it's probably fine.\r\n\r\ncloses #131",
      "createdAt": "2025-07-12T19:18:39Z",
      "updatedAt": "2025-08-12T06:48:15Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "b89ad4139a902463d0ad046b3c8e04f373d5bd41",
      "headRepository": "panva/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "update-error-responses",
      "headRefOid": "d4703ba9ffcd804c42ba70fca585e6ac724c8180",
      "closedAt": "2025-08-12T06:14:02Z",
      "mergedAt": "2025-08-12T06:14:02Z",
      "mergedBy": "paulbastian",
      "mergeCommit": {
        "oid": "edd887a4bc7507cd7fbd7e6df7714769e7df7369"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Approved, but then had a couple of suggestions to add.",
          "createdAt": "2025-07-13T22:06:32Z",
          "updatedAt": "2025-07-13T22:06:32Z"
        },
        {
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "body": "Supersedes #132",
          "createdAt": "2025-07-30T12:02:36Z",
          "updatedAt": "2025-07-30T12:02:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6zqtQ6",
          "commit": {
            "abbreviatedOid": "3575297"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-13T21:31:49Z",
          "updatedAt": "2025-07-13T21:31:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6zquAX",
          "commit": {
            "abbreviatedOid": "3575297"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-13T21:45:09Z",
          "updatedAt": "2025-07-13T21:45:09Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n- `invalid_client_attestation` MAY be used if the attestation or its proof of possession could not be successfully verified. Alternatively the more general `invalid_client` error code as defined in {{RFC6749}} MAY also be used.\r\n\r\nIn the event of errors due to situations not described above, Authorization and Resource Servers MUST follow the guidance of {{RFC6749}} and {{RFC6750}} of when to return suitable Error Responses. \r\n```\r\n\r\nI'm 50/50 on this but feel like it might be worthwhile clarifying the underlying pre-existing error behaviour as per standard OAuth2 applies for all other situations.",
              "createdAt": "2025-07-13T21:45:09Z",
              "updatedAt": "2025-07-13T22:02:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM6zquI8",
          "commit": {
            "abbreviatedOid": "3575297"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-07-13T21:47:48Z",
          "updatedAt": "2025-07-13T21:47:48Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nWhen validation errors specifically related to the use of client attestations are encountered the following additional error codes are defined for use in either Authorization Server authenticated endpoint error responses or Resource Server error responses. These error codes are used to return an Error Response as defined in Section 5.2 of {{RFC6749}}.\r\n```",
              "createdAt": "2025-07-13T21:47:48Z",
              "updatedAt": "2025-07-13T21:54:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM63DRYK",
          "commit": {
            "abbreviatedOid": "d4703ba"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Could you add an entry to the document history? Looks good otherwise imho",
          "createdAt": "2025-07-30T12:01:42Z",
          "updatedAt": "2025-07-30T12:01:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM63_P4-",
          "commit": {
            "abbreviatedOid": "d4703ba"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "approved., history missing and let's not forget to add Micha to acknowledgments from #132 ",
          "createdAt": "2025-08-05T06:40:59Z",
          "updatedAt": "2025-08-05T06:40:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM63_P_k",
          "commit": {
            "abbreviatedOid": "d4703ba"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-08-05T06:41:11Z",
          "updatedAt": "2025-08-05T06:41:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 136,
      "id": "PR_kwDOJaEkaM6eq9Zm",
      "title": "various fixes",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/136",
      "state": "MERGED",
      "author": "panva",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes\r\n\r\n- invalid use of internal references\r\n- missing cache-control in challenge endpoint response example\r\n- challenge endpoint parameters not being an unordered list",
      "createdAt": "2025-07-13T07:49:22Z",
      "updatedAt": "2025-07-16T06:28:05Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "b89ad4139a902463d0ad046b3c8e04f373d5bd41",
      "headRepository": "panva/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "formatting-fixes",
      "headRefOid": "e62cbdd083d27478961afe6e7851d1405589cb0e",
      "closedAt": "2025-07-16T06:28:05Z",
      "mergedAt": "2025-07-16T06:28:05Z",
      "mergedBy": "c2bo",
      "mergeCommit": {
        "oid": "2ae44a229aeae0fd0819c8ea1ad71dcbd581aa9b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM6zpZU6",
          "commit": {
            "abbreviatedOid": "e62cbdd"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-13T08:20:29Z",
          "updatedAt": "2025-07-13T08:20:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6zqoJZ",
          "commit": {
            "abbreviatedOid": "e62cbdd"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-13T19:57:55Z",
          "updatedAt": "2025-07-13T19:57:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM6zqryJ",
          "commit": {
            "abbreviatedOid": "e62cbdd"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-07-13T21:03:56Z",
          "updatedAt": "2025-07-13T21:03:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 138,
      "id": "PR_kwDOJaEkaM6jL7JA",
      "title": "Update draft-ietf-oauth-attestation-based-client-auth.md",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/138",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-08-12T06:16:02Z",
      "updatedAt": "2025-08-12T06:19:25Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "edd887a4bc7507cd7fbd7e6df7714769e7df7369",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "pb/editorial",
      "headRefOid": "33bf543188e37da618988c33b6920fed5651f054",
      "closedAt": "2025-08-12T06:19:25Z",
      "mergedAt": "2025-08-12T06:19:25Z",
      "mergedBy": "c2bo",
      "mergeCommit": {
        "oid": "693d9e79e39657f783bd6594a0faada663dd810a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM65Sz20",
          "commit": {
            "abbreviatedOid": "33bf543"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-08-12T06:16:36Z",
          "updatedAt": "2025-08-12T06:16:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM65Sz4J",
          "commit": {
            "abbreviatedOid": "33bf543"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-08-12T06:16:39Z",
          "updatedAt": "2025-08-12T06:16:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 141,
      "id": "PR_kwDOJaEkaM6mm5QZ",
      "title": "remove restrictions to not allow MAC-based algorithms",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/141",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #130 ",
      "createdAt": "2025-09-03T09:12:40Z",
      "updatedAt": "2025-09-03T14:21:18Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "693d9e79e39657f783bd6594a0faada663dd810a",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "130-allow-mac-as-signature-algorithms",
      "headRefOid": "c1409f00cc45b626f478a40085e694f7452d6d9f",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM69hzkP",
          "commit": {
            "abbreviatedOid": "c1409f0"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-03T09:19:42Z",
          "updatedAt": "2025-09-03T09:19:42Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "That would still not allow MAC I believe?\r\n\r\nSomething like this is used in JWT RFC:\r\n```\r\n[...] be digitally signed or integrity protected with a Message Authentication Code (MAC) [...]\r\n```",
              "createdAt": "2025-09-03T09:19:42Z",
              "updatedAt": "2025-09-03T09:51:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM69kEJ3",
          "commit": {
            "abbreviatedOid": "c1409f0"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-03T12:14:02Z",
          "updatedAt": "2025-09-03T12:14:02Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "The question is if we want to allow public key derived MACs or MACs in general? The former relies on asymmetric mechanism and would be included imo",
              "createdAt": "2025-09-03T12:14:02Z",
              "updatedAt": "2025-09-03T12:14:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM69mP7b",
          "commit": {
            "abbreviatedOid": "c1409f0"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-09-03T14:21:18Z",
          "updatedAt": "2025-09-03T14:21:18Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I haven't thought too much about this yet, but my gut feeling would be to allow MAC - people need to understand their deployments and requirements, but I could see something like this used in a context where attestation server and AS are operated by the same entity.\r\nI would agree for the PoP (to not allow MACs)",
              "createdAt": "2025-09-03T14:21:18Z",
              "updatedAt": "2025-09-03T14:22:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 142,
      "id": "PR_kwDOJaEkaM6mqNT7",
      "title": "70 register as and client metadata for algorithm negotiation of attestations and pops",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/142",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #35\r\nCloses #66 \r\nCloses #70 ",
      "createdAt": "2025-09-03T14:01:22Z",
      "updatedAt": "2025-09-03T14:41:09Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "693d9e79e39657f783bd6594a0faada663dd810a",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "70-register-as-and-client-metadata-for-algorithm-negotiation-of-attestations-and-pops",
      "headRefOid": "a9915910dce861fa895416bbacef724f9cc7c9d2",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 143,
      "id": "PR_kwDOJaEkaM6mqT0A",
      "title": "make draft standards track and update Paul's affiliation",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/143",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially fix #140 ",
      "createdAt": "2025-09-03T14:09:46Z",
      "updatedAt": "2025-09-03T14:15:41Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "693d9e79e39657f783bd6594a0faada663dd810a",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "pb-affiliation-and-standards-track",
      "headRefOid": "f1d5d7a1dfa3a90b47c3021c44ead0d8a1a31e24",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM69mILs",
          "commit": {
            "abbreviatedOid": "f1d5d7a"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-03T14:15:41Z",
          "updatedAt": "2025-09-03T14:15:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 144,
      "id": "PR_kwDOJaEkaM6mqgkP",
      "title": "check client_id at PAR endpoint",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/144",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially closes #140 ",
      "createdAt": "2025-09-03T14:24:52Z",
      "updatedAt": "2025-09-03T14:37:39Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "693d9e79e39657f783bd6594a0faada663dd810a",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "pb-par-check-client_id",
      "headRefOid": "718fa2952b5e2ec08f31048337be6a7b3d351d32",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM69mjiJ",
          "commit": {
            "abbreviatedOid": "718fa29"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-03T14:37:39Z",
          "updatedAt": "2025-09-03T14:37:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 145,
      "id": "PR_kwDOJaEkaM6mqnC0",
      "title": "Pb clarify refresh token binding",
      "url": "https://github.com/oauth-wg/draft-ietf-oauth-attestation-based-client-auth/pull/145",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially closes #140 ",
      "createdAt": "2025-09-03T14:33:27Z",
      "updatedAt": "2025-09-03T14:39:10Z",
      "baseRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "baseRefName": "main",
      "baseRefOid": "693d9e79e39657f783bd6594a0faada663dd810a",
      "headRepository": "oauth-wg/draft-ietf-oauth-attestation-based-client-auth",
      "headRefName": "pb-clarify-refresh-token-binding",
      "headRefOid": "2fb03874c99a97c32b2445aae5e02a9aead86f83",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM69mfys",
          "commit": {
            "abbreviatedOid": "4705b9b"
          },
          "author": "c2bo",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-03T14:35:39Z",
          "updatedAt": "2025-09-03T14:35:39Z",
          "comments": []
        }
      ]
    }
  ]
}